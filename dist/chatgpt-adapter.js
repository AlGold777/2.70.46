// Auto-generated by scripts/build-bundles.js @ 2025-12-02T17:36:09.120Z
(function () {
  const globalObject = typeof window !== 'undefined' ? window : self;
  globalObject.SelectorConfigRegistry = globalObject.SelectorConfigRegistry || {};
  if (globalObject.SelectorConfigRegistry.GPT) return;

  globalObject.SelectorConfigRegistry.GPT = {
    versions: [],
    emergencyFallbacks: {
      composer: [
        'textarea[data-id="root"]',
        'textarea[name="prompt"]',
        'textarea',
        'div[role="textbox"]',
        '[contenteditable="true"]'
      ],
      sendButton: [
        'button[data-testid="send-button"]',
        'button[aria-label*="Send"]',
        'button[type="submit"]',
        'button'
      ],
      response: [
        '[data-testid="conversation-panel"]',
        '[data-testid="chat-history"]',
        'main',
        'section'
      ]
    },
    observationDefaults: {
      rootSelector: 'main',
      targetSelectors: [
        '[data-testid="conversation-panel"]',
        '[data-testid="chat-history"]',
        '.markdown',
        '.prose'
      ],
      stabilizationDelayMs: 1800,
      endGenerationMarkers: [
        { selector: '[data-testid="stop-button"]', type: 'disappear' }
      ]
    }
  };
})();

;
// content-chatgpt.js - Enhanced Version with Advanced Features from Grok Integration

//-- Защита от дублирования --//
const resolveExtensionVersion = () => {
  try {
    return chrome?.runtime?.getManifest?.()?.version || 'unknown';
  } catch (_) {
    return 'unknown';
  }
};
if (window.chatgptContentScriptLoaded) {
    console.warn('[content-chatgpt] Script already loaded, skipping duplicate initialization');
    throw new Error('Duplicate script load prevented');
}
window.chatgptContentScriptLoaded = {
  timestamp: Date.now(),
  version: resolveExtensionVersion(),
  source: 'content-chatgpt'
};
console.log('[content-chatgpt] First load, initializing...');
//-- Конец защиты --//

(function () {
  const MODEL = "GPT";
  let isEvaluatorMode = false;
  let lastResponseSnapshot = '';
  const getLifecycleMode = () => {
    if (typeof window !== 'undefined') {
      if (window.__humanoidActivityMode) return window.__humanoidActivityMode;
      if (document?.visibilityState === 'hidden') return 'background';
    }
    return 'interactive';
  };
  const buildLifecycleContext = (prompt = '', extra = {}) => ({
    promptLength: prompt?.length || 0,
    evaluator: Boolean(extra.evaluator),
    mode: extra.mode || getLifecycleMode()
  });
  const getForceStopRegistry = () => {
    if (window.__humanoidForceStopRegistry) {
      return window.__humanoidForceStopRegistry;
    }
    const handlers = new Set();
    window.__humanoidForceStopRegistry = {
      register(handler) {
        if (typeof handler !== 'function') return () => {};
        handlers.add(handler);
        return () => handlers.delete(handler);
      },
      run(reason) {
        handlers.forEach((fn) => {
          try { fn(reason); } catch (_) {}
        });
      }
    };
    return window.__humanoidForceStopRegistry;
  };
  const registerForceStopHandler = (handler) => getForceStopRegistry().register(handler);
  const handleForceStopMessage = (traceId) => {
    if (traceId && window.HumanoidEvents?.stop) {
      try {
        window.HumanoidEvents.stop(traceId, { status: 'forced', reason: 'background-force-stop' });
      } catch (_) {}
    }
    getForceStopRegistry().run('background-force-stop');
  };

  const cleanupScope = window.HumanoidCleanup?.createScope?.(`${MODEL.toLowerCase()}-content`) || {
    trackInterval: (id) => id,
    trackTimeout: (id) => id,
    trackObserver: (observer) => observer,
    trackAbortController: (controller) => controller,
    register: () => () => {},
    addEventListener: () => () => {},
    cleanup: () => {},
    isCleaned: () => false,
    getReason: () => null
  };
  let scriptStopped = false;
  const stopContentScript = (reason = 'manual-stop') => {
    if (scriptStopped) return cleanupScope.getReason?.() || reason;
    scriptStopped = true;
    console.warn('[content-chatgpt] Cleanup triggered:', reason);
    try {
      getForceStopRegistry().run(reason);
    } catch (_) {}
    try {
      cleanupScope.cleanup?.(reason);
    } catch (err) {
      console.warn('[content-chatgpt] Cleanup scope failed', err);
    }
    try {
      window.chatgptContentScriptLoaded = null;
    } catch (_) {}
    return reason;
  };
  window.__cleanup_chatgpt = stopContentScript;
  cleanupScope.addEventListener?.(window, 'pagehide', () => stopContentScript('pagehide'));
  cleanupScope.addEventListener?.(window, 'beforeunload', () => stopContentScript('beforeunload'));

const sleep = (ms) => new Promise((r) => setTimeout(r, ms));
const getHumanoid = () => (typeof window !== 'undefined' ? window.Humanoid : null);
const isUserInteracting = () => {
  if (document.hidden) return true;
  const el = document.activeElement;
  if (!el) return false;
  const tag = el.tagName;
  return tag === 'INPUT' || tag === 'TEXTAREA' || el.isContentEditable;
};
const keepAliveMutex = (() => {
  const key = '__keepAliveMutex';
  if (window[key]) return window[key];
  let locked = false;
  const queue = [];
  const run = async (fn) => {
    if (locked) await new Promise((res) => queue.push(res));
    locked = true;
    try { return await fn(); } finally {
      locked = false;
      const next = queue.shift();
      if (next) next();
    }
  };
  const mutex = { run };
  window[key] = mutex;
  return mutex;
})();

const runLifecycle = (source, context, executor) => {
  if (typeof window.withHumanoidActivity === 'function') {
    return window.withHumanoidActivity(source, context, executor);
  }
  return executor({
    traceId: null,
    heartbeat: () => {},
    stop: () => {},
    error: () => {}
  });
};

const pipelineExpectedLength = (text = '') => {
  const len = (text || '').length;
  if (len > 4000) return 'veryLong';
  if (len > 2000) return 'long';
  if (len > 800) return 'medium';
  return 'short';
};

async function tryChatgptPipeline(promptText = '', lifecycle = {}) {
  const { heartbeat, stop } = lifecycle || {};
  if (!window.UnifiedAnswerPipeline) return null;
  heartbeat?.({
    stage: 'start',
    expectedLength: pipelineExpectedLength(promptText),
    pipeline: 'UnifiedAnswerPipeline'
  });
  try {
    const pipeline = new window.UnifiedAnswerPipeline('gpt', {
      expectedLength: pipelineExpectedLength(promptText)
    });
    const result = await pipeline.execute();
    if (result?.success && result.answer) {
      heartbeat?.({
        stage: 'success',
        answerLength: result.answer.length,
        pipeline: 'UnifiedAnswerPipeline'
      });
      if (typeof stop === 'function') {
        await stop({
          status: 'success',
          source: 'pipeline',
          answer: result.answer,
          answerLength: result.answer.length
        });
      }
      return result;
    }
    heartbeat?.({
      stage: 'empty',
      status: 'no-answer',
      pipeline: 'UnifiedAnswerPipeline'
    });
  } catch (err) {
    heartbeat?.({
      stage: 'error',
      error: err?.message || String(err),
      pipeline: 'UnifiedAnswerPipeline'
    });
    console.warn('[content-chatgpt] UnifiedAnswerPipeline failed, falling back to manual watcher', err);
  }
  return null;
}

  function triggerInputEvents(element) {
    element.dispatchEvent(new Event('input', { bubbles: true }));
    element.dispatchEvent(new Event('change', { bubbles: true }));
  }

  async function fallbackTypeInput(input, text) {
    try {
      input.focus({ preventScroll: true });
    } catch (_) {
      input.focus?.();
    }
    await sleep(300);
    if (input.tagName === 'TEXTAREA') {
      input.value = '';
      triggerInputEvents(input);
      await sleep(100);
      input.value = text;
    } else {
      input.textContent = '';
      triggerInputEvents(input);
      await sleep(100);
      input.textContent = text;
    }
    triggerInputEvents(input);
    await sleep(150);
  }

  async function humanTypeInput(input, text, options = {}) {
    const humanoid = getHumanoid();
    if (humanoid?.typeText) {
      try {
        await humanoid.typeText(input, text, options);
        return;
      } catch (err) {
        console.warn('[content-chatgpt] Humanoid.typeText failed, falling back', err);
      }
    }
    await fallbackTypeInput(input, text);
  }

  async function humanClick(element) {
    const humanoid = getHumanoid();
    if (!element) return;
    if (humanoid?.click) {
      try {
        await humanoid.click(element);
        return;
      } catch (err) {
        console.warn('[content-chatgpt] Humanoid.click failed, falling back', err);
      }
    }
    element.click();
  }

async function humanRead(duration = 480) {
  const humanoid = getHumanoid();
  if (humanoid?.readPage) {
    try {
      await humanoid.readPage(duration);
      } catch (err) {
        console.warn('[content-chatgpt] Humanoid.readPage failed', err);
      }
  }
}

const startDriftFallback = (intensity = 'soft') => {
  const humanoid = getHumanoid();
  if (humanoid?.startAntiSleepDrift) {
    humanoid.startAntiSleepDrift(intensity);
    return;
  }
  window.scrollBy({ top: (Math.random() > 0.5 ? 1 : -1) * (intensity === 'hard' ? 24 : 12), behavior: 'auto' });
};

const stopDriftFallback = () => {
  const humanoid = getHumanoid();
  humanoid?.stopAntiSleepDrift?.();
};

const createKeepAliveHeartbeat = (source) => {
  let traceId = null;
  let cleanupTimer = null;
  return (meta = {}) => {
    const lifecycle = window.HumanoidEvents;
    if (!lifecycle?.start) return;
    if (!traceId) {
      try {
        traceId = lifecycle.start(source, { mode: 'anti-sleep', source });
      } catch (err) {
        console.warn(`[${source}] keepalive trace failed`, err);
        return;
      }
    }
    try {
      lifecycle.heartbeat(traceId, meta.progress || 0, Object.assign({ phase: 'keepalive-pulse' }, meta));
    } catch (err) {
      console.warn(`[${source}] keepalive heartbeat failed`, err);
    }
    if (cleanupTimer) clearTimeout(cleanupTimer);
    cleanupTimer = setTimeout(() => {
      try { lifecycle.stop(traceId, { status: 'idle' }); } catch (_) {}
      traceId = null;
    }, 8000);
  };
};
const emitKeepAliveHeartbeat = createKeepAliveHeartbeat(`${MODEL.toLowerCase()}:keepalive`);

const runAntiSleepPulse = (intensity = 'soft') => {
  emitKeepAliveHeartbeat({ action: 'keep-alive-ping', intensity, model: MODEL });
  const delta = intensity === 'hard' ? 28 : intensity === 'medium' ? 16 : 8;
  try {
    const Toolkit = window.__UniversalScrollToolkit;
    if (Toolkit) {
      const tk = new Toolkit({ idleThreshold: 800, driftStepMs: 40 });
      tk.keepAliveTick?.((Math.random() > 0.5 ? 1 : -1) * delta);
      return;
    }
  } catch (_) {}
  if (!window.__organicDriftFallback) {
      window.__organicDriftFallback = (() => {
        let rafId = null;
        return (speed) => {
          if (rafId) cancelAnimationFrame(rafId);
          const duration = 1000 + Math.random() * 600;
          const start = performance.now();
          let phase = Math.random() * Math.PI * 2;
          const step = (ts) => {
            const elapsed = ts - start;
            phase += 0.07;
            const offset = Math.sin(phase) * 0.8 * speed;
            window.scrollBy({ top: offset, behavior: 'auto' });
            if (elapsed < duration) {
              rafId = requestAnimationFrame(step);
            } else {
              rafId = null;
            }
          };
          rafId = requestAnimationFrame(step);
        };
      })();
  }
  window.__organicDriftFallback(intensity === 'hard' ? 1.5 : intensity === 'medium' ? 1.1 : 0.8);
  startDriftFallback(intensity);
};

const stopAntiSleep = () => {
  stopDriftFallback();
};

const chatgptScrollCoordinator = window.ScrollCoordinator
  ? new window.ScrollCoordinator({
      source: `${MODEL.toLowerCase()}-smart-scroll`,
      getLifecycleMode,
      registerForceStopHandler,
      startDrift: () => startDriftFallback('soft'),
      stopDrift: () => stopDriftFallback(),
      logPrefix: `[${MODEL}] SmartScroll`
    })
  : null;

async function withSmartScroll(asyncOperation, options = {}) {
  if (chatgptScrollCoordinator) {
    return chatgptScrollCoordinator.run(asyncOperation, options);
  }
  return asyncOperation();
}

  const MONITORED_HOSTS = new Set(['chat.openai.com', 'api.openai.com']);
  window.setupHumanoidFetchMonitor?.(MODEL, ({ status, retryAfter, url }) => {
    if (status !== 429) return;
    let hostname = '';
    try {
      hostname = new URL(url || '', window.location.origin).hostname;
    } catch (_) {}
    if (hostname && !MONITORED_HOSTS.has(hostname)) return;
    const waitTime = retryAfter ? parseInt(retryAfter, 10) * 1000 || 60000 : 60000;
    chrome.runtime.sendMessage({
      type: 'LLM_RESPONSE',
      llmName: MODEL,
      answer: 'Error: Rate limit detected. Please wait.',
      error: {
        type: 'rate_limit',
        message: `HTTP 429 detected. Suggested wait time: ${waitTime}ms`,
        waitTime
      }
    });
  });

  //-- Advanced Content Cleaning System --//
  class ContentCleaner {
      constructor() {
          this.cleaningRules = this.initializeCleaningRules();
          this.cleaningStats = { elementsRemoved: 0, charactersRemoved: 0, rulesApplied: 0 };
      }

      initializeCleaningRules() {
          return {
              uiPhrases: [
                  /\b(Send|Menu|Settings|New chat|Clear|Like|Reply|Copy|Share|Follow|Subscribe)\b/gi,
                  /\b(Upload|Download|Save|Delete|Edit|Search|Filter|Sort)\b/gi,
                  /\b(ChatGPT|OpenAI|GPT|Grok|Claude|Gemini|Perplexity)\b/gi
              ],
              timePatterns: [
                  /\b\d{1,2}:\d{2}\s*(?:AM|PM)?\b/gi,
                  /\b\d+\s*(?:hours?|minutes?|seconds?)\s*ago\b/gi,
                  /\b(?:Just now|Yesterday|Today|Tomorrow)\b/gi
              ],
              formattingSymbols: [
                  /\xa0/g, 
                  /&nbsp;/g, 
                  /&[a-z]+;/gi
              ],
              urlPatterns: [
                  /\bhttps?:\/\/[^\s<>"]+?\b/gi, 
                  /\bwww\.[^\s<>"]+?\b/gi
              ]
          };
      }

      cleanContent(content, options = {}) {
          const startTime = Date.now();
          this.cleaningStats = { elementsRemoved: 0, charactersRemoved: 0, rulesApplied: 0 };
          console.log('[ContentCleaner] Starting content cleaning, initial length:', content.length);

          let textContent = content;
          if (/<\/?[a-z][\s\S]*>/i.test(content)) {
              try {
                  const parser = new DOMParser();
                  const doc = parser.parseFromString(content, 'text/html');
                  doc.querySelectorAll('script,style,svg,canvas,noscript,header,footer,nav,aside,[aria-hidden="true"]').forEach(el => el.remove());
                  textContent = doc.body?.textContent || '';
              } catch (err) {
                  console.warn('[ContentCleaner] DOMParser failed in ChatGPT cleaner, falling back to text extraction', err);
                  const fallbackDiv = document.createElement('div');
                  fallbackDiv.textContent = content;
                  textContent = fallbackDiv.textContent || '';
              }
          }

          let cleanedContent = this.cleanTextContent(textContent, options);

          if (options.maxLength && cleanedContent.length > options.maxLength) {
              cleanedContent = this.applyLengthLimit(cleanedContent, options.maxLength);
          }

          const processingTime = Date.now() - startTime;
          console.log(`[ContentCleaner] Cleaning completed in ${processingTime}ms. Final length: ${cleanedContent.length}`);
          return cleanedContent;
      }

      cleanTextContent(textContent, options) {
          let cleanedText = textContent;
          const allRules = [
              ...this.cleaningRules.uiPhrases,
              ...this.cleaningRules.timePatterns,
              ...this.cleaningRules.urlPatterns,
              ...this.cleaningRules.formattingSymbols
          ];
          
          allRules.forEach(pattern => {
              const originalLength = cleanedText.length;
              cleanedText = cleanedText.replace(pattern, ' ');
              this.recordRemoval(originalLength - cleanedText.length);
          });

          return this.finalNormalization(cleanedText);
      }

      recordRemoval(charactersRemoved) {
          if (charactersRemoved > 0) {
              this.cleaningStats.charactersRemoved += charactersRemoved;
              this.cleaningStats.rulesApplied++;
          }
      }

      applyLengthLimit(content, maxLength) {
          if (content.length <= maxLength) return content;
          const truncated = content.substring(0, maxLength);
          const lastSentenceEnd = Math.max(
              truncated.lastIndexOf('. '), 
              truncated.lastIndexOf('! '),
              truncated.lastIndexOf('? '), 
              truncated.lastIndexOf('\n\n')
          );
          if (lastSentenceEnd > maxLength * 0.7) {
              return truncated.substring(0, lastSentenceEnd + 1) + '\n\n[Content truncated]';
          }
          return truncated + '\n\n[Content truncated]';
      }

      finalNormalization(text) {
          return text
              .replace(/\n\s*\n\s*\n/g, '\n\n')
              .replace(/[ \t]+/g, ' ')
              .trim();
      }

      getCleaningStats() {
          return { ...this.cleaningStats };
      }
  }
  
  window.contentCleaner = new ContentCleaner();

  //-- Metrics Collection System --//
  class MetricsCollector {
      constructor() {
          this.metrics = {
              operations: [],
              timings: {},
              errors: []
          };
          this.startTime = Date.now();
          this.operationCounter = 0;
          
          this.reportTimer = cleanupScope.trackInterval(setInterval(() => this.sendReport(), 300000));
      }

      startOperation(name, context = {}) {
          const opId = `${name}_${this.operationCounter++}_${Date.now()}`;
          const operation = {
              id: opId,
              name,
              start: Date.now(),
              end: null,
              duration: null,
              success: null,
              metadata: context || {},
              lifecycleTraceId: null
          };
          const events = window.HumanoidEvents;
          if (events?.start) {
              try {
                  operation.lifecycleTraceId = events.start(`metrics:${name}`, {
                      mode: getLifecycleMode(),
                      operation: name
                  });
              } catch (_) {}
          }
          this.metrics.operations.push(operation);
          return opId;
      }

      endOperation(opId, success, metadata = {}) {
          const op = this.metrics.operations.find(o => o.id === opId);
          if (op) {
              op.end = Date.now();
              op.duration = op.end - op.start;
              op.success = success;
              op.metadata = metadata;
              if (op.lifecycleTraceId && window.HumanoidEvents?.stop) {
                  try {
                      window.HumanoidEvents.stop(op.lifecycleTraceId, {
                          status: success ? 'success' : 'failed',
                          metadata
                      });
                  } catch (_) {}
                  op.lifecycleTraceId = null;
              }
          }
      }

      recordTiming(key, duration) {
          if (!this.metrics.timings[key]) {
              this.metrics.timings[key] = [];
          }
          this.metrics.timings[key].push(duration);
      }

      recordError(error, context, operationId = null) {
          this.metrics.errors.push({
              message: error?.message || String(error),
              context: context,
              timestamp: Date.now()
          });
          if (this.metrics.errors.length > 10) {
              this.metrics.errors.shift();
          }
          if (operationId) {
              const op = this.metrics.operations.find(o => o.id === operationId);
              if (op?.lifecycleTraceId && window.HumanoidEvents?.error) {
                  try {
                      window.HumanoidEvents.error(op.lifecycleTraceId, error, true);
                  } catch (_) {}
              }
          }
      }

      getReport() {
          const totalOps = this.metrics.operations.length;
          const successfulOps = this.metrics.operations.filter(op => op.success === true).length;
          const failedOps = this.metrics.operations.filter(op => op.success === false).length;

          const avgTimings = {};
          for (const key in this.metrics.timings) {
              const times = this.metrics.timings[key];
              avgTimings[key] = times.reduce((a, b) => a + b, 0) / times.length;
          }

          return {
              uptime: Date.now() - this.startTime,
              operations: {
                  total: totalOps,
                  successful: successfulOps,
                  failed: failedOps,
                  successRate: totalOps > 0 ? `${((successfulOps / totalOps) * 100).toFixed(2)}%` : '0%'
              },
              timings: avgTimings,
              errors: this.metrics.errors.slice(-10),
              timestamp: Date.now()
          };
      }

      sendReport() {
          try {
              chrome.runtime.sendMessage({
                  type: 'METRICS_REPORT',
                  llmName: MODEL,
                  metrics: this.getReport()
              });
          } catch (e) {
              console.warn('[MetricsCollector] Failed to send report:', e);
          }
      }
  }

  const metricsCollector = new MetricsCollector();

  //-- ОРИГИНАЛЬНАЯ ПРОСТАЯ ЛОГИКА ИЗ content-chatgpt.js --//

  function isElementInteractable(element) {
      if (!element) return false;
      if (element.offsetParent === null) return false;
      if (element.getAttribute('disabled') !== null) return false;
      if (element.disabled === true) return false; // Добавлена проверка свойства
      if (element.style.display === 'none') return false;
      if (element.style.visibility === 'hidden') return false;
      if (element.style.opacity === '0') return false; // Добавлена проверка прозрачности
      
      const rect = element.getBoundingClientRect();
      if (rect.width === 0 || rect.height === 0) return false; // Должен иметь размер
      
      // Упрощенная проверка видимости (убрана строгая проверка viewport)
      return rect.top < window.innerHeight && rect.bottom > 0 &&
             rect.left < window.innerWidth && rect.right > 0;
  }

  // Self-Healing Selector Logic (упрощенная версия)
  async function findAndCacheElement(selectorKey, selectorArray, timeout = 30000) {
      const storageKey = `selector_cache_${MODEL}_${selectorKey}`;
      try {
          const result = await chrome.storage.local.get(storageKey);
          const cachedSelector = result[storageKey];
          if (cachedSelector) {
              const el = document.querySelector(cachedSelector);
              if (el && isElementInteractable(el)) {
                  console.log(`[Self-Healing] Found element using cached selector for '${selectorKey}'`);
                  return el;
              }
          }
      } catch (e) { console.warn('[content-chatgpt] Storage access failed, continuing without cache'); }

      const start = Date.now();
      while (Date.now() - start < timeout) {
          for (const selector of selectorArray) {
              try {
                  const el = document.querySelector(selector);
                  if (el && isElementInteractable(el)) {
                      console.log(`[Self-Healing] Found element with '${selector}'. Caching for '${selectorKey}'.`);
                      try { await chrome.storage.local.set({ [storageKey]: selector }); } catch (e) {}
                      return el;
                  }
              } catch (error) { console.warn(`[content-chatgpt] Selector error for ${selector}:`, error); }
          }
          await sleep(1000);
      }
      throw new Error(`Element not found for '${selectorKey}' with any selector`);
  }

  function sendResult(text, ok = true) {
    const messageType = isEvaluatorMode ? 'EVALUATOR_RESPONSE' : 'LLM_RESPONSE';
    
    const message = {
      type: messageType,
      answer: ok ? text : `Ошибка: ${text}`
    };
    
    if (!isEvaluatorMode) {
      message.llmName = MODEL;
    }
    
    console.log(`[CONTENT-GPT] Sending ${messageType}:`, text.substring(0, 100) + '...');
    chrome.runtime.sendMessage(message);
  }

  // ОРИГИНАЛЬНАЯ ФУНКЦИЯ ОБРАБОТКИ (с улучшенной очисткой)
  async function injectAndGetResponse(prompt) {
    return runLifecycle('chatgpt:inject', buildLifecycleContext(prompt, { evaluator: isEvaluatorMode }), async (activity) => {
      console.log(`[CONTENT-GPT] Starting ChatGPT injection process, evaluator mode: ${isEvaluatorMode}`);
      try {
        // Ждём загрузки UI
        await sleep(2000); // Увеличено время ожидания

        activity.heartbeat(0.05, { phase: 'ui-analysis' });

        // ДИАГНОСТИКА: проверяем что есть на странице
        console.log('[DEBUG] Page analysis:');
        console.log('- All textareas:', document.querySelectorAll('textarea').length);
        console.log('- All contenteditable:', document.querySelectorAll('[contenteditable="true"]').length);
        console.log('- Form elements:', document.querySelectorAll('form').length);
        
        // Ищем поле ввода с РАСШИРЕННЫМИ селекторами
        const inputSelectors = [
          // Modern ChatGPT selectors
          'textarea[id^="prompt-textarea"]',
          'textarea[placeholder*="Message"]',
          'textarea[placeholder*="message"]',
          'textarea[data-id="root"]',
          
          // Legacy selectors
          'textarea[data-testid="conversation-input"]',
          'textarea[aria-label="Message ChatGPT"]',
          'textarea#prompt-textarea',
          'textarea.prompt-textarea',
          
          // ContentEditable variants
          'div[contenteditable="true"][role="textbox"]',
          'div[contenteditable="true"][data-testid*="composer"]',
          'div[contenteditable="true"]',
          
          // Fallback: ANY textarea or contenteditable
          'textarea',
          '[contenteditable="true"]'
        ];

        console.log('[CONTENT-GPT] Looking for input field...');
        activity.heartbeat(0.15, { phase: 'input-search' });
        
        // Пробуем найти вручную если Self-Healing не сработает
        let inputField = null;
        try {
            inputField = await findAndCacheElement('inputField', inputSelectors, 10000);
        } catch (err) {
            console.warn('[CONTENT-GPT] Self-Healing failed, trying manual search...');
            
            // Manual fallback: ищем любой видимый textarea/contenteditable
            const allTextareas = Array.from(document.querySelectorAll('textarea'));
            const allContentEditables = Array.from(document.querySelectorAll('[contenteditable="true"]'));
            const allInputs = [...allTextareas, ...allContentEditables];
            
            console.log(`[DEBUG] Found ${allInputs.length} potential input fields`);
            
            for (const el of allInputs) {
                if (isElementInteractable(el)) {
                    console.log('[DEBUG] Found interactable input:', {
                        tag: el.tagName,
                        id: el.id,
                        placeholder: el.placeholder,
                        contenteditable: el.getAttribute('contenteditable')
                    });
                    inputField = el;
                    break;
                }
            }
            
            if (!inputField) {
                throw { type: 'selector_not_found', message: 'ChatGPT input field not found after manual search' };
            }
        }
        
        console.log('[CONTENT-GPT] Input field found. Injecting prompt...');
        await humanRead(600);
        await humanTypeInput(inputField, prompt, { wpm: 125 });
        activity.heartbeat(0.35, { phase: 'typing' });

        console.log('[CONTENT-GPT] Prompt injected, waiting for UI to update...');
        await sleep(2000); // Увеличено время ожидания активации кнопки

        // Ищем кнопку отправки с РАСШИРЕННЫМИ селекторами
        const sendButtonSelectors = [
          // Modern ChatGPT
          'button[data-testid="send-button"]',
          'button[data-testid="fruitjuice-send-button"]',
          'button[data-testid="composer-send-button"]',
          'button[data-testid="send-message-button"]',
          'button[data-testid="pegasus-send-button"]',
          'button[data-testid*="send-button"]',
          'button[data-testid*="send"]',
          'button[aria-label*="Send"]',
          'button[aria-label*="message"]',
          'button[class*="SendButton"]',
          
          // Icon-based
          'button:has(svg[data-testid*="send"])',
          'button:has(svg[data-icon="send"])',
          'button:has(svg[data-icon="arrow-up"])',
          
          // Role-based (new UI sometimes renders div role="button")
          'div[role="button"][data-testid*="send"]',
          'div[role="button"][aria-label*="send" i]',
          'div[role="button"]:has(svg[data-icon="send"])',
          
          // Form-based
          'form button[type="submit"]',
          'form button:not([disabled])',
          'form [role="button"][aria-label*="send" i]',
          
          // Positional fallback
          'button:not([disabled])',
          '[role="button"]:not([aria-disabled="true"])'
        ];

        console.log('[CONTENT-GPT] Looking for send button...');
        activity.heartbeat(0.45, { phase: 'send-button-search' });
        
        let sendButton = null;
        try {
            sendButton = await findAndCacheElement('sendButton', sendButtonSelectors, 10000);
        } catch (err) {
            console.warn('[CONTENT-GPT] Send button not found via selectors, trying smart search...');
            
            // Smart search: find button near the input field
            const inputRect = inputField.getBoundingClientRect();
            const allButtons = Array.from(document.querySelectorAll('button:not([disabled]), [role="button"]:not([aria-disabled="true"])'));
            
            console.log(`[DEBUG] Checking ${allButtons.length} buttons for proximity to input`);
            
            for (const btn of allButtons) {
                if (isElementInteractable(btn)) {
                    const btnRect = btn.getBoundingClientRect();
                    
                    // Button should be close to input (within 200px)
                    const distance = Math.sqrt(
                        Math.pow(btnRect.left - inputRect.right, 2) + 
                        Math.pow(btnRect.top - inputRect.top, 2)
                    );
                    
                    if (distance < 200) {
                        const hasIcon = btn.querySelector('svg') !== null;
                        const btnText = btn.textContent?.trim().toLowerCase() || '';
                        
                        console.log(`[DEBUG] Button candidate (distance: ${distance.toFixed(0)}px):`, {
                            hasIcon,
                            text: btnText.substring(0, 20),
                            ariaLabel: btn.getAttribute('aria-label')
                        });
                        
                        // Prefer buttons with icons or send-related text
                        if (hasIcon || btnText.includes('send') || distance < 100) {
                            sendButton = btn;
                            console.log('[CONTENT-GPT] Found send button via smart search');
                            break;
                        }
                    }
                }
            }
            
            if (!sendButton) {
                throw { type: 'selector_not_found', message: 'ChatGPT send button not found' };
            }
        }
        
        console.log('[CONTENT-GPT] Clicking send button');
        await humanClick(sendButton);
        activity.heartbeat(0.5, { phase: 'send-dispatched' });

        console.log('[CONTENT-GPT] Message sent, waiting for response...');
        activity.heartbeat(0.6, { phase: 'waiting-response' });
        let pipelineAnswer = null;
        await tryChatgptPipeline(prompt, {
          heartbeat: (meta = {}) => activity.heartbeat(0.75, Object.assign({ phase: 'pipeline' }, meta)),
          stop: async ({ answer }) => {
            console.log('[CONTENT-GPT] UnifiedAnswerPipeline captured answer, skipping legacy watcher');
            const cleanedResponse = window.contentCleaner.cleanContent(answer, {
                maxLength: 50000
            });
            lastResponseSnapshot = cleanedResponse;
            pipelineAnswer = cleanedResponse;
            activity.stop({ status: 'success', answerLength: cleanedResponse.length, source: 'pipeline' });
            return cleanedResponse;
          }
        });
        if (pipelineAnswer) {
          return pipelineAnswer;
        }
        const response = await withSmartScroll(() => waitForResponse(120000), {
          keepAliveInterval: 2000,
          operationTimeout: 300000,
          debug: false
        });

        // Очистка ответа с помощью нового модуля
        const cleanedResponse = window.contentCleaner.cleanContent(response, {
            maxLength: 50000
        });
        lastResponseSnapshot = cleanedResponse;

        console.log(`[CONTENT-GPT] Process completed. Response length: ${cleanedResponse.length}`);
        activity.heartbeat(0.9, { phase: 'response-processed' });
        activity.stop({ status: 'success', answerLength: cleanedResponse.length });
        return cleanedResponse;

      } catch (error) {
        if (error?.code === 'background-force-stop') {
          activity.error(error, false);
          throw error;
        }
        activity.error(error, true);
        throw error;
      }
    });
  }

  // УЛУЧШЕННАЯ ФУНКЦИЯ ОЖИДАНИЯ (MutationObserver + стабильность)
  async function waitForResponse(timeout = 120000) {
    console.log('[CONTENT-GPT] Waiting for response (observer mode)…');
    const stopSelectors = [
      'button[aria-label*="Stop"]',
      'button[aria-label*="stop"]'
    ];
    const messageSelectors = [
      'div[data-message-author-role="assistant"]',
      'div.agent-turn',
      'div[class*="agent-turn"]',
      'div[data-testid="conversation-turn"]',
      'article[data-testid*="conversation"]',
      '.group\/turn-messages',
      '[class*="turn-messages"]'
    ];
    const contentSelectors = [
      '.markdown',
      '[class*="markdown"]',
      '.prose',
      '[class*="prose"]',
      '.text-message',
      '[class*="message-content"]',
      'article',
      'div[class*="flex"]',
      'div',
      'p'
    ];

    const readAssistantText = () => {
      let nodes = null;
      for (const sel of messageSelectors) {
        try {
          nodes = document.querySelectorAll(sel);
          if (nodes.length) break;
        } catch (_) {}
      }
      if (!nodes || !nodes.length) return null;
      const last = nodes[nodes.length - 1];
      let contentNode = null;
      for (const sel of contentSelectors) {
        try {
          const candidate = last.querySelector(sel);
          if (candidate && candidate.innerText?.trim().length > 10) {
            contentNode = candidate;
            break;
          }
        } catch (_) {}
      }
      if (!contentNode) contentNode = last;
      let currentText = '';
      if (contentNode.innerHTML && contentNode.innerHTML.trim().length > 10) {
        currentText = contentNode.innerHTML.trim();
      } else if (contentNode.innerText && contentNode.innerText.trim().length > 10) {
        currentText = contentNode.innerText.trim();
      } else if (contentNode.textContent && contentNode.textContent.trim().length > 10) {
        currentText = contentNode.textContent.trim();
      }
      if (!currentText) return null;
      const isGenerating = stopSelectors.some((sel) => document.querySelector(sel));
      return { text: currentText, isGenerating };
    };

    return new Promise((resolve, reject) => {
      let lastText = '';
      let stableCount = 0;
      let settled = false;
      const observer = cleanupScope.trackObserver(new MutationObserver(() => evaluate()));
      const intervalId = cleanupScope.trackInterval(setInterval(() => evaluate(), 1200));
      const timerId = cleanupScope.trackTimeout(setTimeout(() => {
        if (settled) return;
        settled = true;
        observer.disconnect();
        clearInterval(intervalId);
        if (lastText) {
          console.warn('[CONTENT-GPT] Timeout reached, returning last snippet.');
          resolve(lastText);
        } else {
          reject(new Error('Timeout: No response received from ChatGPT'));
        }
      }, timeout));

      const cleanup = (value) => {
        if (settled) return;
        settled = true;
        observer.disconnect();
        clearInterval(intervalId);
        clearTimeout(timerId);
        resolve(value);
      };

      const evaluate = () => {
        const snapshot = readAssistantText();
        if (!snapshot) return;
        const { text, isGenerating } = snapshot;
        if (isGenerating) {
          lastText = text;
          stableCount = 0;
          return;
        }
        if (!lastText) lastText = text;
        if (text === lastText) {
          stableCount += 1;
          if (stableCount >= 2) {
            console.log('[CONTENT-GPT] Response stabilized.');
            cleanup(text);
          }
        } else {
          lastText = text;
          stableCount = 0;
        }
      };

      observer.observe(document.body, { childList: true, subtree: true, characterData: true });
      evaluate();
    });
  }

  // ОБРАБОТЧИК СООБЩЕНИЙ (с улучшенной обработкой)
  const onRuntimeMessage = (message, sender, sendResponse) => {
    if (!message) return false;
    console.log('[CONTENT-GPT] Received:', message.type);
    if (message?.type === 'STOP_AND_CLEANUP') {
      handleForceStopMessage(message.payload?.traceId);
      stopContentScript('manual-toggle');
      if (typeof sendResponse === 'function') {
        sendResponse({ status: 'cleaned', llmName: MODEL });
      }
      return false;
    }
    if (message?.type === 'HUMANOID_FORCE_STOP') {
      handleForceStopMessage(message.payload?.traceId);
      if (typeof sendResponse === 'function') {
        sendResponse({ status: 'force_stop_ack' });
      }
      return false;
    }
    if (message?.action === 'getResponses') {
        const pingId = generatePingId();
        sendResponse?.({ status: 'manual_refresh_started', pingId });
        (async () => {
            try {
                const latestMarkup = grabLatestAssistantMarkup();
                const cleaned = window.contentCleaner.cleanContent(latestMarkup, { maxLength: 50000 });
                if (cleaned && cleaned !== lastResponseSnapshot) {
                    lastResponseSnapshot = cleaned;
                    chrome.runtime.sendMessage({ type: 'LLM_RESPONSE', llmName: MODEL, answer: cleaned });
                    chrome.runtime.sendMessage({ type: 'MANUAL_PING_RESULT', llmName: MODEL, status: 'success', pingId });
                } else {
                    chrome.runtime.sendMessage({ type: 'MANUAL_PING_RESULT', llmName: MODEL, status: 'unchanged', pingId });
                }
            } catch (err) {
                if (err?.code === 'background-force-stop') {
                    chrome.runtime.sendMessage({
                        type: 'MANUAL_PING_RESULT',
                        llmName: MODEL,
                        status: 'aborted',
                        pingId
                    });
                    return;
                }
                chrome.runtime.sendMessage({
                    type: 'MANUAL_PING_RESULT',
                    llmName: MODEL,
                    status: 'failed',
                    error: err?.message || 'manual refresh failed',
                    pingId
                });
            }
        })();
        return true;
    }
    
    if (message?.type === 'HEALTH_CHECK_PING') {
        sendResponse({ type: 'HEALTH_CHECK_PONG', pingId: message.pingId, llmName: MODEL });
        return true;
    }
    
    if (message?.type === 'ANTI_SLEEP_PING') {
        if (isUserInteracting()) {
          stopAntiSleep();
          return false;
        }
        keepAliveMutex.run(async () => {
          runAntiSleepPulse(message.intensity || 'soft');
        });
        return false;
    }
    
    if (message?.type === 'GET_ANSWER' || message.type === 'GET_FINAL_ANSWER') {
      isEvaluatorMode = message.isEvaluator || false;
      console.log(`[CONTENT-GPT] Received ${message.type}, isEvaluator: ${isEvaluatorMode}`);

      injectAndGetResponse(message.prompt)
        .then((resp) => {
          if (message.isFireAndForget) {
              sendResponse({ status: 'success_fire_and_forget' });
              return;
          }
          
          const responseType = message.type === 'GET_ANSWER' ? 'LLM_RESPONSE' : 'FINAL_LLM_RESPONSE';
          
          // Отправка статистики очистки
          const stats = window.contentCleaner.getCleaningStats();
          chrome.runtime.sendMessage({
              type: 'CONTENT_CLEANING_STATS', 
              llmName: MODEL, 
              stats: stats, 
              timestamp: Date.now()
          });
          
          if (isEvaluatorMode) {
              sendResult(resp, true);
          } else {
              chrome.runtime.sendMessage({ type: responseType, llmName: MODEL, answer: resp });
          }
          
          sendResponse({ status: 'success' });
        })
        .catch((err) => {
          if (err?.code === 'background-force-stop') {
              sendResponse({ status: 'force_stopped' });
              return;
          }
          const errorMessage = err.message || err?.message || String(err);
          const responseType = message.type === 'GET_ANSWER' ? 'LLM_RESPONSE' : 'FINAL_LLM_RESPONSE';
          
          if (isEvaluatorMode) {
              sendResult(errorMessage, false);
          } else {
              chrome.runtime.sendMessage({
                  type: responseType, 
                  llmName: MODEL, 
                  answer: `Error: ${errorMessage}`,
                  error: { type: err.type || 'generic_error', message: errorMessage }
              });
          }
          
          sendResponse({ status: 'error', message: errorMessage });
        });
      return true; // Важно для асинхронной обработки
    }
    
    return false;
  };
  chrome.runtime.onMessage.addListener(onRuntimeMessage);
  cleanupScope.register?.(() => {
    try {
      chrome.runtime.onMessage.removeListener(onRuntimeMessage);
    } catch (_) {}
  });

// БАЗОВЫЙ HEARTBEAT ОТКЛЮЧЕН: используем event-driven anti-sleep
function startBasicHeartbeat() { return; }

  console.log(`[CONTENT-GPT] Enhanced script loaded and ready`);
})();
