// Auto-generated by scripts/build-bundles.js @ 2025-12-02T17:36:09.131Z
(function () {
  const globalObject = typeof window !== 'undefined' ? window : self;
  globalObject.SelectorConfigRegistry = globalObject.SelectorConfigRegistry || {};
  if (globalObject.SelectorConfigRegistry['Le Chat']) return;

  globalObject.SelectorConfigRegistry['Le Chat'] = {
    versions: [],
    emergencyFallbacks: {
      composer: [
        'textarea[aria-label*="prompt"]',
        'textarea[aria-label*="message"]',
        'textarea[placeholder*="message"]',
        'textarea[data-testid*="composer"]',
        'div[data-testid*="composer"] textarea',
        'div[data-testid*="composer"] [contenteditable="true"]',
        'div.ProseMirror',
        'div[class*="ProseMirror"]',
        'div[contenteditable="true"][data-placeholder]',
        'div[contenteditable="true"][role="textbox"]',
        'textarea',
        '[contenteditable="true"]',
        'div[role="textbox"]',
        'div[role="textbox"][contenteditable="true"]'
      ],
      sendButton: [
        'button[aria-label*="Send"]',
        'button[aria-label*="send message"]',
        'button[type="submit"]',
        'button:has(svg[data-icon="send"])',
        'button[data-testid*="send"]',
        'button'
      ],
      response: [
        'main article',
        '.chat-response',
        '.prose',
        '[data-testid*="assistant"] article',
        'main'
      ]
    },
    observationDefaults: {
      rootSelector: 'main',
      targetSelectors: [
        '.chat-response',
        'main article',
        '.prose',
        '[data-testid*="assistant"] article'
      ],
      stabilizationDelayMs: 1800,
      endGenerationMarkers: [
        { selector: '[aria-busy="true"]', type: 'disappear' }
      ]
    }
  };
})();

;
// content-lechat.js – AllCopy v6 "Adaptive Resilient Hybrid"
// Структурная основа: как в content-grok (дубликат-guard, IIFE, self-healing, cleaner, 429).
// Адаптация: селекторы и специфика UI LeChat (chat.mistral.ai/chat).

// ============================== IIFE START ==============================
//-- 2.1. Улучшенная защита от дублирования с версионированием --//
(function () {
  const SCRIPT_VERSION = 'v6.1.2'; // Bumped version for LeChat selector fix
  const SCRIPT_NAME = 'content-lechat';
  const resolveExtensionVersion = () => {
    try {
      return chrome?.runtime?.getManifest?.()?.version || 'unknown';
    } catch (_) {
      return 'unknown';
    }
  };
  
  // Проверка на дубликат
  if (window.leChatContentScriptLoaded) {
    console.warn(`[${SCRIPT_NAME}] Already loaded (v${window.__SCRIPT_VERSION}), aborting`);
    throw new Error('Duplicate script load prevented');
  }
  
  // Установка флагов
  window.leChatContentScriptLoaded = {
    timestamp: Date.now(),
    version: SCRIPT_VERSION,
    manifestVersion: resolveExtensionVersion(),
    source: SCRIPT_NAME
  };
  window.__SCRIPT_VERSION = SCRIPT_VERSION;
  window.__SCRIPT_NAME = SCRIPT_NAME;
  
  console.log(`[${SCRIPT_NAME}] Version ${SCRIPT_VERSION} initializing...`);

  const MODEL = 'Le Chat';
  const getLifecycleMode = () => {
    if (typeof window !== 'undefined') {
      if (window.__humanoidActivityMode) return window.__humanoidActivityMode;
      if (document?.visibilityState === 'hidden') return 'background';
    }
    return 'interactive';
  };
  const buildLifecycleContext = (prompt = '', extra = {}) => ({
    promptLength: prompt?.length || 0,
    evaluator: Boolean(extra.evaluator),
    mode: extra.mode || getLifecycleMode()
  });
  const getForceStopRegistry = () => {
    if (window.__humanoidForceStopRegistry) {
      return window.__humanoidForceStopRegistry;
    }
    const handlers = new Set();
    window.__humanoidForceStopRegistry = {
      register(handler) {
        if (typeof handler !== 'function') return () => {};
        handlers.add(handler);
        return () => handlers.delete(handler);
      },
      run(reason) {
        handlers.forEach((fn) => {
          try { fn(reason); } catch (_) {}
        });
      }
    };
    return window.__humanoidForceStopRegistry;
  };
  const registerForceStopHandler = (handler) => getForceStopRegistry().register(handler);
  const handleForceStopMessage = (traceId) => {
    if (traceId && window.HumanoidEvents?.stop) {
      try {
        window.HumanoidEvents.stop(traceId, { status: 'forced', reason: 'background-force-stop' });
      } catch (_) {}
    }
    getForceStopRegistry().run('background-force-stop');
  };
  const cleanupScope = window.HumanoidCleanup?.createScope?.(`${MODEL.toLowerCase()}-content`) || {
    trackInterval: (id) => id,
    trackTimeout: (id) => id,
    trackObserver: (observer) => observer,
    trackAbortController: (controller) => controller,
    register: () => () => {},
    addEventListener: () => () => {},
    cleanup: () => {},
    isCleaned: () => false,
    getReason: () => null
  };
  let scriptStopped = false;
  const stopContentScript = (reason = 'manual-stop') => {
    if (scriptStopped) return cleanupScope.getReason?.() || reason;
    scriptStopped = true;
    console.warn('[content-lechat] Cleanup triggered:', reason);
    try {
      getForceStopRegistry().run(reason);
    } catch (_) {}
    try {
      cleanupScope.cleanup?.(reason);
    } catch (err) {
      console.warn('[content-lechat] Cleanup scope failed', err);
    }
    try {
      performLeChatCleanup();
    } catch (err) {
      console.warn('[content-lechat] Local cleanup failed', err);
    }
    try {
      window.leChatContentScriptLoaded = null;
    } catch (_) {}
    delete window.__leChatAllCopyV6;
    return reason;
  };
  const getHumanoid = () => (typeof window !== 'undefined' ? window.Humanoid : null);

  async function lechatHumanRead(duration = 480) {
    const humanoid = getHumanoid();
    if (humanoid?.readPage) {
      try {
        await humanoid.readPage(duration);
      } catch (err) {
        console.warn('[content-lechat] Humanoid.readPage failed', err);
      }
    }
  }

  async function lechatHumanClick(element) {
    const humanoid = getHumanoid();
    if (!element) return;
    if (humanoid?.click) {
      try {
        await humanoid.click(element);
        return;
      } catch (err) {
        console.warn('[content-lechat] Humanoid.click failed', err);
      }
    }
    element.click();
  }

  async function fallbackLechatType(input, prompt) {
    try {
      input.focus({ preventScroll: true });
    } catch (_) {
      input.focus?.();
    }
    await sleep(120);
    const isEditable = input.isContentEditable || input.getAttribute?.('contenteditable') === 'true';
    if (isEditable) {
      try {
        const sel = window.getSelection?.();
        if (sel && typeof sel.removeAllRanges === 'function') {
          const range = document.createRange();
          range.selectNodeContents(input);
          range.collapse(false);
          sel.removeAllRanges();
          sel.addRange(range);
        }
      } catch (_) {}
      try {
        document.execCommand?.('selectAll', false, null);
        document.execCommand?.('insertText', false, prompt);
      } catch (_) {}
      if (!input.innerText || input.innerText.trim() !== prompt.trim()) {
        input.textContent = prompt;
      }
    } else if (input.tagName === 'TEXTAREA') {
      input.value = prompt;
    } else {
      input.textContent = prompt;
    }
    try {
      input.dispatchEvent(new InputEvent('beforeinput', { bubbles: true, inputType: 'insertText', data: prompt, composed: true }));
    } catch (_) {}
    input.dispatchEvent(new InputEvent('input', { bubbles: true, data: prompt, composed: true }));
    input.dispatchEvent(new Event('change', { bubbles: true }));
    await sleep(220);
  }

  async function lechatHumanType(input, prompt, options = {}) {
    const humanoid = getHumanoid();
    if (humanoid?.typeText) {
      try {
        await humanoid.typeText(input, prompt, options);
        return;
      } catch (err) {
        console.warn('[content-lechat] Humanoid.typeText failed', err);
      }
    }
    await fallbackLechatType(input, prompt);
  }

  window.setupHumanoidFetchMonitor?.(MODEL, ({ status, retryAfter, url }) => {
    if (status !== 429) return;
    const waitTime = retryAfter ? parseInt(retryAfter, 10) * 1000 || 60000 : 60000;
    console.error('[content-lechat] HTTP 429 detected for', url || 'unknown');
    chrome.runtime.sendMessage({
      type: 'LLM_RESPONSE',
      llmName: MODEL,
      answer: 'Error: Rate limit detected. Please wait.',
      error: { 
        type: 'rate_limit', 
        message: `HTTP 429 detected. Suggested wait time: ${waitTime}ms`,
        waitTime
      }
    });
  });

  // -------------------- Utils --------------------
  const sleep = (ms) => new Promise((r) => setTimeout(r, ms));
  const isUserInteracting = () => {
    if (document.hidden) return true;
    const el = document.activeElement;
    if (!el) return false;
    const tag = el.tagName;
    return tag === 'INPUT' || tag === 'TEXTAREA' || el.isContentEditable;
  };
  const keepAliveMutex = (() => {
    const key = '__keepAliveMutex';
    if (window[key]) return window[key];
    let locked = false;
    const queue = [];
    const run = async (fn) => {
      if (locked) await new Promise((res) => queue.push(res));
      locked = true;
      try { return await fn(); } finally {
        locked = false;
        const next = queue.shift();
        if (next) next();
      }
    };
  const mutex = { run };
  window[key] = mutex;
  return mutex;
})();

  const pipelineExpectedLength = (text = '') => {
    const len = (text || '').length;
    if (len > 4000) return 'veryLong';
    if (len > 2000) return 'long';
    if (len > 800) return 'medium';
    return 'short';
  };

  async function tryLeChatPipeline(promptText = '', lifecycle = {}) {
    const { heartbeat, stop } = lifecycle || {};
    if (!window.UnifiedAnswerPipeline) return null;
    heartbeat?.({
      stage: 'start',
      expectedLength: pipelineExpectedLength(promptText),
      pipeline: 'UnifiedAnswerPipeline'
    });
    try {
      const pipeline = new window.UnifiedAnswerPipeline('lechat', {
        expectedLength: pipelineExpectedLength(promptText)
      });
      const result = await pipeline.execute();
      if (result?.success && result.answer) {
        heartbeat?.({
          stage: 'success',
          answerLength: result.answer.length,
          pipeline: 'UnifiedAnswerPipeline'
        });
        if (typeof stop === 'function') {
          await stop({
            status: 'success',
            source: 'pipeline',
            answer: result.answer,
            answerLength: result.answer.length,
            metadata: result.metadata
          });
        }
        return result;
      }
      heartbeat?.({
        stage: 'empty',
        status: 'no-answer',
        pipeline: 'UnifiedAnswerPipeline'
      });
    } catch (err) {
      heartbeat?.({
        stage: 'error',
        error: err?.message || String(err),
        pipeline: 'UnifiedAnswerPipeline'
      });
      console.warn('[content-lechat] UnifiedAnswerPipeline failed, falling back to legacy watcher', err);
    }
    return null;
  }
  const startDriftFallback = (intensity = 'soft') => {
    const humanoid = getHumanoid();
    if (humanoid?.startAntiSleepDrift) {
      humanoid.startAntiSleepDrift(intensity);
      return;
    }
    const delta = intensity === 'hard' ? 24 : intensity === 'medium' ? 16 : 10;
    window.scrollBy({ top: (Math.random() > 0.5 ? 1 : -1) * delta, behavior: 'auto' });
  };

  const stopDriftFallback = () => {
    const humanoid = getHumanoid();
    humanoid?.stopAntiSleepDrift?.();
  };

  const createKeepAliveHeartbeat = (source) => {
    let traceId = null;
    let cleanupTimer = null;
    return (meta = {}) => {
      const lifecycle = window.HumanoidEvents;
      if (!lifecycle?.start) return;
      if (!traceId) {
        try {
          traceId = lifecycle.start(source, { mode: 'anti-sleep', source });
        } catch (err) {
          console.warn(`[${source}] keepalive trace failed`, err);
          return;
        }
      }
      try {
        lifecycle.heartbeat(traceId, meta.progress || 0, Object.assign({ phase: 'keepalive-pulse' }, meta));
      } catch (err) {
        console.warn(`[${source}] keepalive heartbeat failed`, err);
      }
      if (cleanupTimer) clearTimeout(cleanupTimer);
      cleanupTimer = setTimeout(() => {
        try { lifecycle.stop(traceId, { status: 'idle' }); } catch (_) {}
        traceId = null;
      }, 8000);
    };
  };
  const emitKeepAliveHeartbeat = createKeepAliveHeartbeat(`${MODEL.toLowerCase()}:keepalive`);

  function isElementInteractable(el) {
    if (!el) return false;
    if (el.offsetParent === null) return false;
    if (el.getAttribute && el.getAttribute('disabled') !== null) return false;
    const style = el.style || {};
    if (style.display === 'none' || style.visibility === 'hidden') return false;
    const rect = el.getBoundingClientRect?.();
    if (!rect) return true;
    const vw = window.innerWidth || document.documentElement.clientWidth;
    const vh = window.innerHeight || document.documentElement.clientHeight;
    return rect.bottom >= 0 && rect.right >= 0 && rect.top <= vh && rect.left <= vw;
  }

  const runAntiSleepPulse = (intensity = 'soft') => {
    emitKeepAliveHeartbeat({ action: 'keep-alive-ping', intensity, model: MODEL });
    const delta = intensity === 'hard' ? 28 : intensity === 'medium' ? 16 : 8;
    try {
      const Toolkit = window.__UniversalScrollToolkit;
      if (Toolkit) {
        const tk = new Toolkit({ idleThreshold: 800, driftStepMs: 40 });
        tk.keepAliveTick?.((Math.random() > 0.5 ? 1 : -1) * delta);
        return;
      }
    } catch (_) {}
    startDriftFallback(intensity);
  };

  async function findAndCacheElement(selectorKey, selectorArray, timeout = 30000, scope = document) {
    const opId = metricsCollector.startOperation(`findElement_${selectorKey}`);
    const storageKey = `selector_cache_${MODEL}_${selectorKey}`;
    try {
      const existing = await chrome.storage.local.get(storageKey);
      const cached = existing[storageKey];
      if (cached) {
        const el = scope.querySelector(cached);
        if (isElementInteractable(el)) {
          console.log(`[Self-Healing] Using cached selector for "${selectorKey}": ${cached}`);
          metricsCollector.recordSelectorEvent('cache_hit');
          metricsCollector.endOperation(opId, true, { cached: true, selector: cached });
          return el;
        }
      }
    } catch (_) {}
    const start = Date.now();
    let attempt = 0;
    const baseDelay = 200;
    const maxDelay = 5000;
    while (Date.now() - start < timeout) {
      for (const sel of selectorArray) {
        try {
          const el = scope.querySelector(sel);
          if (isElementInteractable(el)) {
            try { await chrome.storage.local.set({ [storageKey]: sel }); } catch (_) {}
            console.log(`[Self-Healing] Found & cached selector for "${selectorKey}": ${sel} (attempt ${attempt + 1})`);
            metricsCollector.recordSelectorEvent('hit');
            metricsCollector.endOperation(opId, true, { selector: sel, attempts: attempt + 1 });
            return el;
          }
        } catch (e) {
          console.warn(`[Self-Healing] Bad selector "${sel}"`, e);
        }
      }
      const delay = Math.min(baseDelay * Math.pow(2, attempt), maxDelay);
      await sleep(delay);
      attempt++;
    }
    metricsCollector.recordSelectorEvent('miss');
    metricsCollector.endOperation(opId, false, { attempts: attempt });
    throw new Error(`Element not found for "${selectorKey}" after ${attempt} attempts`);
  }

  // -------------------- SmartScroll / KeepAlive (Гибкий) --------------------
  const leChatScrollCoordinator = window.ScrollCoordinator
    ? new window.ScrollCoordinator({
        source: `${MODEL.toLowerCase()}-smart-scroll`,
        getLifecycleMode,
        registerForceStopHandler,
        startDrift: () => startDriftFallback('soft'),
        stopDrift: () => stopDriftFallback(),
        logPrefix: `[${MODEL}] SmartScroll`
      })
    : null;

  async function withSmartScroll(asyncOperation, options = {}) {
    if (leChatScrollCoordinator) {
      return leChatScrollCoordinator.run(asyncOperation, options);
    }
    return asyncOperation();
  }

  // -------------------- ContentCleaner (мягкий, без агрессивной обрезки) --------------------
  class ContentCleaner {
    // ... (ContentCleaner implementation remains unchanged) ...
    constructor() {
      this.rules = this._initRules();
      this.stats = { elementsRemoved: 0, charactersRemoved: 0, rulesApplied: 0 };
    }
    _initRules() {
      return {
        uiPhrases: [
          /\b(Send|Menu|Settings|New chat|Clear|Like|Reply|Copy|Share|Follow|Subscribe|Regenerate)\b/gi,
          /\b(Upload|Download|Save|Delete|Edit|Search|Filter|Sort)\b/gi,
          /\b(Le Chat|Mistral|chat\.mistral\.ai)\b/gi
        ],
        timePatterns: [
          /\b\d{1,2}:\d{2}\s*(AM|PM)?\b/gi,
          /\b\d+\s*(hours?|minutes?|seconds?)\s*ago\b/gi,
          /\b(Just now|Yesterday|Today|Tomorrow)\b/gi
        ],
        formatting: [/\xa0/g, /&nbsp;/g, /&[a-z]+;/gi],
        urls: [/\bhttps?:\/\/[^\s<>"]+\b/gi, /\bwww\.[^\s<>"]+\b/gi],
        stripTags: [/<!--[\s\S]*?-->/g]
      };
    }
    clean(content, options = {}) {
      this.stats = { elementsRemoved: 0, charactersRemoved: 0, rulesApplied: 0 };

      const isHtml = /<\/?[a-z][\s\S]*>/i.test(content);
      let text = content;

      if (isHtml) {
        try {
          const parser = new DOMParser();
          const doc = parser.parseFromString(content, 'text/html');
          doc.querySelectorAll('script,style,svg,canvas,noscript,header,footer,nav,aside,button,[aria-hidden="true"]').forEach(el => {
            this.stats.elementsRemoved++;
            this.stats.charactersRemoved += (el.textContent || '').length;
            el.remove();
          });
          text = doc.body?.textContent || '';
        } catch (err) {
          console.warn('[ContentCleaner] DOMParser failed in LeChat cleaner, falling back to text extraction', err);
          const div = document.createElement('div');
          div.textContent = content;
          text = div.textContent || '';
        }
      }

      const patterns = [
        ...this.rules.uiPhrases,
        ...this.rules.timePatterns,
        ...this.rules.urls,
        ...this.rules.formatting,
        ...this.rules.stripTags
      ];

      let out = text;
      for (const p of patterns) {
        const before = out.length;
        out = out.replace(p, ' ');
        const diff = before - out.length;
        if (diff > 0) {
          this.stats.rulesApplied++;
          this.stats.charactersRemoved += diff;
        }
      }

      out = out.replace(/\n\s*\n\s*\n/g, '\n\n').replace(/[ \t]+/g, ' ').trim();

      const maxLength = options.maxLength || null;
      if (maxLength && out.length > maxLength) {
        const truncated = out.slice(0, maxLength);
        const cutAt = Math.max(truncated.lastIndexOf('. '), truncated.lastIndexOf('\n\n'));
        out = (cutAt > maxLength * 0.7 ? truncated.slice(0, cutAt + 1) : truncated) + '\n\n[Content truncated]';
      }
      return out;
    }
    getStats() { return { ...this.stats }; }
  }
  const contentCleaner = new ContentCleaner();

  // -------------------- Metrics Collection System --------------------
  // ... (MetricsCollector implementation remains unchanged) ...
  class MetricsCollector {
    constructor() {
      this.metrics = {
        operations: [],
        selectors: { hits: 0, misses: 0, cacheHits: 0 },
        timings: {},
        errors: []
      };
      this.startTime = Date.now();
    }
    startOperation(name, context = {}) {
      const id = `${name}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      const op = {
        id,
        name,
        start: Date.now(),
        end: null,
        success: null,
        metadata: context || {},
        lifecycleTraceId: null
      };
      const events = window.HumanoidEvents;
      if (events?.start) {
        try {
          op.lifecycleTraceId = events.start(`metrics:${name}`, {
            mode: getLifecycleMode(),
            operation: name
          });
        } catch (_) {}
      }
      this.metrics.operations.push(op);
      return id;
    }
    endOperation(id, success = true, metadata = {}) {
      const op = this.metrics.operations.find(o => o.id === id);
      if (op) {
        op.end = Date.now();
        op.duration = op.end - op.start;
        op.success = success;
        op.metadata = metadata;
        if (op.lifecycleTraceId && window.HumanoidEvents?.stop) {
          try {
            window.HumanoidEvents.stop(op.lifecycleTraceId, {
              status: success ? 'success' : 'failed',
              metadata
            });
          } catch (_) {}
          op.lifecycleTraceId = null;
        }
      }
    }
    recordSelectorEvent(type) {
      if (type === 'hit') this.metrics.selectors.hits++;
      else if (type === 'miss') this.metrics.selectors.misses++;
      else if (type === 'cache_hit') this.metrics.selectors.cacheHits++;
    }
    recordTiming(key, duration) {
      if (!this.metrics.timings[key]) this.metrics.timings[key] = [];
      this.metrics.timings[key].push(duration);
    }
    recordError(error, context = '', operationId = null) {
      this.metrics.errors.push({
        message: error?.message || String(error),
        context,
        timestamp: Date.now(),
        type: error?.type || 'unknown'
      });
      if (operationId) {
        const op = this.metrics.operations.find(o => o.id === operationId);
        if (op?.lifecycleTraceId && window.HumanoidEvents?.error) {
          try {
            window.HumanoidEvents.error(op.lifecycleTraceId, error, true);
          } catch (_) {}
        }
      }
    }
    getReport() {
      const now = Date.now();
      const successOps = this.metrics.operations.filter(o => o.success === true);
      const failedOps = this.metrics.operations.filter(o => o.success === false);
      const avgTimings = {};
      for (const [key, values] of Object.entries(this.metrics.timings)) {
        avgTimings[key] = values.reduce((a, b) => a + b, 0) / values.length;
      }
      return {
        uptime: now - this.startTime,
        operations: {
          total: this.metrics.operations.length,
          successful: successOps.length,
          failed: failedOps.length,
          successRate: this.metrics.operations.length > 0 
            ? (successOps.length / this.metrics.operations.length * 100).toFixed(2) + '%'
            : 'N/A'
        },
        selectors: this.metrics.selectors,
        timings: avgTimings,
        errors: this.metrics.errors.slice(-10),
        timestamp: now
      };
    }
    sendReport() {
      chrome.runtime.sendMessage({
        type: 'METRICS_REPORT',
        llmName: MODEL,
        metrics: this.getReport()
      });
    }
  }
  const metricsCollector = new MetricsCollector();

  cleanupScope.trackInterval(setInterval(() => metricsCollector.sendReport(), 300000));

  // -------------------- ПЕРЕНОСИМЫЕ ФУНКЦИИ ИЗ РАБОЧЕЙ ВЕРСИИ --------------------
  
  // Композер (ввод текста) - рабочая версия из content-lechat
  function getComposer() {
    const candidates = [
      'textarea[placeholder*="message"]',
      'textarea[aria-label*="message"]',
      'textarea[data-testid*="composer"]',
      'div[data-testid*="composer"] textarea',
      'div[data-testid*="composer"] [contenteditable="true"]',
      'div.ProseMirror',
      'div[class*="ProseMirror"]',
      'div[contenteditable="true"][data-placeholder]',
      'div[role="textbox"][contenteditable="true"]',
      'div[contenteditable="true"]',
      'textarea'
    ];
    for (const sel of candidates) {
      const el = document.querySelector(sel);
      if (isElementInteractable(el)) return el;
    }
    return null;
  }

  async function resolveComposerViaSelectorFinder() {
    if (!window.SelectorFinder?.findOrDetectSelector) return null;
    try {
      const result = await window.SelectorFinder.findOrDetectSelector({
        modelName: MODEL,
        elementType: 'composer',
        timeout: 25000
      });
      if (result?.element) {
        console.log('[content-lechat] Composer via SelectorFinder', result.selector || result.method || result.layer || 'auto');
        return result.element;
      }
    } catch (err) {
      console.warn('[content-lechat] SelectorFinder composer resolution failed', err);
    }
    return null;
  }

  async function resolveComposer() {
    const direct = getComposer();
    if (direct) return direct;

    const managed = await resolveComposerViaSelectorFinder();
    if (managed) return managed;

    try {
      return await findAndCacheElement('lechat_composer', [
        'textarea[placeholder*="message"]',
        'textarea[aria-label*="message"]',
        'textarea[aria-label*="prompt"]',
        'textarea[data-testid*="composer"]',
        'div[data-testid*="composer"] textarea',
        'div[data-testid*="composer"] [contenteditable="true"]',
        'div[role="textbox"][contenteditable="true"]',
        'div[contenteditable="true"]',
        'textarea'
      ]);
    } catch (err) {
      console.warn('[content-lechat] Fallback composer search failed', err);
      return null;
    }
  }

  // Ввод промпта - рабочая версия из content-lechat (прямое присваивание)
  async function typePrompt(input, prompt) {
    await lechatHumanRead(420);
    await lechatHumanType(input, prompt, { wpm: 120 });
    await sleep(320);
  }

  async function resolveSendButton(referenceInput) {
    if (window.SelectorFinder?.findOrDetectSelector) {
      try {
        const result = await window.SelectorFinder.findOrDetectSelector({
          modelName: MODEL,
          elementType: 'sendButton',
          timeout: 20000,
          referenceElement: referenceInput || null
        });
        if (result?.element && isElementInteractable(result.element)) {
          return result.element;
        }
      } catch (err) {
        console.warn('[content-lechat] SelectorFinder send button resolution failed', err);
      }
    }

    const sendBtn = document.querySelector(
      [
        'button[aria-label*="Send"]',
        'button[aria-label*="send message"]',
        'button:has(svg[data-icon="arrow-up"])',
        'button:has(svg[data-icon="send"])',
        'button[type="submit"]',
        'button[aria-label="Post"]',
        'button[aria-label*="Отправить"]',
        'button[data-testid*="send"]',
        'button:has(svg)',
        'button:has([data-icon="send"])'
      ].join(',')
    );
    return isElementInteractable(sendBtn) ? sendBtn : null;
  }

  // Отправка промпта - рабочая версия из content-lechat
  async function sendComposer(input) {
    const enterDown = new KeyboardEvent('keydown', { key: 'Enter', code: 'Enter', keyCode: 13, which: 13, bubbles: true });
    const enterUp = new KeyboardEvent('keyup', { key: 'Enter', code: 'Enter', keyCode: 13, which: 13, bubbles: true });
    input.dispatchEvent(enterDown);
    input.dispatchEvent(enterUp);
    await sleep(120);

    const sendBtn = await resolveSendButton(input);
    if (sendBtn && !sendBtn.disabled) {
      await lechatHumanClick(sendBtn);
    }
  }

  // Извлечение ответа - адаптация под LeChat с логикой Grok
  function getProseNodes() {
    return Array.from(document.querySelectorAll(
      'div.prose:not(:has(div[contenteditable])), .prose, div[data-testid="lechat-response"] .prose, article .prose, [data-testid="answer"] .prose, .result, .answer'
    )).filter((n) => ((n.innerText || '').trim().length > 0));
  }

  function extractResponseText(node) {
    if (!node) return '';
    const isHtml = node.innerHTML && node.innerHTML.trim();
    if (isHtml) {
      return node.innerHTML.trim();
    }
    return (node.innerText || node.textContent || '').trim();
  }

  // Ожидание ответа - логика Grok с селекторами LeChat
  async function waitForLeChatReply(prompt, timeout = 150000) {
    const captureProseSnapshot = () => {
      const prose = getProseNodes();
      if (!prose.length) return null;
      const last = prose[prose.length - 1];
      const txt = extractResponseText(last);
      if (!txt || txt.length < 5) return null;
      const isGenerating = document.querySelector(
        'button > div > svg[data-icon="stop"], .animate-pulse, .typing-indicator, [data-testid="generation-in-progress"], [aria-busy="true"], .loading, .loader, .dots'
      );
      return { text: txt, isGenerating };
    };

    const captureFallbackSnapshot = () => {
      const messages = Array.from(document.querySelectorAll('div[class*="message"], article, div[role="article"]'));
      if (!messages.length) return null;
      const lastMsg = messages[messages.length - 1];
      const txt = extractResponseText(lastMsg);
      if (!txt || txt.length < 5) return null;
      const prefix = prompt.slice(0, Math.min(40, prompt.length)).trim();
      if (prefix && txt.startsWith(prefix)) return null;
      const isGenerating = Boolean(document.querySelector('[aria-busy="true"], .typing-indicator, .animate-pulse'));
      return { text: txt, isGenerating };
    };

    return new Promise((resolve, reject) => {
      const startTime = Date.now();
      let lastSeen = '';
      let stableTicks = 0;
      let fallbackMode = false;
      let settled = false;

      const cleanup = (value, isTimeout = false) => {
        if (settled) return;
        settled = true;
        if (domObserver) {
          domObserver.disconnect();
          domObserver = null;
        }
        clearInterval(intervalId);
        clearTimeout(timerId);
        if (value) {
          resolve(value);
        } else if (isTimeout && lastSeen) {
          console.warn('[content-lechat] Timeout reached, returning last captured text.');
          resolve(lastSeen);
        } else {
          reject(new Error('Тайм-аут Le Chat'));
        }
      };

      const evaluate = () => {
        let snapshot = captureProseSnapshot();
        if (!snapshot && fallbackMode) {
          snapshot = captureFallbackSnapshot();
        }
        if (!snapshot) return;
        const { text, isGenerating } = snapshot;
        if (!isGenerating && text === lastSeen) {
          stableTicks += 1;
          if (stableTicks >= 2) {
            console.log('[content-lechat] Response stabilized.');
            cleanup(text);
          }
        } else {
          lastSeen = text;
          stableTicks = 0;
        }
      };

      domObserver = cleanupScope.trackObserver(new MutationObserver(() => evaluate()));
      domObserver.observe(document.body, { childList: true, subtree: true, characterData: true });
      const intervalId = cleanupScope.trackInterval(setInterval(() => {
        if (!fallbackMode && getProseNodes().length === 0 && Date.now() - startTime > 10000) {
          fallbackMode = true;
        }
        evaluate();
      }, 600));
      const timerId = cleanupScope.trackTimeout(setTimeout(() => cleanup(null, true), timeout));
      evaluate();
    });
  }

  // -------------------- Отправка результата в бекграунд --------------------
  // NOTE: sendResult is removed/deprecated to avoid duplicate messages (Issue 2).
  // All messaging is now handled by the chrome.runtime.onMessage listener.

  // -------------------- Публичная операция: inject → wait → extract → clean → send --------------------
  async function injectAndGetResponse(prompt) {
    return runLifecycle('lechat:inject', buildLifecycleContext(prompt), async (activity) => {
      const opId = metricsCollector.startOperation('injectAndGetResponse');
      const startTime = Date.now();
      let pipelineCompleted = false;
      let pipelineStats = null;
      try {
        const cleaned = await withSmartScroll(async () => {
          await sleep(3000);
          activity.heartbeat(0.15, { phase: 'composer-search' });

          const composer = await resolveComposer();
          if (!composer) {
            throw { type: 'selector_not_found', message: 'Le Chat input field not found' };
          }
          activity.heartbeat(0.3, { phase: 'composer-ready' });

          await typePrompt(composer, prompt);
          
          await sleep(100);
          const validationText = (composer.value ?? composer.textContent ?? '').trim();
          if (!validationText.length) {
            throw { type: 'injection_failed', message: 'Input did not accept value (React guard).' };
          }
          activity.heartbeat(0.45, { phase: 'typing' });
          
          await sendComposer(composer);
          activity.heartbeat(0.6, { phase: 'send-dispatched' });

          activity.heartbeat(0.7, { phase: 'waiting-response' });
          let pipelineAnswer = null;
          await tryLeChatPipeline(prompt, {
            heartbeat: (meta = {}) => activity.heartbeat(0.8, Object.assign({ phase: 'pipeline' }, meta)),
            stop: async ({ answer }) => {
              console.log('[content-lechat] UnifiedAnswerPipeline captured response');
              pipelineAnswer = contentCleaner.clean(answer, { maxLength: 50000 });
              pipelineCompleted = true;
              pipelineStats = { responseLength: pipelineAnswer.length, source: 'pipeline' };
              return pipelineAnswer;
            }
          });
          if (pipelineAnswer) {
            return pipelineAnswer;
          }
          const rawText = await waitForLeChatReply(prompt, 150000);

          return contentCleaner.clean(rawText, { maxLength: 50000 });
        }, { keepAliveInterval: 2000, operationTimeout: 300000, debug: false });
        
        const stats = contentCleaner.getStats();
        chrome.runtime.sendMessage({
          type: 'CONTENT_CLEANING_STATS',
          llmName: MODEL,
          stats,
          timestamp: Date.now()
        });
        
        const duration = Date.now() - startTime;
        const stopMeta = pipelineCompleted
          ? Object.assign({ duration }, pipelineStats || { responseLength: cleaned.length, source: 'pipeline' })
          : { responseLength: cleaned.length, duration };
        metricsCollector.recordTiming('total_response_time', duration);
        metricsCollector.endOperation(opId, true, stopMeta);
        activity.heartbeat(0.95, { phase: 'response-processed' });
        activity.stop({ status: 'success', answerLength: cleaned.length, source: pipelineCompleted ? 'pipeline' : 'legacy' });
        return cleaned;
        
      } catch (e) {
        if (e?.code === 'background-force-stop') {
          activity.error(e, false);
          throw e;
        }
        console.error('[content-lechat] injectAndGetResponse error:', e);
        metricsCollector.recordError(e, 'injectAndGetResponse', opId);
        metricsCollector.endOperation(opId, false, { error: e?.message });
        activity.error(e, true);
        throw e;
      }
    });
  }
  //-- 3.1. Централизованная функция очистки --//
  let keepAliveActive = true; 
  let healthCheckTimer = null;
  let keepAliveTimer = null;
  let domObserver = null;
  const addedListeners = [];
  const ROOT_ID = 'lechat-allcopy-v6-root';

  function addTrackedListener(target, event, handler) {
    target.addEventListener(event, handler);
    addedListeners.push({ target, event, handler });
  }

  function performLeChatCleanup() {
    console.log('[content-lechat] Cleanup initiated...');
    
    // Останавливаем все флаги активности
    keepAliveActive = false;
    
    // Удаляем DOM-элементы
    const rootElement = document.getElementById(ROOT_ID);
    if (rootElement) {
      rootElement.remove();
      console.log('[content-lechat] DOM elements removed');
    }
    
    // Останавливаем таймеры
    if (healthCheckTimer) {
      clearInterval(healthCheckTimer);
      healthCheckTimer = null;
      console.log('[content-lechat] Health check timer cleared');
    }
    
    if (keepAliveTimer) {
      clearInterval(keepAliveTimer);
      keepAliveTimer = null;
      console.log('[content-lechat] Keep-alive timer cleared');
    }
    
    // Отключаем MutationObserver
    if (domObserver) {
      domObserver.disconnect();
      domObserver = null;
      console.log('[content-lechat] DOM observer disconnected');
    }
    
    // Удаляем все event listeners
    addedListeners.forEach(({target, event, handler}) => {
      try {
        target.removeEventListener(event, handler);
      } catch (e) {
        console.warn('[content-lechat] Failed to remove listener:', e);
      }
    });
    addedListeners.length = 0;
    console.log('[content-lechat] Event listeners removed');
    
    // Сбрасываем глобальные флаги
    window.leChatContentScriptLoaded = null;
    delete window.__leChatAllCopyV6;
    delete window.__SCRIPT_VERSION;
    delete window.__cleanup_lechat;
    
    console.log('[content-lechat] ✅ Cleanup complete');
  }
  
  // Экспортируем cleanup для внешнего вызова
  window.__cleanup_lechat = () => stopContentScript('manual-trigger');
  
  // Проверка отключения расширения каждые 3 секунды
  healthCheckTimer = cleanupScope.trackInterval(setInterval(() => {
    if (!chrome.runtime?.id) {
      console.warn('[content-lechat] Extension disconnected, self-cleaning');
      stopContentScript('runtime-disconnected');
    }
  }, 3000));
  // -------------------- Message bus --------------------
  const onRuntimeMessage = (msg, _sender, sendResponse) => {
    try {
      if (!msg) return false;
      
      if (msg?.type === 'STOP_AND_CLEANUP') {
        handleForceStopMessage(msg.payload?.traceId);
        stopContentScript('manual-toggle');
        if (typeof sendResponse === 'function') {
          sendResponse({ status: 'cleaned', llmName: MODEL });
        }
        return false;
      }

      if (msg?.type === 'HUMANOID_FORCE_STOP') {
        handleForceStopMessage(msg.payload?.traceId);
        if (typeof sendResponse === 'function') {
          sendResponse({ status: 'force_stop_ack' });
        }
        return false;
      }

      if (msg?.type === 'HEALTH_CHECK_PING') {
        sendResponse({ type: 'HEALTH_CHECK_PONG', pingId: msg.pingId, llmName: MODEL });
        return true;
      }
      if (msg?.type === 'HEALTH_PING') {
        sendResponse({ 
          status: 'alive', 
          llmName: MODEL,
          version: window.__SCRIPT_VERSION || 'unknown',
          timestamp: Date.now()
        });
        return true;
      }

      if (msg?.type === 'FORCE_CLEANUP') {
        console.log('[content-lechat] Received FORCE_CLEANUP command');
        stopContentScript('force-cleanup');
        sendResponse?.({ status: 'cleaned', llmName: MODEL });
        return true;
      }

      if (msg?.type === 'ANTI_SLEEP_PING') {
        try {
          if (isUserInteracting()) {
            stopDriftFallback();
            return false;
          }
          keepAliveMutex.run(async () => {
            runAntiSleepPulse(msg.intensity || 'soft');
          });
          chrome.runtime.sendMessage({ type: 'LLM_ACTIVITY_PONG' }).catch(() => {});
        } catch (_) {}
        return false;
      }

      if (msg?.type === 'GET_ANSWER' || msg?.type === 'GET_FINAL_ANSWER') {
        injectAndGetResponse(msg.prompt)
          .then((resp) => {
            if (msg.isFireAndForget) {
              console.log('[content-lechat] Fire-and-forget request processed. Not sending response back.');
              sendResponse?.({ status: 'success_fire_and_forget' });
              return;
            }
            const responseType = msg.type === 'GET_ANSWER' ? 'LLM_RESPONSE' : 'FINAL_LLM_RESPONSE';
            chrome.runtime.sendMessage({ type: responseType, llmName: MODEL, answer: resp });
            sendResponse?.({ status: 'success' });
          })
          .catch((err) => {
            if (err?.code === 'background-force-stop') {
              sendResponse?.({ status: 'force_stopped' });
              return;
            }
            const errorMessage = err?.message || String(err) || 'Unknown error in content-lechat';
            const responseType = msg.type === 'GET_ANSWER' ? 'LLM_RESPONSE' : 'FINAL_LLM_RESPONSE';
            if (err?.type !== 'rate_limit') {
               chrome.runtime.sendMessage({
                  type: responseType,
                  llmName: MODEL,
                  answer: `Error: ${errorMessage}`,
                  error: { type: err?.type || 'generic_error', message: errorMessage }
               });
            }
            sendResponse?.({ status: 'error', message: errorMessage });
          });
        return true;
      }

      if (msg.action === 'injectPrompt' || msg.action === 'sendPrompt' || msg.action === 'REQUEST_LLM_RESPONSE') {
        const prompt = msg.prompt || '';
        injectAndGetResponse(prompt);
      } else if (msg.action === 'getResponses') {
        const runManualRefresh = async () => {
          await withSmartScroll(async () => {
            const rawText = await waitForLeChatReply('', 120000);
            const cleaned = contentCleaner.clean(rawText);
            chrome.runtime.sendMessage({
              type: 'LLM_RESPONSE',
              llmName: MODEL,
              answer: cleaned
            });
          }, { keepAliveInterval: 2000, operationTimeout: 120000, debug: false });
        };
        runManualRefresh()
          .then(() => sendResponse && sendResponse({ status: 'manual_refresh_dispatched' }))
          .catch((err) => {
            if (err?.code === 'background-force-stop') {
              sendResponse && sendResponse({ status: 'force_stopped' });
              return;
            }
            console.error('[content-lechat] Manual getResponses failed', err);
            sendResponse && sendResponse({ status: 'manual_refresh_failed', error: err?.message || 'unknown_error' });
          });
        return true;
      }
    } catch (e) {
      console.error('[content-lechat] onMessage error:', e);
      chrome.runtime.sendMessage({
          type: 'LLM_RESPONSE',
          llmName: MODEL,
          answer: `Structural Error: ${e?.message || String(e)}`,
          error: { type: 'structural_listener_error', message: e?.message || String(e) }
      });
    }
    return false;
  };
  chrome.runtime.onMessage.addListener(onRuntimeMessage);
  cleanupScope.register?.(() => {
    try {
      chrome.runtime.onMessage.removeListener(onRuntimeMessage);
    } catch (_) {}
  });

  // -------------------- Экспорт внутрь страницы (по необходимости) --------------------
  window.__leChatAllCopyV6 = {
    injectAndGetResponse,
    contentCleaner
  };

  console.log('[content-lechat] AllCopy v6 ready.');
})();
// ============================== IIFE END ==============================
