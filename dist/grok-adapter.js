// Auto-generated by scripts/build-bundles.js @ 2025-12-02T17:36:09.129Z
// selectors/grok.config.js
(function () {
  const globalObject = typeof window !== 'undefined' ? window : self;
  globalObject.SelectorConfigRegistry = globalObject.SelectorConfigRegistry || {};

  globalObject.SelectorConfigRegistry.Grok = {
    versions: [
      {
        version: 'grok-2025-q1',
        uiRevision: '2025.1',
        expiresAt: '2025-05-31T00:00:00Z',
        qaNotes: 'Captured on production 2025-02-23 after Grok composer refresh.',
        dateCreated: '2025-02-24T00:00:00Z',
        description: 'Composer migrated into data-testid="grok-editor" shell with detached footer actions.',
        markers: [
          { selector: 'div[data-testid="grok-editor"]' }
        ],
        selectors: {
          composer: [
            'div[data-testid="grok-editor"] div[role="textbox"]',
            'div[data-testid="grok-editor"] [contenteditable="true"]',
            'div[data-testid="grok-editor"] textarea',
            'section[data-testid*="composer"] div[role="textbox"]',
            'section[data-testid*="composer"] [contenteditable="true"]',
            'section[data-testid*="composer"] textarea',
            'textarea[placeholder*="Ask Grok" i]',
            'div[role="textbox"][aria-label*="Ask Grok" i]'
          ],
          sendButton: [
            'div[data-testid="grok-editor"] button[data-testid="grok-send-button"]',
            'div[data-testid="grok-editor"] button[aria-label*="send" i]',
            'section[data-testid*="composer"] button[data-testid="grok-send-button"]',
            'section[data-testid*="composer"] button[aria-label*="send" i]',
            'form button[data-testid*="composer"]',
            'button[data-testid="grok-send-button"]',
            'button[aria-label*="Ask Grok" i]',
            'button[aria-label*="send" i]',
            'button[type="submit"]'
          ],
          response: {
            primary: [
              'div[data-testid="grok-response"] .prose',
              'main [data-testid*="response"] .prose',
              'main [data-testid*="thread"] .prose',
              'section[data-testid*="response"] .prose'
            ],
            fallback: [
              'div[data-testid="grok-response"] article',
              'main [data-testid*="response"] article',
              'section[data-testid*="response"]',
              '.prose',
              'article[data-testid="tweet"]',
              'main [class*="response"]'
            ],
            extraction: {
              method: 'innerText',
              cleanup: 'full'
            }
          }
        },
        constraints: {
          composer: {
            exclude: [
              'input[type="search"]',
              '[role="search"] [role="textbox"]',
              '[aria-label*="search" i]'
            ]
          },
          sendButton: {
            exclude: [
              'button[aria-label*="search" i]',
              '[role="search"] button'
            ]
          }
        },
        observation: {
          rootSelector: 'main[role="main"]',
          targetSelectors: [
            'div[data-testid="grok-response"]',
            'section[data-testid*="response"]',
            '.prose',
            'article[data-testid="tweet"]'
          ],
          stabilizationDelayMs: 1600,
          endGenerationMarkers: [
            {
              selector: '.animate-pulse, .typing-indicator, [data-testid="generation-in-progress"], [aria-busy="true"], .loading, .loader, .dots',
              type: 'disappear'
            }
          ]
        },
        anchors: {
          composer: [
            'Ask Grok',
            'Message Grok'
          ],
          sendButton: [
            'Send',
            'Ask',
            'Post'
          ],
          response: [
            'Grok',
            'Answer'
          ]
        }
      },
      {
        version: 'grok-2024-q4',
        uiRevision: '2024.4',
        expiresAt: '2025-02-15T00:00:00Z',
        qaNotes: 'Verified on staging 2024-12-05, production hotfix ready.',
        dateCreated: '2024-11-01T00:00:00Z',
        description: 'Primary composer moved into data-testid="grok-text-input"; dedicated send button data-testid was introduced.',
        markers: [
          { selector: 'div[data-testid="grok-text-input"]' },
          { selector: 'button[data-testid="grok-send-button"]' }
        ],
        selectors: {
          composer: [
            'div[data-testid="grok-text-input"] div[role="textbox"]',
            'div[data-testid="grok-text-input"] [contenteditable="true"]',
            'div[data-testid="grok-text-input"] textarea',
            'div[role="textbox"][data-testid*="grok"]',
            'div[role="textbox"][contenteditable="true"]'
          ],
          sendButton: [
            'button[data-testid="grok-send-button"]',
            'div[data-testid="grok-text-input"] button[aria-label*="Send"]',
            'div[data-testid="grok-text-input"] button[type="submit"]',
            'button[aria-label="Post"]',
            'button[aria-label*="Send"]'
          ],
          response: {
            primary: [
              'div[data-testid="grok-response"] .prose',
              'div.group.relative .prose',
              '[data-testid="answer"] .prose',
              'main [class*="response"] .prose'
            ],
            fallback: [
              'div[data-testid="grok-response"] article',
              '.prose',
              'main [class*="response"]',
              'main [class*="prose"]',
              'article[data-testid="tweet"]'
            ],
            extraction: {
              method: 'innerText',
              cleanup: 'full'
            }
          }
        },
        constraints: {
          composer: {
            exclude: [
              'input[type="search"]',
              '[role="search"] [role="textbox"]',
              '[aria-label*="search" i]'
            ]
          },
          sendButton: {
            exclude: [
              'button[aria-label*="search" i]',
              '[role="search"] button'
            ]
          }
        },
        observation: {
          rootSelector: 'main[role="main"]',
          targetSelectors: [
            'div[data-testid="grok-response"]',
            '.prose',
            'article[data-testid="tweet"]'
          ],
          stabilizationDelayMs: 1800,
          endGenerationMarkers: [
            {
              selector: '.animate-pulse, .typing-indicator, [data-testid="generation-in-progress"], [aria-busy="true"], .loading, .loader, .dots',
              type: 'disappear'
            }
          ]
        },
        anchors: {
          composer: [
            'Ask Grok',
            'Message Grok'
          ],
          sendButton: [
            'Send',
            'Ask',
            'Post'
          ],
          response: [
            'Grok',
            'Answer'
          ]
        }
      },
      {
        version: 'grok-2024-q3',
        uiRevision: '2024.3',
        expiresAt: '2024-11-30T00:00:00Z',
        qaNotes: 'Legacy fallback kept for returning users; verify monthly.',
        dateCreated: '2024-08-15T00:00:00Z',
        description: 'Legacy layout using Tweet composer markup with inline send button.',
        markers: [
          { selector: 'div[data-testid="tweetTextarea_0"]' },
          { selector: 'div[data-testid="tweetButtonInline"]' }
        ],
        selectors: {
          composer: [
            'div[data-testid="tweetTextarea_0"] div[role="textbox"]',
            'div[data-testid="tweetTextarea_0"] textarea',
            'div[role="textbox"][contenteditable="true"]',
            'textarea[data-testid="tweetTextarea_0"]',
            'textarea[placeholder*="Ask"]'
          ],
          sendButton: [
            'div[data-testid="tweetButtonInline"]',
            'div[data-testid="tweetButtonInline"] button',
            'button[data-testid="tweetButton"]',
            'button[aria-label*="Send"]',
            'button:has(svg)'
          ],
          response: {
            primary: [
              '.prose',
              '[data-testid="answer"] .prose',
              'main [class*="response"] .prose'
            ],
            fallback: [
              '[data-testid="answer"]',
              'article[data-testid="tweet"]',
              'main[role="main"] article',
              'main [class*="response"]'
            ],
            extraction: {
              method: 'innerText',
              cleanup: 'full'
            }
          }
        },
        constraints: {
          composer: {
            exclude: [
              'input[type="search"]',
              '[role="search"] [role="textbox"]',
              '[aria-label*="search" i]'
            ]
          },
          sendButton: {
            exclude: [
              'button[aria-label*="search" i]',
              '[role="search"] button'
            ]
          }
        },
        observation: {
          rootSelector: 'main[role="main"]',
          targetSelectors: [
            '.prose',
            'article[data-testid="tweet"]',
            '[data-testid="answer"]'
          ],
          stabilizationDelayMs: 2000,
          endGenerationMarkers: [
            {
              selector: '.animate-pulse, .typing-indicator, [aria-busy="true"], .loading, .loader, .dots',
              type: 'disappear'
            }
          ]
        },
        anchors: {
          composer: [
            'Ask Grok',
            'Ask me anything'
          ],
          sendButton: [
            'Send',
            'Tweet',
            'Ask'
          ],
          response: [
            'Grok',
            'Answer'
          ]
        }
      }
    ],
    emergencyFallbacks: {
      composer: [
        'div[role="textbox"]',
        'div[contenteditable="true"]',
        'textarea'
      ],
      sendButton: [
        'button[aria-label*="Send"]',
        'button[type="submit"]',
        'button:has(svg)'
      ],
      response: [
        '[role="log"]',
        '[class*="response"]',
        'article',
        'main'
      ]
    }
  };
})();

;
// content-grok.js – AllCopy v6 "Adaptive Resilient Hybrid"
// Структурная основа: как в content-claude (дубликат-guard, IIFE, self-healing, cleaner, 429).
// Плюс: Perplexity-style селекторная сеть, Gemini-style самообучающий fallback,
// Grok-style SmartScroll/KeepAlive и стабильная доставка результата.

// ============================== IIFE START ==============================
(function () {
  // -------------------- Duplicate guard --------------------
  const resolveExtensionVersion = () => {
    try {
      return chrome?.runtime?.getManifest?.()?.version || 'unknown';
    } catch (_) {
      return 'unknown';
    }
  };
  if (window.grokContentScriptLoaded) {
    console.warn('[content-grok] Script already loaded, skipping duplicate initialization');
    throw new Error('Duplicate script load prevented');
  }
  window.grokContentScriptLoaded = {
    timestamp: Date.now(),
    version: resolveExtensionVersion(),
    source: 'content-grok'
  };
  console.log('[content-grok] First load, initializing AllCopy v6…');

  const MODEL = 'Grok';
  const getLifecycleMode = () => {
    if (typeof window !== 'undefined') {
      if (window.__humanoidActivityMode) return window.__humanoidActivityMode;
      if (document?.visibilityState === 'hidden') return 'background';
    }
    return 'interactive';
  };
  const buildLifecycleContext = (prompt = '', extra = {}) => ({
    promptLength: prompt?.length || 0,
    evaluator: Boolean(extra.evaluator),
    mode: extra.mode || getLifecycleMode()
  });
  const getForceStopRegistry = () => {
    if (window.__humanoidForceStopRegistry) {
      return window.__humanoidForceStopRegistry;
    }
    const handlers = new Set();
    window.__humanoidForceStopRegistry = {
      register(handler) {
        if (typeof handler !== 'function') return () => {};
        handlers.add(handler);
        return () => handlers.delete(handler);
      },
      run(reason) {
        handlers.forEach((handler) => {
          try { handler(reason); } catch (_) {}
        });
      }
    };
    return window.__humanoidForceStopRegistry;
  };
  const registerForceStopHandler = (handler) => getForceStopRegistry().register(handler);
  const handleForceStopMessage = (traceId) => {
    if (traceId && window.HumanoidEvents?.stop) {
      try {
        window.HumanoidEvents.stop(traceId, { status: 'forced', reason: 'background-force-stop' });
      } catch (_) {}
    }
    getForceStopRegistry().run('background-force-stop');
  };
  const cleanupScope = window.HumanoidCleanup?.createScope?.(`${MODEL.toLowerCase()}-content`) || {
    trackInterval: (id) => id,
    trackTimeout: (id) => id,
    trackObserver: (observer) => observer,
    trackAbortController: (controller) => controller,
    register: () => () => {},
    addEventListener: () => () => {},
    cleanup: () => {},
    isCleaned: () => false,
    getReason: () => null
  };
  let scriptStopped = false;
  const stopContentScript = (reason = 'manual-stop') => {
    if (scriptStopped) return cleanupScope.getReason?.() || reason;
    scriptStopped = true;
    console.warn('[content-grok] Cleanup triggered:', reason);
    try {
      getForceStopRegistry().run(reason);
    } catch (_) {}
    try {
      cleanupScope.cleanup?.(reason);
    } catch (err) {
      console.warn('[content-grok] Cleanup scope failed', err);
    }
    try {
      window.grokContentScriptLoaded = null;
    } catch (_) {}
    return reason;
  };
  window.__cleanup_grok = stopContentScript;
  cleanupScope.addEventListener?.(window, 'pagehide', () => stopContentScript('pagehide'));
  cleanupScope.addEventListener?.(window, 'beforeunload', () => stopContentScript('beforeunload'));
  const getHumanoid = () => (typeof window !== 'undefined' ? window.Humanoid : null);
  const selectorFinder = window.SelectorFinder;
  if (!selectorFinder) {
    console.error('[content-grok] SelectorFinder is required but not available. Verify injection order.');
    throw new Error('SelectorFinder unavailable for Grok content script');
  }

  window.setupHumanoidFetchMonitor?.(MODEL, ({ status, retryAfter, url }) => {
    if (status !== 429) return;
    const waitTime = retryAfter ? parseInt(retryAfter, 10) * 1000 || 60000 : 60000;
    console.error('[content-grok] HTTP 429 detected for', url || 'unknown');
    chrome.runtime.sendMessage({
      type: 'LLM_RESPONSE',
      llmName: MODEL,
      answer: 'Error: Rate limit detected. Please wait.',
      error: { 
        type: 'rate_limit', 
        message: `HTTP 429 detected. Suggested wait time: ${waitTime}ms`,
        waitTime
      }
    });
  });

  // -------------------- Utils --------------------
  const sleep = (ms) => new Promise((r) => setTimeout(r, ms));
  const isUserInteracting = () => {
    if (document.hidden) return true;
    const el = document.activeElement;
    if (!el) return false;
    const tag = el.tagName;
    return tag === 'INPUT' || tag === 'TEXTAREA' || el.isContentEditable;
  };
  const keepAliveMutex = (() => {
    const key = '__keepAliveMutex';
    if (window[key]) return window[key];
    let locked = false;
    const queue = [];
    const run = async (fn) => {
      if (locked) {
        await new Promise((resolve) => queue.push(resolve));
      }
      locked = true;
      try {
        return await fn();
      } finally {
        locked = false;
        const next = queue.shift();
        if (next) next();
      }
    };
  const mutex = { run };
    window[key] = mutex;
    return mutex;
  })();

  const runLifecycle = (source, context, executor) => {
    if (typeof window.withHumanoidActivity === 'function') {
      return window.withHumanoidActivity(source, context, executor);
    }
    return executor({
      traceId: null,
      heartbeat: () => {},
      stop: () => {},
      error: () => {}
    });
  };

  const pipelineExpectedLength = (text = '') => {
    const len = (text || '').length;
    if (len > 4000) return 'veryLong';
    if (len > 2000) return 'long';
    if (len > 800) return 'medium';
    return 'short';
  };

  async function tryGrokPipeline(promptText = '', lifecycle = {}) {
    const { heartbeat, stop } = lifecycle || {};
    if (!window.UnifiedAnswerPipeline) return null;
    heartbeat?.({
      stage: 'start',
      expectedLength: pipelineExpectedLength(promptText),
      pipeline: 'UnifiedAnswerPipeline'
    });
    try {
      const pipeline = new window.UnifiedAnswerPipeline('grok', {
        expectedLength: pipelineExpectedLength(promptText)
      });
      const result = await pipeline.execute();
      if (result?.success && result.answer) {
        heartbeat?.({
          stage: 'success',
          answerLength: result.answer.length,
          pipeline: 'UnifiedAnswerPipeline'
        });
        if (typeof stop === 'function') {
          await stop({
            status: 'success',
            source: 'pipeline',
            answer: result.answer,
            answerLength: result.answer.length,
            metadata: result.metadata
          });
        }
        return result;
      }
      heartbeat?.({
        stage: 'empty',
        status: 'no-answer',
        pipeline: 'UnifiedAnswerPipeline'
      });
    } catch (err) {
      heartbeat?.({
        stage: 'error',
        error: err?.message || String(err),
        pipeline: 'UnifiedAnswerPipeline'
      });
      console.warn('[content-grok] UnifiedAnswerPipeline failed, using legacy watcher', err);
    }
    return null;
  }

  const startDriftFallback = (intensity = 'soft') => {
    const humanoid = getHumanoid();
    if (humanoid?.startAntiSleepDrift) {
      humanoid.startAntiSleepDrift(intensity);
      return;
    }
    const delta = intensity === 'hard' ? 24 : intensity === 'medium' ? 16 : 10;
    window.scrollBy({ top: (Math.random() > 0.5 ? 1 : -1) * delta, behavior: 'auto' });
  };

  const stopDriftFallback = () => {
    const humanoid = getHumanoid();
    humanoid?.stopAntiSleepDrift?.();
  };

  const createKeepAliveHeartbeat = (source) => {
    let traceId = null;
    let cleanupTimer = null;
    cleanupScope.register?.(() => {
      if (cleanupTimer) {
        clearTimeout(cleanupTimer);
        cleanupTimer = null;
      }
    });
    return (meta = {}) => {
      const lifecycle = window.HumanoidEvents;
      if (!lifecycle?.start) return;
      if (!traceId) {
        try {
          traceId = lifecycle.start(source, { mode: 'anti-sleep', source });
        } catch (err) {
          console.warn(`[${source}] keepalive trace failed`, err);
          return;
        }
      }
      try {
        lifecycle.heartbeat(traceId, meta.progress || 0, Object.assign({ phase: 'keepalive-pulse' }, meta));
      } catch (err) {
        console.warn(`[${source}] keepalive heartbeat failed`, err);
      }
      if (cleanupTimer) clearTimeout(cleanupTimer);
      cleanupTimer = setTimeout(() => {
        try { lifecycle.stop(traceId, { status: 'idle' }); } catch (_) {}
        traceId = null;
      }, 8000);
    };
  };
  const emitKeepAliveHeartbeat = createKeepAliveHeartbeat(`${MODEL.toLowerCase()}:keepalive`);

  function isElementInteractable(el) {
    if (!el) return false;
    if (el.offsetParent === null) return false;
    if (el.getAttribute && el.getAttribute('disabled') !== null) return false;
    const style = el.style || {};
    if (style.display === 'none' || style.visibility === 'hidden') return false;
    const rect = el.getBoundingClientRect?.();
    if (!rect) return true;
    const vw = window.innerWidth || document.documentElement.clientWidth;
    const vh = window.innerHeight || document.documentElement.clientHeight;
    return rect.bottom >= 0 && rect.right >= 0 && rect.top <= vh && rect.left <= vw;
  }

  const runAntiSleepPulse = (intensity = 'soft') => {
    emitKeepAliveHeartbeat({ action: 'keep-alive-ping', intensity, model: MODEL });
    const delta = intensity === 'hard' ? 28 : intensity === 'medium' ? 16 : 8;
    keepAliveMutex.run(async () => {
      try {
        const Toolkit = window.__UniversalScrollToolkit;
        if (Toolkit) {
          const tk = new Toolkit({ idleThreshold: 800, driftStepMs: 40 });
          const ok = await tk.keepAliveTick?.((Math.random() > 0.5 ? 1 : -1) * delta);
          if (ok !== undefined) return;
        }
      } catch (_) {}
      startDriftFallback(intensity);
    });
  };
  //-- 1.2. Перемещаем fallback-функцию внутрь IIFE --//
  // -------------------- Fallback DOM queries for send button --------------------
  async function fallbackFindSendButton(composerEl, timeoutMs = 8000) {
    const fallbackSelectors = [
      'button[data-testid="grok-send-button"]',
      'div[data-testid="grok-editor"] button[data-testid="grok-send-button"]',
      'div[data-testid="grok-editor"] button[aria-label*="Send" i]',
      'div[data-testid="grok-editor"] button[type="submit"]',
      'div[data-testid="grok-text-input"] button[aria-label*="Send" i]',
      'div[data-testid="grok-text-input"] button[type="submit"]',
      'div[data-testid="tweetButtonInline"] button',
      'div[data-testid="tweetButtonInline"]',
      'button[data-testid="tweetButton"]',
      'button[aria-label*="send" i]',
      'button[type="submit"]',
      'button:has(svg)'
    ];

    const containers = [];
    if (composerEl) containers.push(composerEl.closest('form'));
    if (composerEl) containers.push(composerEl.closest('[data-testid="grok-editor"]'));
    if (composerEl) containers.push(composerEl.closest('[data-testid="grok-text-input"]'));
    containers.push(document);

    const startTs = Date.now();
    while (Date.now() - startTs < timeoutMs) {
      for (const container of containers) {
        if (!container || typeof container.querySelector !== 'function') continue;
        for (const selector of fallbackSelectors) {
          const candidate = container.querySelector(selector);
          if (candidate && !candidate.disabled && isElementInteractable(candidate)) {
            console.log('[content-grok] Fallback send button selector matched:', selector);
            return candidate;
          }
        }
      }
      await sleep(200);
    }
    return null;
  }

  const sanitizeValue = (value) => String(value ?? '').replace(/\u200b/g, '');

  const normalizeEchoText = (text) => String(text || '')
    .replace(/<[^>]+>/g, ' ')
    .replace(/&nbsp;/gi, ' ')
    .replace(/[^\p{L}\p{N}\s]/gu, ' ')
    .replace(/\s+/g, ' ')
    .trim()
    .toLowerCase();

  const readComposerValue = (input) => {
    if (!input) return '';
    const raw = (input.value ?? input.innerText ?? input.textContent ?? '').replace(/\u200b/g, '');
    return raw.trim();
  };

  function applyNativeValue(element, value) {
    if (!element) return;
    const tag = element.tagName;
    const proto = tag === 'INPUT'
      ? HTMLInputElement.prototype
      : tag === 'TEXTAREA'
        ? HTMLTextAreaElement.prototype
        : HTMLElement.prototype;
    const descriptor = Object.getOwnPropertyDescriptor(proto, 'value');
    if (descriptor?.set) {
      descriptor.set.call(element, value);
    } else {
      element.value = value;
    }
  }

  function emitValueChange(element, text, inputType = 'insertFromPaste') {
    if (!element) return;
    const normalized = sanitizeValue(text);
    try {
      element.focus({ preventScroll: true });
    } catch (_) {
      element.focus?.();
    }
    try {
      const beforeEvt = new InputEvent('beforeinput', {
        data: normalized,
        inputType: 'insertReplacementText',
        bubbles: true,
        cancelable: true
      });
      element.dispatchEvent(beforeEvt);
    } catch (_) {}
    if ('value' in element) {
      applyNativeValue(element, normalized);
      try {
        element.selectionStart = element.selectionEnd = element.value.length;
      } catch (_) {}
    } else {
      element.textContent = normalized;
    }
    element.dispatchEvent(new InputEvent('input', { bubbles: true, data: normalized, inputType }));
    element.dispatchEvent(new Event('change', { bubbles: true }));
    return normalized;
  }

  async function waitForComposerStabilization(input, { retries = 5, delay = 200 } = {}) {
    for (let i = 0; i < retries; i++) {
      const text = readComposerValue(input);
      if (text.length > 0) return text;
      await sleep(delay);
    }
    return readComposerValue(input);
  }

  const normalizeForComparison = (text = '') => String(text)
    .replace(/[\u200B-\u200D\uFEFF]/g, '')
    .replace(/\s+/g, ' ')
    .trim()
    .toLowerCase();

  function describeNode(node) {
    if (!node || !node.tagName) return 'unknown-node';
    const id = node.id ? `#${node.id}` : '';
    const classes = node.classList?.length ? `.${Array.from(node.classList).join('.')}` : '';
    const role = node.getAttribute?.('role');
    const editable = node.isContentEditable || node.getAttribute?.('contenteditable');
    const info = [`<${node.tagName.toLowerCase()}${id}${classes}>`];
    if (role) info.push(`role=${role}`);
    if (editable) info.push('contenteditable');
    if (node.tabIndex >= 0) info.push(`tabIndex=${node.tabIndex}`);
    return info.join(' ');
  }

  function traceNodePath(node) {
    const segments = [];
    let current = node;
    let depth = 0;
    while (current && depth < 8) {
      if (current === document) {
        segments.push('document');
        break;
      }
      segments.push(describeNode(current));
      if (current.parentElement) {
        current = current.parentElement;
      } else if (current.getRootNode && current.getRootNode().host) {
        current = current.getRootNode().host;
      } else {
        break;
      }
      depth++;
    }
    return segments.join(' <- ');
  }

  async function forceComposerValue(input, prompt) {
    if (!input) return '';
    const normalized = String(prompt ?? '');
    emitValueChange(input, normalized);
    await sleep(150);
    return readComposerValue(input);
  }

  const isPromptEcho = (candidate, prompt) => {
    if (!candidate || !prompt) return false;
    const normCandidate = normalizeEchoText(candidate);
    const normPrompt = normalizeEchoText(prompt);
    if (!normCandidate || !normPrompt) return false;
    if (normCandidate === normPrompt) return true;
    if (normCandidate.includes(normPrompt) && normCandidate.length <= normPrompt.length + 120) return true;
    const promptHead = normPrompt.slice(0, Math.min(normPrompt.length, 180));
    if (promptHead.length >= 25 && normCandidate.startsWith(promptHead)) return true;
    const limit = Math.min(normPrompt.length, normCandidate.length);
    let overlap = 0;
    for (let i = 0; i < limit; i++) {
      if (normCandidate[i] !== normPrompt[i]) break;
      overlap++;
    }
    if (overlap >= Math.min(limit, normPrompt.length * 0.9)) return true;
    return false;
  };


  // -------------------- SmartScroll / KeepAlive (Гибкий) --------------------
  const grokScrollCoordinator = window.ScrollCoordinator
    ? new window.ScrollCoordinator({
        source: `${MODEL.toLowerCase()}-smart-scroll`,
        getLifecycleMode,
        registerForceStopHandler,
        startDrift: () => startDriftFallback('soft'),
        stopDrift: () => stopDriftFallback(),
        logPrefix: `[${MODEL}] SmartScroll`
      })
    : null;

  async function withSmartScroll(asyncOperation, options = {}) {
    if (grokScrollCoordinator) {
      return grokScrollCoordinator.run(asyncOperation, options);
    }
    return asyncOperation();
  }

  function watchResponseActivity(timeout = 5000) {
    return new Promise((resolve) => {
      const root = document.querySelector('main[role="main"]') || document.querySelector('div[role="main"]') || document.body;
      if (!root) {
        setTimeout(() => resolve(false), timeout);
        return;
      }
      let settled = false;
      const finish = (result) => {
        if (settled) return;
        settled = true;
        try { observer.disconnect(); } catch (_) {}
        clearTimeout(timerId);
        resolve(result);
      };
      const observer = new MutationObserver((mutations) => {
        for (const mutation of mutations) {
          if ((mutation.addedNodes && mutation.addedNodes.length) || mutation.type === 'attributes') {
            finish(true);
            return;
          }
        }
      });
      observer.observe(root, { childList: true, subtree: true, attributes: true });
      const timerId = setTimeout(() => finish(false), timeout);
    });
  }

  async function waitForComposerClear(composerEl, timeout = 3500) {
    if (!composerEl) return false;
    const start = Date.now();
    while (Date.now() - start < timeout) {
      const text = (composerEl.value ?? composerEl.textContent ?? '').trim();
      if (!text.length) {
        return true;
      }
      await sleep(150);
    }
    return false;
  }

  function emitDiagnostic(event = {}) {
    try {
      chrome.runtime.sendMessage({
        type: 'LLM_DIAGNOSTIC_EVENT',
        llmName: MODEL,
        event: {
          ts: event.ts || Date.now(),
          type: event.type || 'INFO',
          label: event.label || '',
          details: event.details || '',
          level: event.level || 'info',
          meta: event.meta || {}
        }
      });
    } catch (err) {
      console.warn('[content-grok] Failed to emit diagnostic event', err);
    }
  }

  function simulateCtrlEnter(composerEl) {
    if (!composerEl) return;
    try {
      composerEl.focus({ preventScroll: true });
    } catch (_) {
      composerEl.focus?.();
    }
    const events = [
      new KeyboardEvent('keydown', { key: 'Control', code: 'ControlLeft', bubbles: true }),
      new KeyboardEvent('keydown', { key: 'Enter', code: 'Enter', bubbles: true, ctrlKey: true }),
      new KeyboardEvent('keypress', { key: 'Enter', code: 'Enter', bubbles: true, ctrlKey: true }),
      new KeyboardEvent('keyup', { key: 'Enter', code: 'Enter', bubbles: true, ctrlKey: true }),
      new KeyboardEvent('keyup', { key: 'Control', code: 'ControlLeft', bubbles: true })
    ];
    for (const evt of events) {
      composerEl.dispatchEvent(evt);
    }
  }

  async function attemptSendViaButton(sendBtn, composerEl) {
    const humanoid = window.Humanoid;
    if (!humanoid) return false;
    const responseWatcher = watchResponseActivity(6000);
    emitDiagnostic({ type: 'SEND', label: 'Попытка через кнопку отправки', details: 'humanoid.click', level: 'info' });
    await humanoid.click(sendBtn);
    const composerTextBefore = (composerEl?.value ?? composerEl?.textContent ?? '').trim();
    if (composerTextBefore.length) {
      emitDiagnostic({ type: 'SEND', label: 'После клика текст остался, жмем Ctrl+Enter', level: 'info' });
      simulateCtrlEnter(composerEl);
    }
    const cleared = await waitForComposerClear(composerEl, 3500);
    const responseStarted = await responseWatcher;
    const success = cleared || responseStarted;
    emitDiagnostic({
      type: 'SEND',
      label: success ? 'Кнопка отправки подтвердила отправку' : 'Кнопка отправки не подтвердила отправку',
      details: '',
      level: success ? 'success' : 'warning'
    });
    return success;
  }

  async function attemptSendViaCtrlEnter(composerEl) {
    const responseWatcher = watchResponseActivity(6000);
    emitDiagnostic({ type: 'SEND', label: 'Попытка через Ctrl+Enter', level: 'info' });
    simulateCtrlEnter(composerEl);
    const cleared = await waitForComposerClear(composerEl, 3500);
    const responseStarted = await responseWatcher;
    const success = cleared || responseStarted;
    emitDiagnostic({
      type: 'SEND',
      label: success ? 'Ctrl+Enter подтвердил отправку' : 'Ctrl+Enter не дал ответ',
      level: success ? 'success' : 'warning'
    });
    return success;
  }

  // -------------------- ContentCleaner (мягкий, без агрессивной обрезки) --------------------
  class ContentCleaner {
    constructor() {
      this.rules = this._initRules();
      this.stats = { elementsRemoved: 0, charactersRemoved: 0, rulesApplied: 0 };
    }
    _initRules() {
      return {
        uiPhrases: [
          /\b(Send|Menu|Settings|New chat|Clear|Like|Reply|Copy|Share|Follow|Subscribe)\b/gi,
          /\b(Upload|Download|Save|Delete|Edit|Search|Filter|Sort)\b/gi,
          /\b(Grok|X\.com|Twitter|Gemini|Claude|Perplexity|GPT)\b/gi
        ],
        timePatterns: [
          /\b\d{1,2}:\d{2}\s*(AM|PM)?\b/gi,
          /\b\d+\s*(hours?|minutes?|seconds?)\s*ago\b/gi,
          /\b(Just now|Yesterday|Today|Tomorrow)\b/gi
        ],
        formatting: [/\xa0/g, /&nbsp;/g, /&[a-z]+;/gi],
        urls: [/\bhttps?:\/\/[^\s<>"]+\b/gi, /\bwww\.[^\s<>"]+\b/gi],
        stripTags: [/<!--[\s\S]*?-->/g]
      };
    }
    clean(content, options = {}) {
      this.stats = { elementsRemoved: 0, charactersRemoved: 0, rulesApplied: 0 };

      const isHtml = /<\/?[a-z][\s\S]*>/i.test(content);
      let text = content;

      if (isHtml) {
        try {
          const parser = new DOMParser();
          const doc = parser.parseFromString(content, 'text/html');
          doc.querySelectorAll('script,style,svg,canvas,noscript,header,footer,nav,aside,[aria-hidden="true"]').forEach(el => {
            this.stats.elementsRemoved++;
            this.stats.charactersRemoved += (el.textContent || '').length;
            el.remove();
          });
          text = doc.body?.textContent || '';
        } catch (err) {
          console.warn('[ContentCleaner] DOMParser failed, falling back to text extraction', err);
          const div = document.createElement('div');
          div.textContent = content;
          text = div.textContent || '';
        }
      }

      const patterns = [
        ...this.rules.uiPhrases,
        ...this.rules.timePatterns,
        ...this.rules.urls,
        ...this.rules.formatting,
        ...this.rules.stripTags
      ];

      let out = text;
      for (const p of patterns) {
        const before = out.length;
        out = out.replace(p, ' ');
        const diff = before - out.length;
        if (diff > 0) {
          this.stats.rulesApplied++;
          this.stats.charactersRemoved += diff;
        }
      }

      out = out.replace(/\n\s*\n\s*\n/g, '\n\n').replace(/[ \t]+/g, ' ').trim();

      const maxLength = options.maxLength || null;
      if (maxLength && out.length > maxLength) {
        const truncated = out.slice(0, maxLength);
        const cutAt = Math.max(truncated.lastIndexOf('. '), truncated.lastIndexOf('\n\n'));
        out = (cutAt > maxLength * 0.7 ? truncated.slice(0, cutAt + 1) : truncated) + '\n\n[Content truncated]';
      }
      return out;
    }
    getStats() { return { ...this.stats }; }
  }
  const contentCleaner = new ContentCleaner();
  let lastResponseCache = '';

  function findLatestNonEchoResponse(prompt) {
    const selectors = [
      'article[data-role="assistant"]',
      'div[data-testid*="response"]',
      'div[class*="assistant"]',
      'div[class*="conversation-turn"]',
      'article',
      '.markdown'
    ];
    const nodes = Array.from(document.querySelectorAll(selectors.join(',')));
    for (let i = nodes.length - 1; i >= 0; i--) {
      const node = nodes[i];
      const txt = (node.innerText || node.textContent || '').trim();
      if (!txt) continue;
      if (isPromptEcho(txt, prompt)) continue;
      try {
        return contentCleaner.clean(txt, { maxLength: 50000 });
      } catch (_) {
        return txt;
      }
    }
    return null;
  }

  async function waitForNonEchoResponse(prompt, timeoutMs = 12000) {
    return new Promise((resolve, reject) => {
      let lastSeen = '';
      let settled = false;
      const cleanup = (value, isTimeout = false) => {
        if (settled) return;
        settled = true;
        observer.disconnect();
        clearInterval(intervalId);
        clearTimeout(timerId);
        if (value) {
          resolve(value);
        } else if (isTimeout && lastSeen) {
          resolve(lastSeen);
        } else {
          reject(new Error('Non-echo response timeout'));
        }
      };

      const evaluate = () => {
        const alt = findLatestNonEchoResponse(prompt);
        if (alt && !isPromptEcho(alt, prompt)) {
          if (alt === lastSeen) {
            cleanup(alt);
          } else {
            lastSeen = alt;
          }
        }
      };

      const observer = cleanupScope.trackObserver(new MutationObserver(() => evaluate()));
      observer.observe(document.body, { childList: true, subtree: true, characterData: true });
      const intervalId = cleanupScope.trackInterval(setInterval(() => evaluate(), 400));
      const timerId = cleanupScope.trackTimeout(setTimeout(() => cleanup(null, true), timeoutMs));
      evaluate();
    });
  }

  // -------------------- Metrics Collection System --------------------
  class MetricsCollector {
    constructor() {
      this.metrics = {
        operations: [],
        selectors: { hits: 0, misses: 0, cacheHits: 0 },
        timings: {},
        errors: []
      };
      this.startTime = Date.now();
    }
    startOperation(name, context = {}) {
      const id = `${name}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      const operation = { id, name, start: Date.now(), end: null, success: null, metadata: context || {} };
      const events = window.HumanoidEvents;
      if (events?.start) {
        try {
          operation.lifecycleTraceId = events.start(`metrics:${name}`, {
            mode: getLifecycleMode(),
            operation: name
          });
        } catch (_) {}
      }
      this.metrics.operations.push(operation);
      return id;
    }
    endOperation(id, success = true, metadata = {}) {
      const op = this.metrics.operations.find(o => o.id === id);
      if (op) {
        op.end = Date.now();
        op.duration = op.end - op.start;
        op.success = success;
        op.metadata = metadata;
        if (op.lifecycleTraceId && window.HumanoidEvents?.stop) {
          try {
            window.HumanoidEvents.stop(op.lifecycleTraceId, {
              status: success ? 'success' : 'failed',
              metadata
            });
          } catch (_) {}
          op.lifecycleTraceId = null;
        }
      }
    }
    recordSelectorEvent(type) {
      if (type === 'hit') this.metrics.selectors.hits++;
      else if (type === 'miss') this.metrics.selectors.misses++;
      else if (type === 'cache_hit') this.metrics.selectors.cacheHits++;
    }
    recordTiming(key, duration) {
      if (!this.metrics.timings[key]) this.metrics.timings[key] = [];
      this.metrics.timings[key].push(duration);
    }
    recordError(error, context = '', operationId = null) {
      this.metrics.errors.push({
        message: error?.message || String(error),
        context,
        timestamp: Date.now(),
        type: error?.type || 'unknown'
      });
      if (operationId) {
        const op = this.metrics.operations.find(o => o.id === operationId);
        if (op?.lifecycleTraceId && window.HumanoidEvents?.error) {
          try {
            window.HumanoidEvents.error(op.lifecycleTraceId, error, true);
          } catch (_) {}
        }
      }
    }
    getReport() {
      const now = Date.now();
      const successOps = this.metrics.operations.filter(o => o.success === true);
      const failedOps = this.metrics.operations.filter(o => o.success === false);
      const avgTimings = {};
      for (const [key, values] of Object.entries(this.metrics.timings)) {
        avgTimings[key] = values.reduce((a, b) => a + b, 0) / values.length;
      }
      return {
        uptime: now - this.startTime,
        operations: {
          total: this.metrics.operations.length,
          successful: successOps.length,
          failed: failedOps.length,
          successRate: this.metrics.operations.length > 0 
            ? (successOps.length / this.metrics.operations.length * 100).toFixed(2) + '%'
            : 'N/A'
        },
        selectors: this.metrics.selectors,
        timings: avgTimings,
        errors: this.metrics.errors.slice(-10),
        timestamp: now
      };
    }
    sendReport() {
      chrome.runtime.sendMessage({
        type: 'METRICS_REPORT',
        llmName: MODEL,
        metrics: this.getReport()
      });
    }
  }
  const metricsCollector = new MetricsCollector();

  cleanupScope.trackInterval(setInterval(() => metricsCollector.sendReport(), 300000));

  // -------------------- ПЕРЕНЕСЁННЫЕ ФУНКЦИИ ИЗ РАБОЧЕЙ ВЕРСИИ --------------------

  const now = () => (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();

  function resolveWritableInput(base) {
    if (!base) return null;
    const isWritable = (
      base.tagName === 'TEXTAREA' ||
      base.isContentEditable ||
      base.getAttribute?.('contenteditable') === 'true' ||
      base.getAttribute?.('role') === 'textbox'
    );
    if (isWritable) return base;
    const nestedSelectors = [
      '[role="textbox"][contenteditable="true"]',
      '[contenteditable="true"][role="textbox"]',
      '[contenteditable="true"]',
      '[data-lexical-editor] [contenteditable="true"]',
      '[data-testid*="composer"] [contenteditable="true"]',
      '[data-testid*="composer"] [role="textbox"]',
      'div[role="textbox"]',
      'textarea.tiptap-textarea',
      'textarea'
    ];
    for (const selector of nestedSelectors) {
      const scoped = base.querySelector?.(selector);
      if (scoped) return scoped;
    }
    for (const selector of nestedSelectors) {
      const globalMatch = document.querySelector(selector);
      if (globalMatch && base.contains?.(globalMatch)) {
        return globalMatch;
      }
    }
    return base;
  }

  function getComposerFromSelection() {
    const selection = window.getSelection?.();
    const anchor = selection?.anchorNode;
    if (!anchor) return null;
    let node = anchor.nodeType === 1 ? anchor : anchor.parentElement;
    let steps = 0;
    while (node && steps < 8) {
      if (isElementInteractable(node)) return resolveWritableInput(node);
      node = node.parentElement;
      steps += 1;
    }
    return null;
  }

  function getActiveComposerCandidate() {
    const active = document.activeElement;
    if (!active) return null;
    if (isElementInteractable(active)) return resolveWritableInput(active);
    if (active.shadowRoot) {
      const nested = active.shadowRoot.querySelector('textarea, div[contenteditable="true"], [role="textbox"], textarea.tiptap-textarea');
      if (nested) return resolveWritableInput(nested);
    }
    return null;
  }

  function discoverComposer() {
    const strategies = [
      { label: 'activeElement', resolver: getActiveComposerCandidate },
      { label: 'selection', resolver: getComposerFromSelection }
    ];
    for (const strategy of strategies) {
      const node = strategy.resolver();
      if (node && isElementInteractable(node)) {
        emitDiagnostic({
          type: 'SELECTOR',
          label: `Composer via ${strategy.label}`,
          details: describeNode(node),
          level: 'info'
        });
        return resolveWritableInput(node);
      }
    }
    return null;
  }

  async function findComposer(timeout = 30000) {
    const started = now();
    console.log('[content-grok] Finding composer via SelectorFinder...');
    try {
      const result = await selectorFinder.findOrDetectSelector({
        modelName: MODEL,
        elementType: 'composer',
        timeout
      });
      if (result?.element && isElementInteractable(result.element)) {
        console.log(`[content-grok] Composer found via ${result.method} in ${Math.round(now() - started)}ms`);
        if (result.method === 'cache') {
          metricsCollector.recordSelectorEvent('cache_hit');
        } else {
          metricsCollector.recordSelectorEvent('hit');
        }
        return { element: resolveWritableInput(result.element), method: result.method };
      }
      console.warn('[content-grok] SelectorFinder returned no composer element.');
    } catch (err) {
      console.warn('[content-grok] SelectorFinder composer lookup failed:', err);
    }
    metricsCollector.recordSelectorEvent('miss');
    return null;
  }

  // -------------------- Отправка результата в бекграунд --------------------
  function sendResult(text, ok = true) {
    if (ok) {
      const stats = contentCleaner.getStats();
      chrome.runtime.sendMessage({
        type: 'CONTENT_CLEANING_STATS',
        llmName: MODEL,
        stats,
        timestamp: Date.now()
      });
    }
    chrome.runtime.sendMessage({
      type: 'LLM_RESPONSE',
      llmName: MODEL,
      answer: ok ? text : `Ошибка: ${text}`
    });
  }

  // -------------------- Публичная операция: inject → wait → extract → clean → send --------------------
  async function injectAndGetResponse(prompt) {
    return runLifecycle('grok:inject', buildLifecycleContext(prompt), async (activity) => {
      const opId = metricsCollector.startOperation('injectAndGetResponse');
      const startTime = Date.now();
      try {
        return await withSmartScroll(async () => {
        await sleep(1000);
        activity.heartbeat(0.15, { phase: 'composer-search' });

        let composer = discoverComposer();
        if (composer) {
          emitDiagnostic({
            type: 'SELECTOR',
            label: 'Поле ввода найдено (heuristics)',
            details: traceNodePath(composer),
            level: 'info'
          });
        } else {
          const composerMatch = await findComposer(30000);
          if (!composerMatch?.element) {
            throw { type: 'selector_not_found', message: 'Grok input field not found' };
          }
          composer = resolveWritableInput(composerMatch.element);
          if (!composer) {
            throw { type: 'selector_not_found', message: 'Writable composer not found' };
          }
        emitDiagnostic({
          type: 'SELECTOR',
          label: 'Поле ввода найдено',
          details: `Метод: ${composerMatch.method || 'unknown'}`,
          level: 'success'
        });
        }
        activity.heartbeat(0.3, { phase: 'composer-ready' });

        const humanoid = window.Humanoid;
        if (!humanoid) {
          throw { type: 'humanoid_missing', message: 'Humanoid interaction module not available' };
        }

        await humanoid.readPage(650);
        await humanoid.typeText(composer, prompt, { instant: true });
        let validationText = await waitForComposerStabilization(composer, { retries: 6, delay: 240 });
        const normalizedPromptHead = normalizeForComparison(prompt).slice(0, 120);
        let normalizedValue = normalizeForComparison(validationText);
        if (!normalizedValue.length || (normalizedPromptHead && !normalizedValue.includes(normalizedPromptHead))) {
          emitDiagnostic({ type: 'INPUT', label: 'Повторная попытка вставки (не совпало)', level: 'warning' });
          validationText = await forceComposerValue(composer, prompt);
          normalizedValue = normalizeForComparison(validationText);
        }
        if (!normalizedValue.length || (normalizedPromptHead && !normalizedValue.includes(normalizedPromptHead))) {
          throw { type: 'injection_failed', message: 'Input did not accept value (React guard).' };
        }

        activity.heartbeat(0.4, { phase: 'typing' });
        await humanoid.readPage(480);

        let sendBtn = null;
        let sendBtnMethod = null;
        const started = now();
        console.log('[content-grok] Finding send button via SelectorFinder...');
        activity.heartbeat(0.5, { phase: 'send-button-search' });
        try {
          const result = await selectorFinder.findOrDetectSelector({
            modelName: MODEL,
            elementType: 'sendButton',
            timeout: 5000,
            referenceElement: composer
          });
          if (result?.element && !result.element.disabled) {
            console.log(`[content-grok] Send button found via ${result.method} in ${Math.round(now() - started)}ms`);
            sendBtn = result.element;
            sendBtnMethod = result.method || 'versioned';
          } else {
            console.warn('[content-grok] SelectorFinder returned no send button element.');
          }
        } catch (err) {
          console.warn('[content-grok] SelectorFinder send button lookup failed:', err);
        }

        if ((!sendBtn || sendBtn.disabled) && composer) {
          console.warn('[content-grok] SelectorFinder send button lookup failed, trying fallback DOM queries...');
          sendBtn = await fallbackFindSendButton(composer, 6000);
          if (sendBtn) {
            sendBtnMethod = 'fallback';
          }
        }

        if (!sendBtn || sendBtn.disabled) {
          emitDiagnostic({
            type: 'SELECTOR',
            label: 'Кнопка отправки не найдена',
            level: 'error'
          });
          throw { type: 'selector_not_found', message: 'Grok send button not found' };
        }
        emitDiagnostic({
          type: 'SELECTOR',
          label: 'Кнопка отправки найдена',
          details: `Метод: ${sendBtnMethod || 'unknown'}`,
          level: 'success'
        });

        if (sendBtn.disabled || sendBtn.getAttribute('aria-disabled') === 'true') {
          const enableStart = Date.now();
          while (Date.now() - enableStart < 8000) {
            if (!sendBtn.disabled && sendBtn.getAttribute('aria-disabled') !== 'true') break;
            await sleep(150);
          }
        }

        let sendMethod = 'button';
        let dispatchSuccess = await attemptSendViaButton(sendBtn, composer);
        if (!dispatchSuccess) {
          console.warn('[content-grok] Send via button did not trigger response, trying Ctrl+Enter fallback...');
          dispatchSuccess = await attemptSendViaCtrlEnter(composer);
          sendMethod = dispatchSuccess ? 'ctrl_enter' : sendMethod;
        }

        if (!dispatchSuccess) {
          emitDiagnostic({
            type: 'SEND',
            label: 'Не удалось подтвердить отправку',
            level: 'error'
          });
          throw { type: 'send_failed', message: 'Grok send action did not trigger response' };
        }
        console.log(`[content-grok] Prompt dispatched via ${sendMethod}`);
        emitDiagnostic({
          type: 'SEND',
          label: `Отправка подтверждена (${sendMethod})`,
          level: 'success'
        });
        activity.heartbeat(0.6, { phase: 'send-dispatched' });

        activity.heartbeat(0.65, { phase: 'waiting-response' });
        let pipelineAnswer = null;
        await tryGrokPipeline(prompt, {
          heartbeat: (meta = {}) => activity.heartbeat(0.8, Object.assign({ phase: 'pipeline' }, meta)),
          stop: async ({ answer, metadata }) => {
            emitDiagnostic({
              type: 'PIPELINE',
              label: 'UnifiedAnswerPipeline completed',
              details: `Duration: ${metadata?.duration ?? 0}ms`,
              level: 'success'
            });
            let cleaned = contentCleaner.clean(answer, { maxLength: 50000 });
            pipelineAnswer = cleaned;
            metricsCollector.recordTiming('total_response_time', Date.now() - startTime);
            metricsCollector.endOperation(opId, true, {
              responseLength: cleaned.length,
              duration: Date.now() - startTime,
              source: 'pipeline'
            });
            sendResult(cleaned, true);
            activity.stop({ status: 'success', answerLength: cleaned.length, source: 'pipeline' });
            return cleaned;
          }
        });
        if (pipelineAnswer) {
          return pipelineAnswer;
        }

        const responseMatch = await selectorFinder.waitForElement({
          modelName: MODEL,
          elementType: 'response',
          timeout: 150000,
          prompt
        });
        const rawText = responseMatch?.text || '';

        let cleaned = contentCleaner.clean(rawText, { maxLength: 50000 });
        if (isPromptEcho(cleaned, prompt)) {
          console.warn('[content-grok] Detected prompt echo. Waiting for alternative response...');
          const alt = await waitForNonEchoResponse(prompt, 15000);
          if (alt && !isPromptEcho(alt, prompt)) {
            cleaned = alt;
          } else {
            throw { type: 'echo_detected', message: 'Grok returned prompt back instead of response' };
          }
        }
        
        metricsCollector.recordTiming('total_response_time', Date.now() - startTime);
        metricsCollector.endOperation(opId, true, { 
          responseLength: cleaned.length,
          duration: Date.now() - startTime
        });
        sendResult(cleaned, true);
        activity.heartbeat(0.9, { phase: 'response-processed' });
        activity.stop({ status: 'success', answerLength: cleaned.length });
        return cleaned;
      }, { keepAliveInterval: 2000, operationTimeout: 300000, debug: false });
      } catch (e) {
        if (e?.code === 'background-force-stop') {
          activity.error(e, false);
          throw e;
        }
        console.error('[content-grok] injectAndGetResponse error:', e);
        metricsCollector.recordError(e, 'injectAndGetResponse', opId);
        metricsCollector.endOperation(opId, false, { error: e?.message });
        emitDiagnostic({
          type: 'ERROR',
          label: 'Ошибка обработки запроса',
          details: e?.message || 'unknown',
          level: 'error'
        });
        sendResult(e?.message || String(e), false);
        activity.error(e, true);
        throw e;
      }
    });
  }

  // -------------------- Message bus --------------------
  const onRuntimeMessage = (msg, _sender, sendResponse) => {
    try {
      if (!msg) return false;
      if (msg?.type === 'STOP_AND_CLEANUP') {
        handleForceStopMessage(msg.payload?.traceId);
        stopContentScript('manual-toggle');
        if (typeof sendResponse === 'function') {
          sendResponse({ status: 'cleaned', llmName: MODEL });
        }
        return false;
      }
      if (msg?.type === 'HUMANOID_FORCE_STOP') {
        handleForceStopMessage(msg.payload?.traceId);
        if (typeof sendResponse === 'function') {
          sendResponse({ status: 'force_stop_ack' });
        }
        return false;
      }
      
      if (msg?.type === 'HEALTH_CHECK_PING') {
        sendResponse({ type: 'HEALTH_CHECK_PONG', pingId: msg.pingId, llmName: MODEL });
        return true;
      }

      if (msg?.type === 'ANTI_SLEEP_PING') {
        if (isUserInteracting()) {
          stopDriftFallback();
          return false;
        }
        runAntiSleepPulse(msg.intensity || 'soft');
        stopDriftFallback();
        return false;
      }

      if (msg?.type === 'GET_ANSWER' || msg?.type === 'GET_FINAL_ANSWER') {
        injectAndGetResponse(msg.prompt)
          .then((resp) => {
            if (msg.isFireAndForget) {
              console.log('[content-grok] Fire-and-forget request processed. Not sending response back.');
              sendResponse?.({ status: 'success_fire_and_forget' });
              return;
            }
            const responseType = msg.type === 'GET_ANSWER' ? 'LLM_RESPONSE' : 'FINAL_LLM_RESPONSE';

            const stats = contentCleaner.getStats();
            chrome.runtime.sendMessage({ 
              type: 'CONTENT_CLEANING_STATS', 
              llmName: MODEL, 
              stats: stats, 
              timestamp: Date.now() 
            });

            chrome.runtime.sendMessage({ type: responseType, llmName: MODEL, answer: resp });
            sendResponse?.({ status: 'success' });
          })
          .catch((err) => {
            if (err?.code === 'background-force-stop') {
              sendResponse?.({ status: 'force_stopped' });
              return;
            }
            const errorMessage = err?.message || String(err) || 'Unknown error in content-grok';
            const responseType = msg.type === 'GET_ANSWER' ? 'LLM_RESPONSE' : 'FINAL_LLM_RESPONSE';
            chrome.runtime.sendMessage({
              type: responseType,
              llmName: MODEL,
              answer: `Error: ${errorMessage}`,
              error: { type: err?.type || 'generic_error', message: errorMessage }
            });
            sendResponse?.({ status: 'error', message: errorMessage });
          });
        return true;
      }

      if (msg.action === 'injectPrompt' || msg.action === 'sendPrompt' || msg.action === 'REQUEST_LLM_RESPONSE') {
        const prompt = msg.prompt || '';
        injectAndGetResponse(prompt);
      } else if (msg.action === 'getResponses') {
        const source = msg?.meta?.source || 'manual';
        emitDiagnostic({
          type: 'PING',
          label: 'Повторное извлечение ответа',
          details: `source: ${source}`,
          level: 'info'
        });

        let manualPingId = `${Date.now()}_${Math.random().toString(36).slice(2, 6)}`;
        sendResponse?.({ status: 'manual_refresh_started', pingId: manualPingId });

        (async () => {
          try {
            await withSmartScroll(async () => {
              emitDiagnostic({ type: 'PING', label: 'Ждем появления ответа', level: 'info', meta: { pingId: manualPingId } });
              const responseMatch = await selectorFinder.waitForElement({
                modelName: MODEL,
                elementType: 'response',
                timeout: 120000,
                prompt: ''
              });
              const rawText = responseMatch?.text || '';
              const cleaned = contentCleaner.clean(rawText);

              if (cleaned && cleaned !== lastResponseCache) {
                lastResponseCache = cleaned;
                sendResult(cleaned, true);
                emitDiagnostic({ type: 'PING', label: 'Ответ обновлен после ping', level: 'success', meta: { pingId: manualPingId } });
              } else {
                emitDiagnostic({ type: 'PING', label: 'Ответ не изменился после ping', level: 'info', meta: { pingId: manualPingId } });
                chrome.runtime.sendMessage({ type: 'MANUAL_PING_RESULT', llmName: MODEL, status: 'unchanged', pingId: manualPingId });
              }
            }, { keepAliveInterval: 2000, operationTimeout: 120000, debug: false });
            chrome.runtime.sendMessage({ type: 'MANUAL_PING_RESULT', llmName: MODEL, status: 'success', pingId: manualPingId });
          } catch (err) {
            if (err?.code === 'background-force-stop') {
              chrome.runtime.sendMessage({ type: 'MANUAL_PING_RESULT', llmName: MODEL, status: 'aborted', pingId: manualPingId });
              return;
            }
            emitDiagnostic({ type: 'PING', label: 'Повторное извлечение не удалось', details: err?.message || 'unknown error', level: 'error', meta: { pingId: manualPingId } });
            chrome.runtime.sendMessage({ type: 'MANUAL_PING_RESULT', llmName: MODEL, status: 'failed', error: err?.message || 'unknown error', pingId: manualPingId });
          }
        })();
        return true;
      }
    } catch (e) {
      console.error('[content-grok] onMessage error:', e);
      sendResult(e?.message || String(e), false);
    }
    return false;
  };
  chrome.runtime.onMessage.addListener(onRuntimeMessage);
  cleanupScope.register?.(() => {
    try {
      chrome.runtime.onMessage.removeListener(onRuntimeMessage);
    } catch (_) {}
  });

  // -------------------- Экспорт внутрь страницы (по необходимости) --------------------
  window.__grokAllCopyV6 = {
    injectAndGetResponse,
    contentCleaner
  };

  console.log('[content-grok] AllCopy v6 ready.');
})();
// ============================== IIFE END ==============================
