// Auto-generated by scripts/build-bundles.js @ 2025-12-02T17:36:09.126Z
(function () {
  const globalObject = typeof window !== 'undefined' ? window : self;
  globalObject.SelectorConfigRegistry = globalObject.SelectorConfigRegistry || {};
  if (globalObject.SelectorConfigRegistry.Claude) return;

  globalObject.SelectorConfigRegistry.Claude = {
    versions: [],
    emergencyFallbacks: {
      composer: [
        'textarea[data-testid="chat-input"]',
        'textarea',
        'div[role="textbox"]',
        '[contenteditable="true"]'
      ],
      sendButton: [
        'button[data-testid="send-button"]',
        'button[aria-label*="Send"]',
        'button[type="submit"]'
      ],
      //-- 1.1. Берём именно ПОСЛЕДНИЙ ответ ассистента Claude --//
      response: [
        'div[data-is-response="true"]:last-of-type [data-testid="message-text"]',
        'div[data-is-response="true"]:last-of-type article',
        'div[data-is-response="true"]:last-of-type',
        'div[data-testid="conversation-turn"][data-role="assistant"]:last-of-type [data-testid="message-text"]',
        'div[data-testid="conversation-turn"][data-author-role="assistant"]:last-of-type [data-testid="message-text"]',
        'div[data-testid="conversation-turn"][data-role="assistant"]:last-of-type article',
        'div[data-testid="conversation-turn"][data-author-role="assistant"]:last-of-type',
        '[data-testid="chat-response"]',
        '.prose',
        'main article',
        'main'
      ]
    },
    observationDefaults: {
      rootSelector: 'main',
      targetSelectors: [
        'div[data-is-response="true"]:last-of-type [data-testid="message-text"]',
        'div[data-is-response="true"]:last-of-type article',
        'div[data-testid="conversation-turn"][data-role="assistant"]:last-of-type [data-testid="message-text"]',
        'div[data-testid="conversation-turn"][data-author-role="assistant"]:last-of-type [data-testid="message-text"]',
        'div[data-testid="conversation-turn"][data-role="assistant"]:last-of-type article',
        'div[data-testid="conversation-turn"][data-author-role="assistant"]:last-of-type',
        '[data-testid="chat-response"]',
        '.prose',
        'main article'
      ],
      stabilizationDelayMs: 1800,
      endGenerationMarkers: [
        { selector: '[data-testid="chat-loader"]', type: 'disappear' }
      ]
    }
  };
})();

;
// content-claude-enhanced-final.js
// LLM: Claude Sonnet 4.5
// Created: 2025-10-17, 15:42
// ENHANCED VERSION: Combines Claude-specific logic with extended functionality from Grok v6
// Extended Features: HTTP 429 with retry, Metrics Collection, UI Version Detection, 
// Self-Healing with exponential backoff, Enhanced ContentCleaner, SmartScroll/KeepAlive
// Core Claude Features: Tab opening, prompt injection, message sending - PRESERVED

(function () {
  const resolveExtensionVersion = () => {
    try {
      return chrome?.runtime?.getManifest?.()?.version || 'unknown';
    } catch (_) {
      return 'unknown';
    }
  };
  // ==================== Duplicate Guard ====================
  if (window.claudeContentScriptLoaded) {
    console.warn('[content-claude] Script already loaded, skipping duplicate initialization');
    throw new Error('Duplicate script load prevented');
  }
  //-- 2.1.1. Вставить: Guard для SelectorFinder --//
if (typeof window.SelectorFinder === 'undefined') {
  console.warn('[content-claude] SelectorFinder not present — auto-detection disabled. Ensure selector-finder.js is injected before this script.');
}

  window.claudeContentScriptLoaded = {
    timestamp: Date.now(),
    version: resolveExtensionVersion(),
    source: 'content-claude'
  };
  console.log('[content-claude] Enhanced version initializing...');

  const MODEL = 'Claude';
  const getLifecycleMode = () => {
    if (typeof window !== 'undefined') {
      if (window.__humanoidActivityMode) return window.__humanoidActivityMode;
      if (document?.visibilityState === 'hidden') return 'background';
    }
    return 'interactive';
  };
  const buildLifecycleContext = (prompt = '', extra = {}) => ({
    promptLength: prompt?.length || 0,
    evaluator: Boolean(extra.evaluator),
    mode: extra.mode || getLifecycleMode()
  });
  const getForceStopRegistry = () => {
    if (window.__humanoidForceStopRegistry) {
      return window.__humanoidForceStopRegistry;
    }
    const handlers = new Set();
    window.__humanoidForceStopRegistry = {
      register(handler) {
        if (typeof handler !== 'function') return () => {};
        handlers.add(handler);
        return () => handlers.delete(handler);
      },
      run(reason) {
        handlers.forEach((fn) => {
          try { fn(reason); } catch (_) {}
        });
      }
    };
    return window.__humanoidForceStopRegistry;
  };
  const registerForceStopHandler = (handler) => getForceStopRegistry().register(handler);
  const handleForceStopMessage = (traceId) => {
    if (traceId && window.HumanoidEvents?.stop) {
      try {
        window.HumanoidEvents.stop(traceId, { status: 'forced', reason: 'background-force-stop' });
      } catch (_) {}
    }
    getForceStopRegistry().run('background-force-stop');
  };

  const cleanupScope = window.HumanoidCleanup?.createScope?.(`${MODEL.toLowerCase()}-content`) || {
    trackInterval: (id) => id,
    trackTimeout: (id) => id,
    trackObserver: (observer) => observer,
    trackAbortController: (controller) => controller,
    register: () => () => {},
    addEventListener: () => () => {},
    cleanup: () => {},
    isCleaned: () => false,
    getReason: () => null
  };
  let scriptStopped = false;
  const stopContentScript = (reason = 'manual-stop') => {
    if (scriptStopped) return cleanupScope.getReason?.() || reason;
    scriptStopped = true;
    console.warn('[content-claude] Cleanup triggered:', reason);
    try {
      getForceStopRegistry().run(reason);
    } catch (_) {}
    try {
      cleanupScope.cleanup?.(reason);
    } catch (err) {
      console.warn('[content-claude] Cleanup scope failed', err);
    }
    try {
      window.claudeContentScriptLoaded = null;
    } catch (_) {}
    return reason;
  };
  window.__cleanup_claude = stopContentScript;
  cleanupScope.addEventListener?.(window, 'pagehide', () => stopContentScript('pagehide'));
  cleanupScope.addEventListener?.(window, 'beforeunload', () => stopContentScript('beforeunload'));

  const getHumanoid = () => (typeof window !== 'undefined' ? window.Humanoid : null);

  window.setupHumanoidFetchMonitor?.(MODEL, ({ status, retryAfter, url }) => {
    if (status !== 429) return;
    const waitTime = retryAfter ? parseInt(retryAfter, 10) * 1000 || 60000 : 60000;
    console.error('[HTTP 429 Interceptor] Rate limit detected!', url || 'unknown');
    chrome.runtime.sendMessage({
      type: 'LLM_RESPONSE',
      llmName: MODEL,
      answer: 'Error: Rate limit detected. Please wait.',
      error: { 
        type: 'rate_limit', 
        message: `HTTP 429 detected. Suggested wait time: ${waitTime}ms`,
        waitTime
      }
    });
  });

  // ==================== Utilities ====================
  const sleep = (ms) => new Promise((r) => setTimeout(r, ms));
  const isUserInteracting = () => {
    if (document.hidden) return true;
    const el = document.activeElement;
    if (!el) return false;
    const tag = el.tagName;
    return tag === 'INPUT' || tag === 'TEXTAREA' || el.isContentEditable;
  };
  const keepAliveMutex = (() => {
    const key = '__keepAliveMutex';
    if (window[key]) return window[key];
    let locked = false;
    const queue = [];
    const run = async (fn) => {
      if (locked) {
        await new Promise((resolve) => queue.push(resolve));
      }
      locked = true;
      try {
        return await fn();
      } finally {
        locked = false;
        const next = queue.shift();
        if (next) next();
      }
    };
    const mutex = { run };
    window[key] = mutex;
    return mutex;
  })();

  const runLifecycle = (source, context, executor) => {
    if (typeof window.withHumanoidActivity === 'function') {
      return window.withHumanoidActivity(source, context, executor);
    }
    return executor({
      traceId: null,
      heartbeat: () => {},
      stop: () => {},
      error: () => {}
    });
  };
  const startDriftFallback = (intensity = 'soft') => {
    const humanoid = getHumanoid();
    if (humanoid?.startAntiSleepDrift) {
      humanoid.startAntiSleepDrift(intensity);
      return;
    }
    window.scrollBy({ top: (Math.random() > 0.5 ? 1 : -1) * (intensity === 'hard' ? 24 : 12), behavior: 'auto' });
  };

  const stopDriftFallback = () => {
    const humanoid = getHumanoid();
    humanoid?.stopAntiSleepDrift?.();
  };

  const createKeepAliveHeartbeat = (source) => {
    let traceId = null;
    let cleanupTimer = null;
    return (meta = {}) => {
      const lifecycle = window.HumanoidEvents;
      if (!lifecycle?.start) return;
      if (!traceId) {
        try {
          traceId = lifecycle.start(source, { mode: 'anti-sleep', source });
        } catch (err) {
          console.warn(`[${source}] keepalive trace failed`, err);
          return;
        }
      }
      try {
        lifecycle.heartbeat(traceId, meta.progress || 0, Object.assign({ phase: 'keepalive-pulse' }, meta));
      } catch (err) {
        console.warn(`[${source}] keepalive heartbeat failed`, err);
      }
      if (cleanupTimer) clearTimeout(cleanupTimer);
      cleanupTimer = setTimeout(() => {
        try { lifecycle.stop(traceId, { status: 'idle' }); } catch (_) {}
        traceId = null;
      }, 8000);
    };
  };
  const emitKeepAliveHeartbeat = createKeepAliveHeartbeat(`${MODEL.toLowerCase()}:keepalive`);

  function isElementInteractable(element) {
    if (!element) return false;
    if (element.getAttribute && element.getAttribute('disabled') !== null) return false;
    const style = element.style || {};
    if (style.display === 'none' || style.visibility === 'hidden') return false;
    const rect = element.getBoundingClientRect?.();
    if (!rect) return true;
    return element.offsetParent !== null && rect.width > 0 && rect.height > 0;
  }

  const runAntiSleepPulse = (intensity = 'soft') => {
    emitKeepAliveHeartbeat({ action: 'keep-alive-ping', intensity, model: MODEL });
    const delta = intensity === 'hard' ? 28 : intensity === 'medium' ? 16 : 8;
    keepAliveMutex.run(async () => {
      try {
        const Toolkit = window.__UniversalScrollToolkit;
        if (Toolkit) {
          const tk = new Toolkit({ idleThreshold: 800, driftStepMs: 40 });
          const ok = await tk.keepAliveTick?.((Math.random() > 0.5 ? 1 : -1) * delta);
          if (ok !== undefined) return;
        }
      } catch (_) {}
      startDriftFallback(intensity);
    });
  };

  // ==================== Metrics Collection System ====================
  class MetricsCollector {
    constructor() {
      this.metrics = {
        operations: [],
        selectors: { hits: 0, misses: 0, cacheHits: 0 },
        timings: {},
        errors: []
      };
      this.startTime = Date.now();
    }
    
    startOperation(name, context = {}) {
      const id = `${name}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      const op = {
        id,
        name,
        start: Date.now(),
        end: null,
        success: null,
        metadata: context || {},
        lifecycleTraceId: null
      };
      const events = window.HumanoidEvents;
      if (events?.start) {
        try {
          op.lifecycleTraceId = events.start(`metrics:${name}`, {
            mode: getLifecycleMode(),
            operation: name
          });
        } catch (_) {}
      }
      this.metrics.operations.push(op);
      return id;
    }
    
    endOperation(id, success = true, metadata = {}) {
      const op = this.metrics.operations.find(o => o.id === id);
      if (op) {
        op.end = Date.now();
        op.duration = op.end - op.start;
        op.success = success;
        op.metadata = metadata;
        if (op.lifecycleTraceId && window.HumanoidEvents?.stop) {
          try {
            window.HumanoidEvents.stop(op.lifecycleTraceId, {
              status: success ? 'success' : 'failed',
              metadata
            });
          } catch (_) {}
          op.lifecycleTraceId = null;
        }
      }
    }
    
    recordSelectorEvent(type) {
      if (type === 'hit') this.metrics.selectors.hits++;
      else if (type === 'miss') this.metrics.selectors.misses++;
      else if (type === 'cache_hit') this.metrics.selectors.cacheHits++;
    }
    
    recordTiming(key, duration) {
      if (!this.metrics.timings[key]) this.metrics.timings[key] = [];
      this.metrics.timings[key].push(duration);
    }
    
    recordError(error, context = '', operationId = null) {
      this.metrics.errors.push({
        message: error?.message || String(error),
        context,
        timestamp: Date.now(),
        type: error?.type || 'unknown'
      });
      if (operationId) {
        const op = this.metrics.operations.find(o => o.id === operationId);
        if (op?.lifecycleTraceId && window.HumanoidEvents?.error) {
          try {
            window.HumanoidEvents.error(op.lifecycleTraceId, error, true);
          } catch (_) {}
        }
      }
    }
    
    getReport() {
      const now = Date.now();
      const successOps = this.metrics.operations.filter(o => o.success === true);
      const failedOps = this.metrics.operations.filter(o => o.success === false);
      const avgTimings = {};
      
      for (const [key, values] of Object.entries(this.metrics.timings)) {
        avgTimings[key] = values.reduce((a, b) => a + b, 0) / values.length;
      }
      
      return {
        uptime: now - this.startTime,
        operations: {
          total: this.metrics.operations.length,
          successful: successOps.length,
          failed: failedOps.length,
          successRate: this.metrics.operations.length > 0 
            ? (successOps.length / this.metrics.operations.length * 100).toFixed(2) + '%'
            : 'N/A'
        },
        selectors: this.metrics.selectors,
        timings: avgTimings,
        errors: this.metrics.errors.slice(-10),
        timestamp: now
      };
    }
    
    sendReport() {
      chrome.runtime.sendMessage({
        type: 'METRICS_REPORT',
        llmName: MODEL,
        metrics: this.getReport()
      });
    }
  }
  
  const metricsCollector = new MetricsCollector();
  cleanupScope.trackInterval(setInterval(() => metricsCollector.sendReport(), 300000)); // Every 5 minutes

  // ==================== UI Version Detection ====================
  class UIVersionDetector {
    constructor() {
      this.version = this.detectVersion();
      this.selectors = this.getSelectorsByVersion();
      console.log(`[UIVersionDetector] Detected UI version: ${this.version}`);
    }
    
    detectVersion() {
      if (document.querySelector('div[data-is-response="true"]')) {
        return 'claude_v2';
      }
      if (document.querySelector('div[data-testid="conversation-turn"]')) {
        return 'claude_v1';
      }
      if (document.querySelector('div.ProseMirror[contenteditable="true"]')) {
        return 'claude_prosemirror';
      }
      return 'unknown';
    }
    
    getSelectorsByVersion() {
      const selectorMap = {
        claude_v2: {
          composer: [
            'div.ProseMirror[contenteditable="true"]',
            'div[contenteditable="true"][role="textbox"]'
          ],
          sendButton: [
            'button[aria-label*="Send"]',
            'button[data-testid="send-button"]'
          ],
          response: [
            'div[data-is-response="true"]',
            'div[data-testid="conversation-turn"]'
          ]
        },
        claude_v1: {
          composer: [
            'div.ProseMirror[contenteditable="true"]',
            'div[contenteditable="true"]'
          ],
          sendButton: [
            'button[aria-label*="Send"]',
            'button:has(svg)'
          ],
          response: [
            'div[data-testid="conversation-turn"]',
            'div[data-is-response="true"]'
          ]
        },
        claude_prosemirror: {
          composer: [
            'div.ProseMirror[contenteditable="true"]'
          ],
          sendButton: [
            'button[aria-label*="Send"]'
          ],
          response: [
            'div[data-is-response="true"]'
          ]
        },
        unknown: {
          composer: [
            'div.ProseMirror[contenteditable="true"]',
            'div[contenteditable="true"]',
            'textarea'
          ],
          sendButton: [
            'button[aria-label*="Send"]',
            'button[type="submit"]'
          ],
          response: [
            'div[data-is-response="true"]',
            'article',
            'main'
          ]
        }
      };
      return selectorMap[this.version] || selectorMap.unknown;
    }
    
    getComposerSelectors() {
      return this.selectors.composer;
    }
    
    getSendButtonSelectors() {
      return this.selectors.sendButton;
    }
    
    getResponseSelectors() {
      return this.selectors.response;
    }
  }
  
  const uiDetector = new UIVersionDetector();

  // ==================== Self-Healing Element Finder with Exponential Backoff ====================
  async function findAndCacheElement(selectorKey, selectorArray, timeout = 30000, scope = document) {
    const opId = metricsCollector.startOperation(`findElement_${selectorKey}`);
    const storageKey = `selector_cache_${MODEL}_${selectorKey}`;
    
    try {
      const existing = await chrome.storage.local.get(storageKey);
      const cached = existing[storageKey];
      if (cached) {
        const el = scope.querySelector(cached);
        if (isElementInteractable(el)) {
          console.log(`[Self-Healing] Using cached selector for "${selectorKey}": ${cached}`);
          metricsCollector.recordSelectorEvent('cache_hit');
          metricsCollector.endOperation(opId, true, { cached: true, selector: cached });
          return el;
        }
      }
    } catch (_) {}
    
    const start = Date.now();
    let attempt = 0;
    const baseDelay = 200;
    const maxDelay = 5000;
    
    while (Date.now() - start < timeout) {
      for (const sel of selectorArray) {
        try {
          const el = scope.querySelector(sel);
          if (isElementInteractable(el)) {
            try { await chrome.storage.local.set({ [storageKey]: sel }); } catch (_) {}
            console.log(`[Self-Healing] Found & cached selector for "${selectorKey}": ${sel} (attempt ${attempt + 1})`);
            metricsCollector.recordSelectorEvent('hit');
            metricsCollector.endOperation(opId, true, { selector: sel, attempts: attempt + 1 });
            return el;
          }
        } catch (e) {
          console.warn(`[Self-Healing] Bad selector "${sel}"`, e);
        }
      }
      
      const delay = Math.min(baseDelay * Math.pow(2, attempt), maxDelay);
      await sleep(delay);
      attempt++;
    }
    
    metricsCollector.recordSelectorEvent('miss');
    metricsCollector.endOperation(opId, false, { attempts: attempt });
    throw new Error(`Element not found for "${selectorKey}" after ${attempt} attempts`);
  }

  // ==================== SmartScroll / KeepAlive ====================
  const claudeScrollCoordinator = window.ScrollCoordinator
    ? new window.ScrollCoordinator({
        source: `${MODEL.toLowerCase()}-smart-scroll`,
        getLifecycleMode,
        registerForceStopHandler,
        startDrift: () => startDriftFallback('soft'),
        stopDrift: () => stopDriftFallback(),
        logPrefix: `[${MODEL}] SmartScroll`
      })
    : null;

  async function withSmartScroll(asyncOperation, options = {}) {
    if (claudeScrollCoordinator) {
      return claudeScrollCoordinator.run(asyncOperation, options);
    }
    return asyncOperation();
  }

  // ==================== Enhanced Content Cleaning System ====================
  class ContentCleaner {
    constructor() {
      this.rules = this._initRules();
      this.stats = { elementsRemoved: 0, charactersRemoved: 0, rulesApplied: 0 };
    }
    
    _initRules() {
      return {
        uiPhrases: [
          /\b(Send|Menu|Settings|New chat|Clear|Like|Reply|Copy|Share|Follow|Subscribe)\b/gi,
          /\b(Upload|Download|Save|Delete|Edit|Search|Filter|Sort)\b/gi,
          /\b(Claude|Anthropic|Gemini|Google|Grok|GPT)\b/gi
        ],
        timePatterns: [
          /\b\d{1,2}:\d{2}\s*(AM|PM)?\b/gi,
          /\b\d+\s*(hours?|minutes?|seconds?)\s*ago\b/gi,
          /\b(Just now|Yesterday|Today|Tomorrow)\b/gi
        ],
        formatting: [/\xa0/g, /&nbsp;/g, /&[a-z]+;/gi],
        urls: [/\bhttps?:\/\/[^\s<>"]+\b/gi, /\bwww\.[^\s<>"]+\b/gi],
        stripTags: [/<!--[\s\S]*?-->/g]
      };
    }
    
    clean(content, options = {}) {
      const startTime = Date.now();
      this.stats = { elementsRemoved: 0, charactersRemoved: 0, rulesApplied: 0 };

      const isHtml = /<\/?[a-z][\s\S]*>/i.test(content);
      let text = content;

      if (isHtml) {
        try {
          const parser = new DOMParser();
          const doc = parser.parseFromString(content, 'text/html');
          doc.querySelectorAll('script,style,svg,canvas,noscript,header,footer,nav,aside,[aria-hidden="true"]').forEach(el => {
            this.stats.elementsRemoved++;
            this.stats.charactersRemoved += (el.textContent || '').length;
            el.remove();
          });
          text = doc.body?.textContent || '';
        } catch (err) {
          console.warn('[ContentCleaner] DOMParser failed in Claude cleaner, falling back to text extraction', err);
          const div = document.createElement('div');
          div.textContent = content;
          text = div.textContent || '';
        }
      }

      const patterns = [
        ...this.rules.uiPhrases,
        ...this.rules.timePatterns,
        ...this.rules.urls,
        ...this.rules.formatting,
        ...this.rules.stripTags
      ];

      let out = text;
      for (const p of patterns) {
        const before = out.length;
        out = out.replace(p, ' ');
        const diff = before - out.length;
        if (diff > 0) {
          this.stats.rulesApplied++;
          this.stats.charactersRemoved += diff;
        }
      }

      out = out.replace(/\n\s*\n\s*\n/g, '\n\n').replace(/[ \t]+/g, ' ').trim();

      const maxLength = options.maxLength || null;
      if (maxLength && out.length > maxLength) {
        const truncated = out.slice(0, maxLength);
        const cutAt = Math.max(truncated.lastIndexOf('. '), truncated.lastIndexOf('\n\n'));
        out = (cutAt > maxLength * 0.7 ? truncated.slice(0, cutAt + 1) : truncated) + '\n\n[Content truncated]';
      }
      
      const processingTime = Date.now() - startTime;
      console.log(`[ContentCleaner] Cleaning completed in ${processingTime}ms. Final length: ${out.length}`);
      return out;
    }
    
    // Legacy API compatibility
    cleanContent(content, options = {}) {
      return this.clean(content, options);
    }
    
    getStats() { 
      return { ...this.stats }; 
    }
    
    // Legacy API compatibility
    getCleaningStats() {
      return this.getStats();
    }
  }
  
  const contentCleaner = new ContentCleaner();
  window.contentCleaner = contentCleaner; // Export for compatibility

  // ==================== Quick Hash for Stability Detection ====================
  function quickHash(s) {
    let h = 0, i = 0, len = s.length;
    while (i < len) { h = (h << 5) - h + s.charCodeAt(i++) | 0; }
    return h >>> 0;
  }

  // ==================== Claude-Specific Text Input (PRESERVED) ====================
  async function typeWithHumanPauses(element, prompt) {
    const opId = metricsCollector.startOperation('typeWithHumanPauses');
    console.log('[content-claude] Starting optimized typing, length:', prompt.length);
    
    element.textContent = '';
    element.focus();
    await sleep(300);

    // Strategy 1: Direct assignment
    try {
      element.textContent = prompt;
      element.dispatchEvent(new Event('input', { bubbles: true }));
      element.dispatchEvent(new Event('change', { bubbles: true }));
      await sleep(500);
      
      if ((element.textContent || '').includes(prompt.substring(0, 20))) {
        console.log('[content-claude] ✅ Direct assignment successful');
        metricsCollector.endOperation(opId, true, { method: 'direct' });
        return true;
      }
    } catch (error) { 
      console.warn('[content-claude] Direct assignment failed:', error); 
    }

    // Strategy 2: Gradual input (fallback)
    console.log('[content-claude] Falling back to gradual input');
    try {
      for (let i = 0; i < prompt.length; i++) {
        element.textContent += prompt[i];
        if (i % 5 === 0) {
          element.dispatchEvent(new InputEvent('input', { 
            inputType: 'insertText', 
            data: prompt[i], 
            bubbles: true 
          }));
          await sleep(5 + Math.random() * 5);
        }
      }
      element.dispatchEvent(new Event('change', { bubbles: true }));
      console.log('[content-claude] Gradual input completed');
      metricsCollector.endOperation(opId, true, { method: 'gradual' });
      return true;
    } catch (error) {
      console.error('[content-claude] All typing methods failed:', error);
      metricsCollector.recordError(error, 'typeWithHumanPauses');
      metricsCollector.endOperation(opId, false);
      throw error;
    }
  }

  const CLAUDE_ASSISTANT_RESPONSE_SELECTORS = [
    'div[data-testid="conversation-turn"][data-author-role="assistant"]',
    'div[data-testid="conversation-turn"][data-role="assistant"]',
    'div[data-is-response="true"][data-author-role="assistant"]',
    'div[data-is-response="true"][data-role="assistant"]',
    'div[data-message-author-role="assistant"]',
    '[data-testid="chat-response"]',
    '[data-testid="assistant-response"]'
  ];

  const CLAUDE_RESPONSE_FALLBACK_SELECTORS = [
    'div[data-is-response="true"]',
    'div[data-testid="conversation-turn"]',
    '.font-claude-message',
    '[class*="font-claude"]',
    'div[class*="group"][class*="agent"] p',
    'main div.font-user-message ~ div p',
    'div[class*="markdown"] p'
  ];

  function normalizeForPromptComparison(text = '') {
    return text
      .replace(/[\u200B-\u200D\uFEFF]/g, '')
      .replace(/^\s*(you said|you|user|prompt)\s*[:\-–]?\s*/i, '')
      .replace(/\s+/g, ' ')
      .trim()
      .toLowerCase();
  }

  function stripAssistantLeadIn(text = '') {
    if (!text) return '';
    return text.replace(/^\s*(?:assistant|answer|claude|a|а)\s*[:\-–]?\s*/i, '').trimStart();
  }

  function stripPromptEchoFromText(text = '', originalPrompt = '', cachedNormalizedPrompt = '') {
    if (!text) return '';
    let cleaned = stripAssistantLeadIn(text);
    cleaned = cleaned.replace(/^\s*(?:prompt|question|вопрос|user|you)\s*[:\-–]\s*/i, '').trimStart();

    const prompt = (originalPrompt || '').trim();
    const normalizedPrompt = cachedNormalizedPrompt || normalizeForPromptComparison(prompt);
    if (!prompt || !normalizedPrompt) {
      return cleaned.trim();
    }

    let normalizedCandidate = normalizeForPromptComparison(cleaned);
    if (!normalizedCandidate) {
      return cleaned.trim();
    }

    let attempts = 0;
    while (attempts < 2) {
      const idx = normalizedCandidate.indexOf(normalizedPrompt);
      if (idx === -1 || idx > Math.max(8, normalizedPrompt.length * 0.35)) {
        break;
      }

      const removalLength = Math.min(
        cleaned.length,
        Math.max(Math.round(prompt.length * 1.1), Math.round(normalizedPrompt.length * 1.6), 12)
      );
      cleaned = cleaned.slice(removalLength).trimStart();
      normalizedCandidate = normalizeForPromptComparison(cleaned);
      attempts++;
    }

    if (!cleaned) return '';

    const cachedPromptHead = normalizeForPromptComparison(prompt.slice(0, Math.min(prompt.length, 80)));
    const lines = cleaned.split(/\n+/);
    if (lines.length > 1) {
      const firstLineNorm = normalizeForPromptComparison(lines[0]);
      if (
        firstLineNorm &&
        cachedPromptHead &&
        (cachedPromptHead.startsWith(firstLineNorm) ||
          firstLineNorm.startsWith(cachedPromptHead) ||
          Math.abs(firstLineNorm.length - cachedPromptHead.length) < 6)
      ) {
        lines.shift();
        cleaned = lines.join('\n').trim();
      }
    }

    return cleaned.trim();
  }

  function looksLikePromptEcho(candidateText, normalizedPrompt) {
    if (!normalizedPrompt || !candidateText) return false;
    const normalizedCandidate = normalizeForPromptComparison(candidateText);
    if (!normalizedCandidate) return false;
    if (normalizedCandidate === normalizedPrompt) return true;
    const lengthDelta = Math.abs(normalizedCandidate.length - normalizedPrompt.length);
    if (normalizedCandidate.endsWith(normalizedPrompt) && lengthDelta < 30) return true;
    if (
      normalizedCandidate.includes(normalizedPrompt) &&
      normalizedCandidate.length / Math.max(normalizedPrompt.length, 1) < 1.15
    ) {
      return true;
    }
    return false;
  }

  function collectClaudeResponseElements() {
    const primary = Array.from(
      document.querySelectorAll(CLAUDE_ASSISTANT_RESPONSE_SELECTORS.join(', '))
    );
    if (primary.length) return primary;
    return Array.from(document.querySelectorAll(CLAUDE_RESPONSE_FALLBACK_SELECTORS.join(', ')));
  }

  function detectClaudeMessageRole(element) {
    if (!element) return 'unknown';
    const nodesToInspect = [];
    let cursor = element;
    let depth = 0;
    while (cursor && depth < 4) {
      nodesToInspect.push(cursor);
      cursor = cursor.parentElement;
      depth++;
    }
    const attrNames = ['data-author-role', 'data-role', 'data-message-author-role', 'data-testid'];
    for (const node of nodesToInspect) {
      for (const attr of attrNames) {
        const value = node.getAttribute?.(attr);
        if (!value) continue;
        const normalized = value.toLowerCase();
        if (normalized.includes('assistant') || normalized.includes('claude') || normalized.includes('bot')) {
          return 'assistant';
        }
        if (normalized.includes('user') || normalized.includes('you') || normalized.includes('customer')) {
          return 'user';
        }
      }
      const className = typeof node.className === 'string' ? node.className.toLowerCase() : '';
      if (className) {
        if (/font-claude|assistant|from-claude|by-claude|assistant-message/.test(className)) {
          return 'assistant';
        }
        if (/font-user|from-user|user-message|by-user|author-user/.test(className)) {
          return 'user';
        }
      }
    }
    const authorHint = element.querySelector?.('[data-testid="message-author"], [data-testid="conversation-author"]');
    const authorText = authorHint?.textContent?.trim().toLowerCase();
    if (authorText) {
      if (/\bclaude\b|\bassistant\b/.test(authorText)) return 'assistant';
      if (/\byou\b|\buser\b/.test(authorText)) return 'user';
    }
    return 'unknown';
  }

  function selectLatestAssistantCandidate(elements, normalizedPrompt, originalPrompt) {
    for (let i = elements.length - 1; i >= 0; i--) {
      const element = elements[i];
      const text = extractResponseText(element);
      if (!text || text.trim().length < 2) continue;
      const role = detectClaudeMessageRole(element);
      if (role === 'user') continue;
      if (looksLikePromptEcho(text, normalizedPrompt)) continue;
      const sanitized = stripPromptEchoFromText(text, originalPrompt, normalizedPrompt);
      if (!sanitized || sanitized.length < 5) continue;
      return { element, text: sanitized, role };
    }
    return null;
  }

  const isPromptEchoStrict = (text = '', normalizedPrompt = '') => {
    if (!text || !normalizedPrompt) return false;
    const normalizedCandidate = normalizeForPromptComparison(text);
    if (!normalizedCandidate) return false;
    if (normalizedCandidate === normalizedPrompt) return true;
    if (normalizedCandidate.startsWith(normalizedPrompt) && normalizedCandidate.length <= normalizedPrompt.length + 80) {
      return true;
    }
    if (normalizedPrompt.startsWith(normalizedCandidate) && normalizedCandidate.length >= normalizedPrompt.length * 0.7) {
      return true;
    }
    return false;
  };

  // ==================== Claude-Specific Response Detection with Stability ====================
  async function waitForClaudeResponse(timeout = 120000, promptText = '') {
    const opId = metricsCollector.startOperation('waitForClaudeResponse');
    const start = Date.now();

    if (window.UnifiedAnswerPipeline) {
      try {
        const pipeline = new window.UnifiedAnswerPipeline('Claude', {
          expectedLength: promptText && promptText.length > 2000 ? 'long' : 'medium',
          answerSelectors: [
            '[data-testid="conversation-turn"][data-testid-message-author*="assistant"] .prose',
            '[data-testid="conversation-turn"] .markdown',
            '.chat-message .markdown',
            'main article'
          ],
          typingIndicatorSelectors: [
            '[data-testid="typing"]',
            '.typing-indicator',
            '.animate-pulse',
            '[class*="streaming"]'
          ],
          streamStartSelectors: [
            '[data-testid="conversation-turn"]',
            '[data-testid="chat-spinner"]',
            '.chat-message'
          ],
          enableHumanActivity: true
        });
        const pipelineResult = await pipeline.execute();
        if (pipelineResult?.success && pipelineResult.answer) {
          metricsCollector.endOperation(opId, true, {
            responseLength: pipelineResult.answer.length,
            waitTime: Date.now() - start,
            source: 'UnifiedAnswerPipeline'
          });
          return pipelineResult.answer;
        }
      } catch (pipelineError) {
        console.warn('[content-claude] UnifiedAnswerPipeline fallback failed, using legacy flow', pipelineError);
      }
    }

    const normalizedPrompt = normalizeForPromptComparison(promptText || '');
    const evaluateCandidate = () => {
      const responseElements = collectClaudeResponseElements();
      if (!responseElements.length) return null;
      const candidate = selectLatestAssistantCandidate(responseElements, normalizedPrompt, promptText);
      if (!candidate || !candidate.text || candidate.text.length < 5) return null;
      if (normalizedPrompt && isPromptEchoStrict(candidate.text, normalizedPrompt)) return null;
      const isGenerating = document.querySelector(
        '.animate-pulse, [class*="streaming"], [data-testid="chat-spinner"], .typing-indicator, .animate-spin'
      );
      return { text: candidate.text, hash: quickHash(candidate.text), isGenerating };
    };

    const result = await new Promise((resolve, reject) => {
      let lastHash = 0;
      let lastText = '';
      let stableCount = 0;
      let lastChangeTs = Date.now();
      let settled = false;

      const cleanup = (value, isTimeout = false) => {
        if (settled) return;
        settled = true;
        observer.disconnect();
        clearInterval(intervalId);
        clearTimeout(timerId);
        if (value) {
          resolve(value);
        } else if (isTimeout && lastText) {
          console.warn('[content-claude] Timeout reached, returning last text');
          resolve(lastText);
        } else {
          reject(new Error('Claude response timeout'));
        }
      };

      const evaluate = () => {
        const snapshot = evaluateCandidate();
        if (!snapshot) return;
        const { text, hash, isGenerating } = snapshot;
        if (hash !== lastHash) {
          lastHash = hash;
          lastText = text;
          stableCount = 0;
          lastChangeTs = Date.now();
          return;
        }
        if (!isGenerating && text.length > 10) {
          stableCount += 1;
          if (stableCount >= 2 || Date.now() - lastChangeTs >= 6500) {
            console.log('[content-claude] Response stabilized.');
            cleanup(text);
          }
        } else {
          stableCount = 0;
          lastChangeTs = Date.now();
        }
      };

      const observer = cleanupScope.trackObserver(new MutationObserver(() => evaluate()));
      observer.observe(document.body, { childList: true, subtree: true, characterData: true });
      const intervalId = cleanupScope.trackInterval(setInterval(() => evaluate(), 900));
      const timerId = cleanupScope.trackTimeout(setTimeout(() => cleanup(null, true), timeout));
      evaluate();
    });

    metricsCollector.recordTiming('response_wait_time', Date.now() - start);
    metricsCollector.endOperation(opId, true, {
      responseLength: result.length,
      waitTime: Date.now() - start,
      source: 'observer'
    });
    return result;
  }


function extractResponseText(element) {
    if (!element) return '';
    
    let container = element.closest('div[data-testid="conversation-turn"], [data-message-author-role="assistant"]');
    if (!container) {
      container = element;
    }
    
    const clone = container.cloneNode(true);
    clone.querySelectorAll('button, svg, img, [aria-hidden="true"], header, footer, form').forEach(el => el.remove());
    const text = (clone.textContent || clone.innerText || '').trim();
    
    console.log(`[extractResponseText] Extracted ${text.length} characters`);
    return text;
  }

//-- 2.2.1. Вставить: autoExtractResponse для Claude (non-destructive) --//
async function autoExtractResponse(prompt, composerEl) {
  if (window.SelectorFinder) {
    try {
      const res = await window.SelectorFinder.findOrDetectResponseSelector({
        modelName: 'Claude', domain: location.hostname, prompt, composerEl, debug: false
      });
      if (res && res.selector) {
        const el = document.querySelector(res.selector);
        if (el && (el.innerText || el.textContent || '').trim()) return (el.innerText || el.textContent || '').trim();
        for (const n of window.SelectorFinder._internals.deepElements(document)) {
          try {
            const sub = n.shadowRoot && n.shadowRoot.querySelector && n.shadowRoot.querySelector(res.selector);
            if (sub && (sub.innerText || sub.textContent || '').trim()) return (sub.innerText || sub.textContent || '').trim();
          } catch (e) {}
        }
      }
    } catch (e) {
      console.warn('[content-claude] SelectorFinder error', e);
    }
  }
  return await autoExtractResponse(prompt, composer);
}


  // ==================== Main Injection Logic (PRESERVED Claude-specific flow) ====================



  async function injectAndGetResponse(prompt) {
    return runLifecycle('claude:inject', buildLifecycleContext(prompt, { evaluator: isEvaluatorMode }), async (activity) => {
      const opId = metricsCollector.startOperation('injectAndGetResponse');
      const startTime = Date.now();
      try {
        console.log('[content-claude] Starting Claude injection process');
        await sleep(3000);
        
        const inputSelectors = uiDetector.getComposerSelectors();
        const sendButtonSelectors = uiDetector.getSendButtonSelectors();
        
        console.log('[content-claude] Looking for input field...');
        activity.heartbeat(0.2, { phase: 'composer-search' });
        const inputArea = await findAndCacheElement('inputField', inputSelectors);
        
        const typingSuccess = await typeWithHumanPauses(inputArea, prompt);
        activity.heartbeat(0.35, { phase: 'typing' });
        if (!typingSuccess) throw new Error('Text input failed');

        await sleep(600);
        
        console.log('[content-claude] Looking for send button...');
        activity.heartbeat(0.4, { phase: 'send-button-search' });
        const sendButton = await findAndCacheElement('sendButton', sendButtonSelectors);
        
        if (sendButton.disabled || sendButton.getAttribute('aria-disabled') === 'true') {
          const enableStart = Date.now();
          while (Date.now() - enableStart < 8000) {
            if (!sendButton.disabled && sendButton.getAttribute('aria-disabled') !== 'true') break;
            await sleep(150);
          }
        }

        const humanoid = window.Humanoid;
        console.log('[content-claude] Clicking send button');
        if (humanoid && typeof humanoid.click === 'function') {
          await humanoid.click(sendButton);
        } else {
          sendButton.focus({ preventScroll: true });
          sendButton.click();
        }
        activity.heartbeat(0.5, { phase: 'send-dispatched' });

        if ((inputArea.textContent || '').trim().length && document.contains(inputArea)) {
          console.log('[content-claude] Composer still populated after click, sending Enter key as fallback');
          inputArea.dispatchEvent(new KeyboardEvent('keydown', { key: 'Enter', code: 'Enter', bubbles: true }));
          inputArea.dispatchEvent(new KeyboardEvent('keyup', { key: 'Enter', code: 'Enter', bubbles: true }));
        }
        
        console.log('[content-claude] Message sent, waiting for response...');
        activity.heartbeat(0.6, { phase: 'waiting-response' });
        
        const response = await withSmartScroll(
          async () => await waitForClaudeResponse(120000, prompt),
          { keepAliveInterval: 2000, operationTimeout: 300000, debug: false }
        );
        
        const cleanedResponse = contentCleaner.clean(response, { maxLength: 50000 });
        
        metricsCollector.recordTiming('total_response_time', Date.now() - startTime);
        metricsCollector.endOperation(opId, true, { 
          responseLength: cleanedResponse.length,
          duration: Date.now() - startTime
        });
        activity.heartbeat(0.9, { phase: 'response-processed' });
        activity.stop({ status: 'success', answerLength: cleanedResponse.length });
        console.log(`[content-claude] Process completed. Response length: ${cleanedResponse.length}`);
        return cleanedResponse;
      } catch (error) {
        if (error?.code === 'background-force-stop') {
          activity.error(error, false);
          throw error;
        }
        console.error('[content-claude] Error in injectAndGetResponse:', error);
        metricsCollector.recordError(error, 'injectAndGetResponse', opId);
        metricsCollector.endOperation(opId, false, { error: error?.message });
        activity.error(error, true);
        throw error;
      }
    });
  }

  // ==================== Basic Heartbeat (disabled: event-driven anti-sleep only) ====================
  function startBasicHeartbeat() {
    // intentionally no-op
    return;
  }
  // автозапуск отключен

  let isEvaluatorMode = false;

  // ==================== Message Bus (PRESERVED Claude protocol) ====================
  const onRuntimeMessage = (message, sender, sendResponse) => {
    try {
      if (!message) return false;
      if (message?.type === 'STOP_AND_CLEANUP') {
        handleForceStopMessage(message.payload?.traceId);
        stopContentScript('manual-toggle');
        if (typeof sendResponse === 'function') {
          sendResponse({ status: 'cleaned', llmName: MODEL });
        }
        return false;
      }
      if (message?.type === 'HUMANOID_FORCE_STOP') {
        handleForceStopMessage(message.payload?.traceId);
        if (typeof sendResponse === 'function') {
          sendResponse({ status: 'force_stop_ack' });
        }
        return false;
      }

      if (message?.type === 'HEALTH_CHECK_PING') {
        sendResponse({ type: 'HEALTH_CHECK_PONG', pingId: message.pingId, llmName: MODEL });
        return true;
      }

      if (message?.type === 'ANTI_SLEEP_PING') {
        if (isUserInteracting()) {
          stopDriftFallback();
          return false;
        }
        runAntiSleepPulse(message.intensity || 'soft');
        return false;
      }

      if (message?.type === 'GET_ANSWER' || message?.type === 'GET_FINAL_ANSWER') {
        isEvaluatorMode = Boolean(message.isEvaluator);
        injectAndGetResponse(message.prompt)
          .then((resp) => {
            if (message.isFireAndForget) {
              sendResponse({ status: 'success_fire_and_forget' });
              return;
            }
            
            const responseType = message.type === 'GET_ANSWER' ? 'LLM_RESPONSE' : 'FINAL_LLM_RESPONSE';
            const stats = contentCleaner.getStats();
            
            if (!isEvaluatorMode) {
              chrome.runtime.sendMessage({ 
                type: 'CONTENT_CLEANING_STATS', 
                llmName: MODEL, 
                stats, 
                timestamp: Date.now() 
              });
            }

            if (isEvaluatorMode) {
              chrome.runtime.sendMessage({
                type: 'EVALUATOR_RESPONSE',
                answer: resp
              });
            } else {
              chrome.runtime.sendMessage({ 
                type: responseType, 
                llmName: MODEL, 
                answer: resp 
              });
            }
            
            sendResponse({ status: 'success' });
          })
          .catch((err) => {
            if (err?.code === 'background-force-stop') {
              sendResponse({ status: 'force_stopped' });
              return;
            }
            const errorMessage = err?.message || String(err) || 'Unknown error in content-claude';
            const responseType = message.type === 'GET_ANSWER' ? 'LLM_RESPONSE' : 'FINAL_LLM_RESPONSE';
            
            if (isEvaluatorMode) {
              chrome.runtime.sendMessage({
                type: 'EVALUATOR_RESPONSE',
                answer: `Error: ${errorMessage}`
              });
            } else {
              chrome.runtime.sendMessage({
                type: responseType,
                llmName: MODEL,
                answer: `Error: ${errorMessage}`,
                error: { 
                  type: err?.type || 'generic_error', 
                  message: errorMessage 
                }
              });
            }
            
            sendResponse({ status: 'error', message: errorMessage });
          });
        return true;
      }
    } catch (e) {
      console.error('[content-claude] listener error:', e);
      metricsCollector.recordError(e, 'messageListener');
    }
    return false;
  };
  chrome.runtime.onMessage.addListener(onRuntimeMessage);
  cleanupScope.register?.(() => {
    try {
      chrome.runtime.onMessage.removeListener(onRuntimeMessage);
    } catch (_) {}
  });

  // ==================== Export for Internal Use ====================
  window.__claudeEnhanced = {
    injectAndGetResponse,
    contentCleaner,
    metricsCollector,
    uiDetector
  };

  console.log('[content-claude] Enhanced initialization complete');
})();
