// Auto-generated by scripts/build-bundles.js @ 2025-12-02T17:36:09.122Z
(function () {
  const globalObject = typeof window !== 'undefined' ? window : self;
  globalObject.SelectorConfigRegistry = globalObject.SelectorConfigRegistry || {};
  if (globalObject.SelectorConfigRegistry.Gemini) return;

  globalObject.SelectorConfigRegistry.Gemini = {
    versions: [],
    emergencyFallbacks: {
      composer: [
        'textarea[aria-label*="Prompt"]',
        'textarea',
        'div[role="textbox"]',
        '[contenteditable="true"]'
      ],
      sendButton: [
        'button[aria-label*="Send"]',
        'button[data-mdc-dialog-action="submit"]',
        'button[type="submit"]'
      ],
      response: [
        'main [data-mdc-dialog-action]',
        'main section',
        'article',
        'main'
      ]
    },
    observationDefaults: {
      rootSelector: 'main',
      targetSelectors: [
        'main article',
        'main section',
        '.prose',
        '.markdown'
      ],
      stabilizationDelayMs: 1800,
      endGenerationMarkers: [
        { selector: '[aria-live="polite"] .progress', type: 'disappear' }
      ]
    }
  };
})();

;
//-- Защита от дублирования, адаптированная из Claude --//
const resolveExtensionVersion = () => {
    try {
        return chrome?.runtime?.getManifest?.()?.version || 'unknown';
    } catch (_) {
        return 'unknown';
    }
};
if (window.geminiContentScriptLoaded) {
    console.warn('[content-gemini] Script already loaded, skipping duplicate initialization');
    throw new Error('Duplicate script load prevented');
}
window.geminiContentScriptLoaded = {
    timestamp: Date.now(),
    version: resolveExtensionVersion(),
    source: 'content-gemini'
};
console.log('[content-gemini] First load, initializing...');
//-- Конец защиты --//

const MODEL = "Gemini";

window.setupHumanoidFetchMonitor?.(MODEL, ({ status, retryAfter }) => {
    if (status !== 429) return;
    const waitTime = retryAfter ? parseInt(retryAfter, 10) * 1000 || 60000 : 60000;
    chrome.runtime.sendMessage({
        type: 'LLM_RESPONSE',
        llmName: MODEL,
        answer: 'Error: Rate limit detected. Please wait.',
        error: {
            type: 'rate_limit',
            message: `HTTP 429 detected. Suggested wait time: ${waitTime}ms`,
            waitTime
        }
    });
});
const getLifecycleMode = () => {
  if (typeof window !== 'undefined') {
    if (window.__humanoidActivityMode) return window.__humanoidActivityMode;
    if (document?.visibilityState === 'hidden') return 'background';
  }
  return 'interactive';
};
const buildLifecycleContext = (prompt = '', extra = {}) => ({
  promptLength: prompt?.length || 0,
  evaluator: Boolean(extra.evaluator),
  mode: extra.mode || getLifecycleMode()
});
const getHumanoid = () => (typeof window !== 'undefined' ? window.Humanoid : null);
const isUserInteracting = () => {
  if (document.hidden) return true;
  const el = document.activeElement;
  if (!el) return false;
  const tag = el.tagName;
  return tag === 'INPUT' || tag === 'TEXTAREA' || el.isContentEditable;
};
const keepAliveMutex = (() => {
  const key = '__keepAliveMutex';
  if (window[key]) return window[key];
  let locked = false;
  const queue = [];
  const run = async (fn) => {
    if (locked) await new Promise((res) => queue.push(res));
    locked = true;
    try { return await fn(); } finally {
      locked = false;
      const next = queue.shift();
      if (next) next();
    }
  };
  const mutex = { run };
  window[key] = mutex;
  return mutex;
})();

const runLifecycle = (source, context, executor) => {
  if (typeof window.withHumanoidActivity === 'function') {
    return window.withHumanoidActivity(source, context, executor);
  }
  return executor({
    traceId: null,
    heartbeat: () => {},
    stop: () => {},
    error: () => {}
  });
};

const pipelineExpectedLength = (text = '') => {
  const len = (text || '').length;
  if (len > 4000) return 'veryLong';
  if (len > 2000) return 'long';
  if (len > 800) return 'medium';
  return 'short';
};

const getForceStopRegistry = () => {
  if (window.__humanoidForceStopRegistry) {
    return window.__humanoidForceStopRegistry;
  }
  const handlers = new Set();
  window.__humanoidForceStopRegistry = {
    register(handler) {
      if (typeof handler !== 'function') return () => {};
      handlers.add(handler);
      return () => handlers.delete(handler);
    },
    run(reason) {
      handlers.forEach((fn) => {
        try { fn(reason); } catch (_) {}
      });
    }
  };
  return window.__humanoidForceStopRegistry;
};
const registerForceStopHandler = (handler) => getForceStopRegistry().register(handler);
const handleForceStopMessage = (traceId) => {
  if (traceId && window.HumanoidEvents?.stop) {
    try {
      window.HumanoidEvents.stop(traceId, { status: 'forced', reason: 'background-force-stop' });
    } catch (_) {}
  }
  getForceStopRegistry().run('background-force-stop');
};

const cleanupScope = window.HumanoidCleanup?.createScope?.(`${MODEL.toLowerCase()}-content`) || {
  trackInterval: (id) => id,
  trackTimeout: (id) => id,
  trackObserver: (observer) => observer,
  trackAbortController: (controller) => controller,
  register: () => () => {},
  addEventListener: () => () => {},
  cleanup: () => {},
  isCleaned: () => false,
  getReason: () => null
};
let scriptStopped = false;
const stopContentScript = (reason = 'manual-stop') => {
  if (scriptStopped) return cleanupScope.getReason?.() || reason;
  scriptStopped = true;
  console.warn('[content-gemini] Cleanup triggered:', reason);
  try {
    getForceStopRegistry().run(reason);
  } catch (_) {}
  try {
    cleanupScope.cleanup?.(reason);
  } catch (err) {
    console.warn('[content-gemini] Cleanup scope failed', err);
  }
  try {
    window.geminiContentScriptLoaded = null;
  } catch (_) {}
  return reason;
};
window.__cleanup_gemini = stopContentScript;
cleanupScope.addEventListener?.(window, 'pagehide', () => stopContentScript('pagehide'));
cleanupScope.addEventListener?.(window, 'beforeunload', () => stopContentScript('beforeunload'));

async function tryGeminiPipeline(promptText = '', lifecycle = {}) {
  const { heartbeat, stop } = lifecycle || {};
  if (!window.UnifiedAnswerPipeline) return null;
  heartbeat?.({
    stage: 'start',
    expectedLength: pipelineExpectedLength(promptText),
    pipeline: 'UnifiedAnswerPipeline'
  });
  try {
    const pipeline = new window.UnifiedAnswerPipeline('gemini', {
      expectedLength: pipelineExpectedLength(promptText)
    });
    const result = await pipeline.execute();
    if (result?.success && result.answer) {
      heartbeat?.({
        stage: 'success',
        answerLength: result.answer.length,
        pipeline: 'UnifiedAnswerPipeline'
      });
      if (typeof stop === 'function') {
        await stop({
          status: 'success',
          source: 'pipeline',
          answer: result.answer,
          answerLength: result.answer.length,
          metadata: result.metadata
        });
      }
      return result;
    }
    heartbeat?.({
      stage: 'empty',
      status: 'no-answer',
      pipeline: 'UnifiedAnswerPipeline'
    });
  } catch (err) {
    heartbeat?.({
      stage: 'error',
      error: err?.message || String(err),
      pipeline: 'UnifiedAnswerPipeline'
    });
    console.warn('[content-gemini] UnifiedAnswerPipeline failed, using legacy watcher', err);
  }
  return null;
}

async function geminiHumanRead(duration = 500) {
  const humanoid = getHumanoid();
  if (humanoid?.readPage) {
    try {
      await humanoid.readPage(duration);
    } catch (err) {
      console.warn('[content-gemini] Humanoid.readPage failed', err);
    }
  }
}

async function geminiHumanClick(element) {
  const humanoid = getHumanoid();
  if (!element) return;
  if (humanoid?.click) {
    try {
      await humanoid.click(element);
      return;
    } catch (err) {
      console.warn('[content-gemini] Humanoid.click failed', err);
    }
  }
  element.click();
}

const geminiScrollCoordinator = window.ScrollCoordinator
  ? new window.ScrollCoordinator({
      source: `${MODEL.toLowerCase()}-smart-scroll`,
      getLifecycleMode,
      registerForceStopHandler,
      startDrift: () => startDriftFallback('soft'),
      stopDrift: () => stopDriftFallback(),
      logPrefix: `[${MODEL}] SmartScroll`
    })
  : null;

async function withSmartScroll(asyncOperation, options = {}) {
  if (geminiScrollCoordinator) {
    return geminiScrollCoordinator.run(asyncOperation, options);
  }
  return asyncOperation();
}
function setContentEditableParagraphs(element, text) {
  if (!element) return;
  const doc = element.ownerDocument || document;
  while (element.firstChild) {
    element.removeChild(element.firstChild);
  }
  const lines = String(text).split(/\n/);
  if (lines.length === 0) {
    const p = doc.createElement('p');
    p.textContent = '\u200B';
    element.appendChild(p);
    return;
  }
  lines.forEach(line => {
    const paragraph = doc.createElement('p');
    paragraph.textContent = line || '\u200B';
    element.appendChild(paragraph);
  });
}

async function fallbackTypeGemini(element, text) {
  try {
    element.focus({ preventScroll: true });
  } catch (_) {
    element.focus?.();
  }
  await sleep(350);
  setContentEditableParagraphs(element, text);
  element.dispatchEvent(new InputEvent('input', { bubbles: true, inputType: 'insertText', data: text }));
  await sleep(180);
}

async function geminiHumanType(element, text, options = {}) {
  const humanoid = getHumanoid();
  if (humanoid?.typeText) {
    try {
      await humanoid.typeText(element, text, options);
      return;
    } catch (err) {
      console.warn('[content-gemini] Humanoid.typeText failed', err);
    }
  }
  await fallbackTypeGemini(element, text);
}

const startDriftFallback = (intensity = 'soft') => {
  const humanoid = getHumanoid();
  if (humanoid?.startAntiSleepDrift) {
    humanoid.startAntiSleepDrift(intensity);
    return;
  }
  window.scrollBy({ top: (Math.random() > 0.5 ? 1 : -1) * (intensity === 'hard' ? 24 : 12), behavior: 'auto' });
};

const stopDriftFallback = () => {
  const humanoid = getHumanoid();
  humanoid?.stopAntiSleepDrift?.();
};

const createKeepAliveHeartbeat = (source) => {
  let traceId = null;
  let cleanupTimer = null;
  return (meta = {}) => {
    const lifecycle = window.HumanoidEvents;
    if (!lifecycle?.start) return;
    if (!traceId) {
      try {
        traceId = lifecycle.start(source, { mode: 'anti-sleep', source });
      } catch (err) {
        console.warn(`[${source}] keepalive trace failed`, err);
        return;
      }
    }
    try {
      lifecycle.heartbeat(traceId, meta.progress || 0, Object.assign({ phase: 'keepalive-pulse' }, meta));
    } catch (err) {
      console.warn(`[${source}] keepalive heartbeat failed`, err);
    }
    if (cleanupTimer) clearTimeout(cleanupTimer);
    cleanupTimer = setTimeout(() => {
      try { lifecycle.stop(traceId, { status: 'idle' }); } catch (_) {}
      traceId = null;
    }, 8000);
  };
};
const emitKeepAliveHeartbeat = createKeepAliveHeartbeat(`${MODEL.toLowerCase()}:keepalive`);

const runAntiSleepPulse = (intensity = 'soft') => {
  emitKeepAliveHeartbeat({ action: 'keep-alive-ping', intensity, model: MODEL });
  const delta = intensity === 'hard' ? 28 : intensity === 'medium' ? 16 : 8;
  try {
    const Toolkit = window.__UniversalScrollToolkit;
    if (Toolkit) {
      const tk = new Toolkit({ idleThreshold: 800, driftStepMs: 40 });
      tk.keepAliveTick?.((Math.random() > 0.5 ? 1 : -1) * delta);
      return;
    }
  } catch (_) {}
  startDriftFallback(intensity);
};

//-- V3.0 START: Advanced Content Cleaning System (перенесено из Claude) --//
class ContentCleaner {
    constructor() {
        this.cleaningRules = this.initializeCleaningRules();
        this.cleaningStats = { elementsRemoved: 0, charactersRemoved: 0, rulesApplied: 0 };
    }

    initializeCleaningRules() {
        return {
            // UI-элементы и фразы интерфейса
            uiPhrases: [
                /\b(Send|Menu|Settings|New chat|Clear|Like|Reply|Copy|Share|Follow|Subscribe)\b/gi,
                /\b(Upload|Download|Save|Delete|Edit|Search|Filter|Sort)\b/gi,
                /\b(Gemini|Google)\b/gi // Адаптировано для Gemini
            ],
            // Временные метки и даты
            timePatterns: [
                /\b\d{1,2}:\d{2}\s*(?:AM|PM)?\b/gi,
                /\b\d+\s*(?:hours?|minutes?|seconds?)\s*ago\b/gi,
                /\b(?:Just now|Yesterday|Today|Tomorrow)\b/gi
            ],
            // Символы форматирования
            formattingSymbols: [
                /\xa0/g, /&nbsp;/g, /&[a-z]+;/gi
            ],
            // URL
            urlPatterns: [
                /\bhttps?:\/\/[^\s<>"]+?\b/gi, /\bwww\.[^\s<>"]+?\b/gi
            ]
        };
    }

    cleanContent(content, options = {}) {
        const startTime = Date.now();
        this.cleaningStats = { elementsRemoved: 0, charactersRemoved: 0, rulesApplied: 0 };
        console.log('[ContentCleaner] Starting content cleaning, initial length:', content.length);

        let textContent = content;
        if (/<\/?[a-z][\s\S]*>/i.test(content)) {
            try {
                const parser = new DOMParser();
                const doc = parser.parseFromString(content, 'text/html');
                doc.querySelectorAll('script,style,svg,canvas,noscript,header,footer,nav,aside,[aria-hidden="true"]').forEach(el => el.remove());
                textContent = doc.body?.textContent || '';
            } catch (err) {
                console.warn('[ContentCleaner] DOMParser failed in Gemini cleaner, using text fallback', err);
                const fallbackDiv = document.createElement('div');
                fallbackDiv.textContent = content;
                textContent = fallbackDiv.textContent || '';
            }
        }

        let cleanedContent = this.cleanTextContent(textContent, options);

        if (options.maxLength && cleanedContent.length > options.maxLength) {
            cleanedContent = this.applyLengthLimit(cleanedContent, options.maxLength);
        }

        const processingTime = Date.now() - startTime;
        console.log(`[ContentCleaner] Cleaning completed in ${processingTime}ms. Final length: ${cleanedContent.length}`);
        return cleanedContent;
    }

    cleanTextContent(textContent, options) {
        let cleanedText = textContent;
        const allRules = [
            ...this.cleaningRules.uiPhrases,
            ...this.cleaningRules.timePatterns,
            ...this.cleaningRules.urlPatterns,
            ...this.cleaningRules.formattingSymbols
        ];
        
        allRules.forEach(pattern => {
            const originalLength = cleanedText.length;
            cleanedText = cleanedText.replace(pattern, ' ');
            this.recordRemoval(originalLength - cleanedText.length);
        });

        return this.finalNormalization(cleanedText);
    }

    recordRemoval(charactersRemoved) {
        if (charactersRemoved > 0) {
            this.cleaningStats.charactersRemoved += charactersRemoved;
            this.cleaningStats.rulesApplied++;
        }
    }

    applyLengthLimit(content, maxLength) {
        if (content.length <= maxLength) return content;
        const truncated = content.substring(0, maxLength);
        const lastSentenceEnd = Math.max(
            truncated.lastIndexOf('. '), truncated.lastIndexOf('! '),
            truncated.lastIndexOf('? '), truncated.lastIndexOf('\n\n')
        );
        if (lastSentenceEnd > maxLength * 0.7) {
            return truncated.substring(0, lastSentenceEnd + 1) + '\n\n[Content truncated]';
        }
        return truncated + '\n\n[Content truncated]';
    }

    finalNormalization(text) {
        return text
            .replace(/\n\s*\n\s*\n/g, '\n\n')
            .replace(/[ \t]+/g, ' ')
            .trim();
    }

    getCleaningStats() {
        return { ...this.cleaningStats };
    }
}
window.contentCleaner = new ContentCleaner();
//-- V3.0 END: Advanced Content Cleaning System --//

const sleep = (ms) => new Promise((r) => setTimeout(r, ms));

// --- ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ (перенесено из Claude) ---
function isElementInteractable(element) {
    if (!element) return false;
    if (element.offsetParent === null) return false;
    if (element.getAttribute('disabled') !== null) return false;
    if (element.style.display === 'none') return false;
    if (element.style.visibility === 'hidden') return false;
    const rect = element.getBoundingClientRect();
    return rect.top >= 0 && rect.left >= 0 && 
           rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) && 
           rect.right <= (window.innerWidth || document.documentElement.clientWidth);
}

// --- Self-Healing Selector Logic (улучшенная версия из Claude) ---
async function findAndCacheElement(selectorKey, selectorArray, timeout = 30000) {
    const storageKey = `selector_cache_${MODEL}_${selectorKey}`;
    try {
        const result = await chrome.storage.local.get(storageKey);
        const cachedSelector = result[storageKey];
        if (cachedSelector) {
            const el = document.querySelector(cachedSelector);
            if (el && isElementInteractable(el)) {
                console.log(`[Self-Healing] Found element using cached selector for '${selectorKey}'`);
                return el;
            }
        }
    } catch (e) { console.warn('[content-gemini] Storage access failed, continuing without cache'); }

    const start = Date.now();
    while (Date.now() - start < timeout) {
        for (const selector of selectorArray) {
            try {
                const el = document.querySelector(selector);
                if (el && isElementInteractable(el)) {
                    console.log(`[Self-Healing] Found element with '${selector}'. Caching for '${selectorKey}'.`);
                    try { await chrome.storage.local.set({ [storageKey]: selector }); } catch (e) {}
                    return el;
                }
            } catch (error) { console.warn(`[content-gemini] Selector error for ${selector}:`, error); }
        }
        await sleep(1000);
    }
    throw new Error(`Element not found for '${selectorKey}' with any selector`);
}

// --- ОСНОВНАЯ ФУНКЦИЯ ОБРАБОТКИ (сохранена логика Gemini, улучшена структура) ---
async function injectAndGetResponse(prompt) {
    return runLifecycle('gemini:inject', buildLifecycleContext(prompt), async (activity) => {
        console.log('[content-gemini] Starting Gemini injection process');
        try {
        await sleep(1000);

        const inputSelectors = [
            'div.ql-editor[contenteditable="true"]',
            'rich-textarea div[contenteditable="true"]',
            'div[contenteditable="true"][role="textbox"]'
        ];
        const sendButtonSelectors = [
            'button[data-testid="send-button"]',
            'button.send-button',
            'button:has(mat-icon[svgicon="send"])', // Более специфичный для Gemini
            'button[aria-label*="Send"]'
        ];

        console.log('[content-gemini] Looking for input field...');
        activity.heartbeat(0.2, { phase: 'composer-search' });
        const inputField = await findAndCacheElement('inputField', inputSelectors)
            .catch(err => { throw { type: 'selector_not_found', message: 'Gemini input field not found' }; });
        
        console.log('[content-gemini] Input field found. Injecting prompt...');
        await geminiHumanRead(600);
        await geminiHumanType(inputField, prompt, { wpm: 115 });
        activity.heartbeat(0.4, { phase: 'typing' });

        await sleep(1500); // Даем время кнопке активироваться

        console.log('[content-gemini] Looking for send button...');
        activity.heartbeat(0.55, { phase: 'send-button-search' });
        const sendButton = await findAndCacheElement('sendButton', sendButtonSelectors)
            .catch(err => { throw { type: 'selector_not_found', message: 'Gemini send button not found' }; });
        
        console.log('[content-gemini] Clicking send button');
        await geminiHumanClick(sendButton);
        activity.heartbeat(0.6, { phase: 'send-dispatched' });

        console.log('[content-gemini] Message sent, waiting for response...');
        activity.heartbeat(0.7, { phase: 'waiting-response' });

        let pipelineAnswer = null;
        await tryGeminiPipeline(prompt, {
            heartbeat: (meta = {}) => activity.heartbeat(0.85, Object.assign({ phase: 'pipeline' }, meta)),
            stop: async ({ answer, metadata }) => {
                console.log('[content-gemini] UnifiedAnswerPipeline captured response, skipping legacy wait', metadata || {});
                const cleanedResponse = window.contentCleaner.cleanContent(answer, {
                    maxLength: 50000
                });
                pipelineAnswer = cleanedResponse;
                activity.stop({ status: 'success', answerLength: cleanedResponse.length, source: 'pipeline' });
                return cleanedResponse;
            }
        });
        if (pipelineAnswer) {
            return pipelineAnswer;
        }
        const response = await withSmartScroll(() => waitForResponse(120000), {
            keepAliveInterval: 2000,
            operationTimeout: 300000,
            debug: false
        });

        // Очистка ответа с помощью нового модуля
        const cleanedResponse = window.contentCleaner.cleanContent(response, {
            maxLength: 50000
        });

        console.log(`[content-gemini] Process completed. Response length: ${cleanedResponse.length}`);
        activity.heartbeat(0.95, { phase: 'response-processed' });
        activity.stop({ status: 'success', answerLength: cleanedResponse.length });
        return cleanedResponse;
        } catch (error) {
        if (error?.code === 'background-force-stop') {
            activity.error(error, false);
            throw error;
        }
        activity.error(error, true);
        throw error;
      }
    });
}

// --- ОЖИДАНИЕ ОТВЕТА (логика сохранена, т.к. специфична для Gemini) ---
async function waitForResponse(timeout = 120000) {
    const responseSelectors = [
        '.model-response-text',
        '[data-testid="model-response-text"]',
        '.markdown'
    ];
    const generatingSelector = '.loading-animation, .typing-indicator, [class*="generating"], .response-loader, [data-testid="generation-in-progress"]';

    const readSnapshot = () => {
        let nodes = [];
        for (const sel of responseSelectors) {
            try {
                nodes = document.querySelectorAll(sel);
                if (nodes.length) break;
            } catch (_) {}
        }
        if (!nodes.length) return null;
        const last = nodes[nodes.length - 1];
        const text = last.innerHTML?.trim();
        if (!text) return null;
        const isGenerating = Boolean(document.querySelector(generatingSelector));
        return { text, isGenerating };
    };

    return new Promise((resolve, reject) => {
        let lastText = '';
        let stableCount = 0;
        let settled = false;
        const observer = cleanupScope.trackObserver(new MutationObserver(() => evaluate()));
        const intervalId = cleanupScope.trackInterval(setInterval(() => evaluate(), 1200));
        const timerId = cleanupScope.trackTimeout(setTimeout(() => {
            if (settled) return;
            settled = true;
            observer.disconnect();
            clearInterval(intervalId);
            if (lastText) {
                console.warn('[content-gemini] Timeout reached, returning last captured text.');
                resolve(lastText);
            } else {
                reject(new Error('Timeout: No response received from Gemini'));
            }
        }, timeout));

        const cleanup = (value) => {
            if (settled) return;
            settled = true;
            observer.disconnect();
            clearInterval(intervalId);
            clearTimeout(timerId);
            resolve(value);
        };

        const evaluate = () => {
            const snapshot = readSnapshot();
            if (!snapshot) return;
            const { text, isGenerating } = snapshot;
            if (isGenerating) {
                lastText = text;
                stableCount = 0;
                return;
            }
            if (!lastText) lastText = text;
            if (text === lastText) {
                stableCount += 1;
                if (stableCount >= 2) {
                    console.log('[content-gemini] Response stabilized.');
                    cleanup(text);
                }
            } else {
                lastText = text;
                stableCount = 0;
            }
        };

        observer.observe(document.body, { childList: true, subtree: true, characterData: true });
        evaluate();
    });
}

// --- ОБРАБОТЧИК СООБЩЕНИЙ (улучшенная версия из Claude) ---
const onRuntimeMessage = (message, sender, sendResponse) => {
    if (!message) return false;
    console.log('[content-gemini] Received:', message.type);
    
    if (message?.type === 'STOP_AND_CLEANUP') {
        handleForceStopMessage(message.payload?.traceId);
        stopContentScript('manual-toggle');
        if (typeof sendResponse === 'function') {
            sendResponse({ status: 'cleaned', llmName: MODEL });
        }
        return false;
    }
    
    if (message?.type === 'HUMANOID_FORCE_STOP') {
        handleForceStopMessage(message.payload?.traceId);
        if (typeof sendResponse === 'function') {
            sendResponse({ status: 'force_stop_ack' });
        }
        return false;
    }
    
    if (message?.type === 'HEALTH_CHECK_PING') {
        sendResponse({ type: 'HEALTH_CHECK_PONG', pingId: message.pingId, llmName: MODEL });
        return true;
    }
    
    if (message?.type === 'ANTI_SLEEP_PING') {
        if (isUserInteracting()) {
          stopDriftFallback();
          return false;
        }
        keepAliveMutex.run(async () => {
          runAntiSleepPulse(message.intensity || 'soft');
        });
        return false;
    }
    
    if (message?.type === 'GET_ANSWER' || message.type === 'GET_FINAL_ANSWER') {
        injectAndGetResponse(message.prompt)
            .then(result => {
                if (message.isFireAndForget) {
                    sendResponse?.({ status: 'success_fire_and_forget' });
                    return;
                }
                const responseType = message.type === 'GET_ANSWER' ? 'LLM_RESPONSE' : 'FINAL_LLM_RESPONSE';
                
                const stats = window.contentCleaner.getCleaningStats();
                chrome.runtime.sendMessage({
                    type: 'CONTENT_CLEANING_STATS', llmName: MODEL, stats: stats, timestamp: Date.now()
                });
                
                chrome.runtime.sendMessage({ type: responseType, llmName: MODEL, answer: result });
                sendResponse?.({ status: 'success' });
            })
            .catch(error => {
                if (error?.code === 'background-force-stop') {
                    sendResponse?.({ status: 'force_stopped' });
                    return;
                }
                const errorMessage = error.message || 'Unknown error in Gemini content script';
                const responseType = message.type === 'GET_ANSWER' ? 'LLM_RESPONSE' : 'FINAL_LLM_RESPONSE';
                
                chrome.runtime.sendMessage({
                    type: responseType, llmName: MODEL, answer: `Error: ${errorMessage}`,
                    error: { type: error.type || 'generic_error', message: errorMessage }
                });
                sendResponse?.({ status: 'error', message: errorMessage });
            });
        return true; // Важно для асинхронной обработки
    }
    
    return false;
};
chrome.runtime.onMessage.addListener(onRuntimeMessage);
cleanupScope.register?.(() => {
    try {
        chrome.runtime.onMessage.removeListener(onRuntimeMessage);
    } catch (_) {}
});


// --- БАЗОВЫЙ HEARTBEAT ОТКЛЮЧЕН: используем только event-driven anti-sleep ---
function startBasicHeartbeat() { return; }

console.log('[content-gemini] Initialization complete');
