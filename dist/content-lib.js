// Auto-generated by scripts/build-bundles.js @ 2025-12-02T17:36:09.107Z
// Initializes global namespace, feature flags, and lightweight telemetry stub for content scripts.
(function() {
  'use strict';

  const globalNS = (typeof window !== 'undefined' ? window : globalThis);
  globalNS.LLMExtension = globalNS.LLMExtension || {};

  const defaultFlags = {
    buildVersion: 'dev',
    selectorV2: false,
    extractorV2: false,
    humanoidV2: false,
    adaptersV2: {} // per-platform overrides, e.g. { chatgpt: true }
  };

  // Merge existing flags with defaults
  globalNS.LLMExtension.flags = Object.assign({}, defaultFlags, globalNS.LLMExtension.flags || {});

  // Minimal telemetry stub in content scripts; background owns durable storage.
  const telemetry = globalNS.LLMExtension.telemetry || {
    record(metric, value, meta = {}) {
      try {
        console.debug('[telemetry:cs]', metric, value, meta);
      } catch (_) {}
    }
  };
  globalNS.LLMExtension.telemetry = telemetry;

})();

;
(function () {
  const globalObject = typeof window !== 'undefined' ? window : self;
  if (globalObject.SelectorManagerStrategies) return;

  const wrapResult = (element, confidence) => {
    if (!element || !(element instanceof Element)) return null;
    return { element, confidence };
  };

  const getTextContent = (node) => (node?.innerText || node?.textContent || '').trim();

  const findTextualDescendant = (root) => {
    if (!root || !(root instanceof Element)) return null;
    const preferred = root.querySelector?.('article, [data-testid*="answer"], .prose');
    if (preferred) {
      const text = getTextContent(preferred);
      if (text.length > 0) return preferred;
    }
    return getTextContent(root).length > 0 ? root : null;
  };

  globalObject.SelectorManagerStrategies = {
    composer: [
      () => {
        const candidates = Array.from(document.querySelectorAll('textarea, textarea[placeholder], textarea[data-testid], textarea[data-qa]'));
        const element = candidates.find((el) => {
          const placeholder = (el.getAttribute('placeholder') || '').toLowerCase();
          const ariaLabel = (el.getAttribute('aria-label') || '').toLowerCase();
          const rect = el.getBoundingClientRect?.();
          const sizeOk = rect && rect.width >= 200 && rect.height >= 40;
          const matchesPlaceholder = /\b(ask|type|message|prompt|question)\b/.test(`${placeholder} ${ariaLabel}`);
          return el && el instanceof Element && (matchesPlaceholder || sizeOk);
        });
        return wrapResult(element, 95);
      },
      () => {
        const contentEditable = Array.from(document.querySelectorAll('div[contenteditable="true"], [role="textbox"]'));
        const element = contentEditable.find((el) => {
          const rect = el.getBoundingClientRect?.();
          const sizeOk = rect && rect.width >= 200 && rect.height >= 40;
          const parent = el.closest('[class*="composer"], [class*="input"], [data-testid*="composer"]');
          return el && el instanceof Element && (sizeOk || parent);
        });
        return wrapResult(element, 85);
      },
      () => {
        const forms = Array.from(document.querySelectorAll('form, section, main'));
        for (const form of forms) {
          const candidate = form.querySelector('div[contenteditable="true"], textarea, [role="textbox"]');
          if (candidate && candidate instanceof Element) {
            return wrapResult(candidate, 78);
          }
        }
        return null;
      }
    ],
    sendButton: [
      (reference) => {
        const container = reference?.closest?.('form, div, section') || document;
        const candidate = container.querySelector?.('button[aria-label*="send" i], button[aria-label*="submit" i]');
        return wrapResult(candidate, 90);
      },
      (reference) => {
        const searchScope = reference?.parentElement || document;
        const buttons = Array.from(searchScope.querySelectorAll('button, div[role="button"], span[role="button"]'));
        const element = buttons.find((btn) => {
          const label = (btn.getAttribute('aria-label') || btn.innerText || '').toLowerCase();
          const hasSvg = !!btn.querySelector('svg');
          const rect = btn.getBoundingClientRect?.();
          const isPositionedRight = reference && rect && reference.getBoundingClientRect && rect.left >= reference.getBoundingClientRect().right - 10;
          return btn && btn instanceof Element && (/\b(send|post|submit|ответ)\b/.test(label) || hasSvg || isPositionedRight);
        });
        const confidence = element ? (/\b(send|post|submit|ответ)\b/.test((element.getAttribute('aria-label') || element.innerText || '').toLowerCase()) ? 85 : 75) : 0;
        return wrapResult(element, confidence);
      },
      (reference) => {
        if (reference) {
          const siblingButton = reference.parentElement?.querySelector?.('button[type="submit"], button[data-testid*="send"]');
          if (siblingButton && siblingButton instanceof Element) return wrapResult(siblingButton, 82);
        }
        const btn = document.querySelector('button[type="submit"], button[data-testid*="send"]');
        return wrapResult(btn, btn ? 75 : 0);
      }
    ],
    response: [
      () => {
        const roles = Array.from(document.querySelectorAll('[role="log"], [role="main"], [role="feed"]'));
        const element = roles.map(findTextualDescendant).find(Boolean);
        return wrapResult(element, element ? 85 : 0);
      },
      () => {
        const classes = Array.from(document.querySelectorAll('[class*="message"], [class*="response"], [class*="chat"], [class*="conversation"]'));
        const element = classes.map(findTextualDescendant).find(Boolean);
        return wrapResult(element, element ? 80 : 0);
      },
      () => {
        const articles = Array.from(document.querySelectorAll('article'));
        for (let i = articles.length - 1; i >= 0; i--) {
          const el = articles[i];
          const text = (el.innerText || el.textContent || '').trim();
          if (el && el instanceof Element && text.length > 0) return wrapResult(el, 60);
        }
        return null;
      }
    ]
  };
})();

;
// selector-manager.js
(function () {
  const globalObject = typeof window !== 'undefined' ? window : self;
  if (globalObject.SelectorFinder) {
    console.warn('[SelectorFinder] Duplicate load prevented');
    return;
  }

  const CACHE_PREFIX = 'selector_cache';
  const CACHE_TTL_MS = 30 * 24 * 60 * 60 * 1000; // 30 days
  const BASE_BACKOFF_MS = 200;
  const MAX_BACKOFF_MS = 5000;
  const DEFAULT_TIMEOUT_MS = 30000;
  const DEFAULT_ELEMENT_TYPES = ['composer', 'sendButton', 'response'];
  const MAX_FINGERPRINT_DEPTH = 3;

  const discoveryQueues = new Map();
  const discoveryState = new Map();
  const stats = {
    requests: 0,
    successes: 0,
    failures: 0,
    cacheHits: 0,
    cacheMisses: 0,
    autoDiscoveryRuns: 0,
    versionedHits: 0
  };

  let lastCleanupRun = 0;

  const cssEscape = (typeof CSS !== 'undefined' && typeof CSS.escape === 'function')
    ? CSS.escape
    : ((value) => value.replace(/([ #;?%&,.+*~\':"!^$[\]()=>|\/@])/g, '\\$1'));

  const isLayoutlessEnvironment = (() => {
    if (typeof navigator === 'undefined') return false;
    const ua = navigator.userAgent || '';
    return /\bjsdom\b/i.test(ua) || /\bnode\b/i.test(ua);
  })();

  let debugFlag = false;
  let debugStylesInjected = false;
  const debugHighlights = new Set();
  const MIN_AUTODISCOVERY_CONFIDENCE = 75;

  const isDebugEnabled = () => {
    if (typeof globalObject.LLM_DEBUG !== 'undefined') {
      return !!globalObject.LLM_DEBUG;
    }
    return debugFlag;
  };

  const injectDebugStyles = () => {
    if (debugStylesInjected || typeof document === 'undefined') return;
    try {
      const style = document.createElement('style');
      style.id = 'selector-finder-debug-style';
      style.textContent = `
        .selector-finder__debug-highlight {
          outline: 2px solid #ff3366 !important;
          outline-offset: 2px !important;
          transition: outline 0.2s ease-in-out;
        }
      `;
      document.head?.appendChild(style);
      debugStylesInjected = true;
    } catch (err) {
      console.warn('[SelectorFinder] Failed to inject debug styles', err);
    }
  };

  const debugTrace = (model, elementType, message, extra) => {
    if (!isDebugEnabled()) return;
    const payload = extra !== undefined ? extra : '';
    console.debug(`[SelectorFinder][debug] ${model}/${elementType}: ${message}`, payload);
  };

  const highlightElement = (element, label) => {
    if (!isDebugEnabled() || !element || !(element instanceof Element)) return;
    injectDebugStyles();
    try {
      element.classList.add('selector-finder__debug-highlight');
      if (label) {
        element.setAttribute('data-selector-finder-highlight', label);
      }
      debugHighlights.add(element);
    } catch (err) {
      console.warn('[SelectorFinder] Failed to highlight element', err);
    }
  };

  const clearDebugHighlights = () => {
    if (!debugHighlights.size) return;
    debugHighlights.forEach((el) => {
      try {
        el.classList.remove('selector-finder__debug-highlight');
        el.removeAttribute('data-selector-finder-highlight');
      } catch (_) { /* ignore */ }
    });
    debugHighlights.clear();
  };

  const primeDebugFlag = () => {
    try {
      if (chrome?.storage?.local?.get) {
        chrome.storage.local.get({ llm_debug: false }, (res) => {
          if (chrome.runtime?.lastError) return;
          debugFlag = !!res.llm_debug;
        });
        if (chrome?.storage?.onChanged?.addListener) {
          chrome.storage.onChanged.addListener((changes, areaName) => {
            if (areaName !== 'local' || !changes.llm_debug) return;
            debugFlag = !!changes.llm_debug.newValue;
          });
        }
      }
    } catch (err) {
      console.warn('[SelectorFinder] Debug flag prime failed', err);
    }
  };
  primeDebugFlag();

  const reportResolutionLayer = (modelName, elementType, layer) => {
    if (!layer) return;
    try {
      chrome.runtime?.sendMessage({
        type: 'METRIC_EVENT',
        event: 'selector_resolution',
        modelName,
        elementType,
        layer,
        timestamp: Date.now()
      });
    } catch (err) {
      console.warn('[SelectorFinder] Failed to report resolution layer', err);
    }
  };

  const autoDiscoveryStrategies = globalObject.SelectorManagerStrategies || {};

  /**
   * Normalizes selector configuration values into a flat array while preserving intent order.
   * @param {string[]|Object|null} value - Selector definition from config.
   * @returns {string[]} Flattened selector list.
   */
  const normalizeSelectorList = (value) => {
    if (!value) return [];
    if (Array.isArray(value)) return Array.from(value);
    if (typeof value === 'object') {
      const priorityBuckets = ['primary', 'secondary', 'tertiary', 'fallback', 'all'];
      const result = [];
      for (const key of priorityBuckets) {
        if (Array.isArray(value[key])) {
          result.push(...value[key]);
        }
      }
      for (const key of Object.keys(value)) {
        if (!priorityBuckets.includes(key) && Array.isArray(value[key])) {
          result.push(...value[key]);
        }
      }
      return result;
    }
    return [];
  };

  /**
   * Logs an informational message with SelectorFinder prefix.
   * @param {string} model - Model name.
   * @param {string} type - Element type.
   * @param {string} message - Message to log.
   * @example log('Grok', 'composer', 'Cache hit');
   */
  const log = (model, type, message) => {
    console.log(`[SelectorFinder] ${model}/${type}: ${message}`);
  };

  /**
   * Logs a warning message with SelectorFinder prefix.
   * @param {string} model - Model name.
   * @param {string} type - Element type.
   * @param {string} message - Message to log.
   * @example warn('Grok', 'composer', 'Cache miss');
   */
  const warn = (model, type, message) => {
    console.warn(`[SelectorFinder] ${model}/${type}: ${message}`);
  };

  /**
   * Logs an error message with SelectorFinder prefix.
   * @param {string} model - Model name.
   * @param {string} type - Element type.
   * @param {string} message - Message to log.
   * @example error('Grok', 'composer', 'Timeout exceeded');
   */
  const error = (model, type, message) => {
    console.error(`[SelectorFinder] ${model}/${type}: ${message}`);
  };

  /**
   * Deep query that traverses shadow roots (mode: open) recursively.
   * Fast path: native querySelector on the current root.
   * Slow path: TreeWalker + shadowRoot descent.
   */
  const queryDeep = (selector, root = document) => {
    if (!selector || !root) return null;
    try {
      const direct = root.querySelector(selector);
      if (direct) return direct;
    } catch (_) {
      // ignore invalid selector here; upstream will log
    }
    const walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT, null);
    while (walker.nextNode()) {
      const node = walker.currentNode;
      if (node?.shadowRoot) {
        const found = queryDeep(selector, node.shadowRoot);
        if (found) return found;
      }
    }
    return null;
  };

  /**
   * Deep queryAll variant for shadow DOM traversal.
   */
  const queryDeepAll = (selector, root = document, results = []) => {
    if (!selector || !root) return results;
    try {
      results.push(...root.querySelectorAll(selector));
    } catch (_) {
      // ignore invalid selector here; upstream will log
    }
    const walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT, null);
    while (walker.nextNode()) {
      const node = walker.currentNode;
      if (node?.shadowRoot) {
        queryDeepAll(selector, node.shadowRoot, results);
      }
    }
    return results;
  };

  /**
   * Emits selector-related telemetry events to the background script.
   * @param {string} event - Metric identifier.
   * @param {Object} [payload={}] - Arbitrary payload data.
   * @example sendMetric('selector_cache_hit', { modelName: 'Grok' });
   */
  const sendMetric = (event, payload = {}) => {
    try {
      chrome.runtime?.sendMessage({
        type: 'SELECTOR_METRIC',
        event,
        payload,
        timestamp: Date.now()
      });
    } catch (err) {
      console.warn('[SelectorFinder] Failed to send metric', err);
    }
  };

  /**
   * Removes outdated selector cache entries older than the TTL.
   * @returns {Promise<void>} Resolves when cleanup finishes.
   * @example await cleanupExpiredCache();
   */
  const cleanupExpiredCache = async () => {
    const now = Date.now();
    if (now - lastCleanupRun < 15 * 60 * 1000) return;
    lastCleanupRun = now;
    try {
      const all = await chrome.storage.local.get(null);
      const expiredKeys = Object.entries(all)
        .filter(([key, value]) => key.startsWith(CACHE_PREFIX) && value?.timestamp && now - value.timestamp > CACHE_TTL_MS)
        .map(([key]) => key);
      if (expiredKeys.length) {
        await chrome.storage.local.remove(expiredKeys);
        console.log(`[SelectorFinder] Removed ${expiredKeys.length} expired selector cache entries`);
      }
    } catch (err) {
      console.warn('[SelectorFinder] Cache cleanup failed', err);
    }
  };

  /**
   * Builds the chrome.storage key for a selector cache entry.
   * @param {string} modelName - Friendly LLM model name.
   * @param {string} elementType - Selector type (composer, sendButton, response).
   * @returns {string} Namespaced storage key.
   * @example const key = getCacheKey('Grok', 'composer');
   */
  const getCacheKey = (modelName, elementType) => `${CACHE_PREFIX}_${modelName}_${elementType}`;

  /**
   * Reads a selector cache entry for the requested model and element type.
   * @param {string} modelName - LLM model name.
   * @param {string} elementType - Element type identifier.
   * @returns {Promise<{selector: string, timestamp: number, uiVersion?: string}|null>} Stored entry or null.
   * @example const cached = await readCache('Grok', 'composer');
   */
  const readCache = async (modelName, elementType) => {
    await cleanupExpiredCache();
    const key = getCacheKey(modelName, elementType);
    try {
      const result = await chrome.storage.local.get(key);
      const entry = result[key];
      if (!entry) {
        stats.cacheMisses += 1;
        return null;
      }
      if (entry.timestamp && Date.now() - entry.timestamp > CACHE_TTL_MS) {
        await chrome.storage.local.remove(key);
        stats.cacheMisses += 1;
        return null;
      }
      stats.cacheHits += 1;
      return entry;
    } catch (err) {
      console.warn('[SelectorFinder] Cache read failed', err);
      return null;
    }
  };

  /**
   * Persists selector metadata to chrome.storage.
   * @param {string} modelName - LLM model name.
   * @param {string} elementType - Element type identifier.
   * @param {string} selector - CSS selector string.
   * @param {Object} metadata - Additional details to store (uiVersion, method, etc).
   * @returns {Promise<boolean>} True on success, false otherwise.
   * @example await writeCache('Grok', 'composer', '#prompt', { uiVersion: 'grok-2024-q4' });
   */
  const writeCache = async (modelName, elementType, selector, metadata = {}) => {
    const key = getCacheKey(modelName, elementType);
    const payload = {
      selector,
      timestamp: Date.now(),
      ...metadata
    };
    try {
      await chrome.storage.local.set({ [key]: payload });
      return true;
    } catch (err) {
      console.warn('[SelectorFinder] Cache write failed', err);
      return false;
    }
  };

  /**
   * Clears cached selectors for a specific model namespace.
   * @param {string} modelName - LLM model name.
   * @returns {Promise<number>} Number of removed entries.
   * @example const removed = await clearCacheForModel('Grok');
   */
  const clearCacheForModel = async (modelName) => {
    try {
      const all = await chrome.storage.local.get(null);
      const keysToRemove = Object.keys(all).filter((key) => key.startsWith(`${CACHE_PREFIX}_${modelName}_`));
      if (keysToRemove.length) {
        await chrome.storage.local.remove(keysToRemove);
      }
      return keysToRemove.length;
    } catch (err) {
      console.warn('[SelectorFinder] Cache clear failed', err);
      return 0;
    }
  };

  const buildElementFingerprint = (element) => {
    if (!element || !(element instanceof Element)) return null;
    const fingerprint = [];
    let current = element;
    for (let depth = 0; current && depth < MAX_FINGERPRINT_DEPTH; depth += 1) {
      fingerprint.push({
        tag: current.tagName?.toLowerCase() || '',
        id: current.id || '',
        dataTestId: current.getAttribute?.('data-testid') || '',
        role: current.getAttribute?.('role') || '',
        ariaLabel: current.getAttribute?.('aria-label') || '',
        classes: Array.from(current.classList || []).slice(0, 3)
      });
      current = current.parentElement;
    }
    return fingerprint;
  };

  const fingerprintMatchesElement = (fingerprint, element) => {
    if (!fingerprint || !fingerprint.length) return true;
    let current = element;
    for (const expected of fingerprint) {
      if (!current) return false;
      if (expected.tag && current.tagName?.toLowerCase() !== expected.tag) return false;
      if (expected.id && current.id !== expected.id) return false;
      if (expected.dataTestId && current.getAttribute?.('data-testid') !== expected.dataTestId) return false;
      if (expected.role && current.getAttribute?.('role') !== expected.role) return false;
      if (expected.ariaLabel && current.getAttribute?.('aria-label') !== expected.ariaLabel) return false;
      if (expected.classes?.length) {
        const hasAll = expected.classes.every((cls) => current.classList?.contains?.(cls));
        if (!hasAll) return false;
      }
      current = current.parentElement;
    }
    return true;
  };

  /**
   * Validates whether an element is currently interactable within the viewport.
   * @param {Element|null} element - Candidate DOM node.
   * @returns {boolean} True when the element is visible and enabled.
   * @example const ready = isElementInteractable(document.querySelector('textarea'));
   */
  const isElementInteractable = (element) => {
    if (!element) return false;
    if (element.offsetParent === null && !isLayoutlessEnvironment) return false;
    if (element.getAttribute && element.getAttribute('disabled') !== null) return false;
    const computed = window.getComputedStyle ? window.getComputedStyle(element) : element.style;
    if (!computed) return false;
    if (computed.display === 'none' || computed.visibility === 'hidden') return false;
    if (isLayoutlessEnvironment) return true;
    const rect = element.getBoundingClientRect?.();
    if (!rect) return true;
    if (rect.width <= 0 || rect.height <= 0) return false;
    const viewportWidth = window.innerWidth || document.documentElement.clientWidth;
    const viewportHeight = window.innerHeight || document.documentElement.clientHeight;
    return rect.bottom >= 0 && rect.right >= 0 && rect.top <= viewportHeight && rect.left <= viewportWidth;
  };

  /**
   * Generates a reusable CSS selector for a discovered element.
   * Prefers ids, data attributes, then class names, falling back to a structural path.
   * @param {Element|null} element - Target DOM node.
   * @returns {string|null} Selector string or null if none could be produced.
   * @example const selector = getSelectorFromElement(document.querySelector('textarea'));
   */
  const getSelectorFromElement = (element) => {
    if (!element || !element.tagName) return null;
    if (element.id) return `#${cssEscape(element.id)}`;
    const attrCandidates = ['data-testid', 'data-qa', 'data-id', 'name', 'placeholder', 'aria-label', 'role'];
    for (const attr of attrCandidates) {
      const value = element.getAttribute?.(attr);
      if (value && value.length <= 80) {
        return `${element.tagName.toLowerCase()}[${attr}="${cssEscape(value)}"]`;
      }
    }
    const classList = Array.from(element.classList || []).filter((cls) => cls && !/^\d+$/.test(cls));
    if (classList.length) {
      return `${element.tagName.toLowerCase()}.${classList.map((cls) => cssEscape(cls)).join('.')}`;
    }
    let path = element.tagName.toLowerCase();
    let parent = element.parentElement;
    while (parent) {
      const siblings = Array.from(parent.children).filter((child) => child.tagName === element.tagName);
      if (siblings.length > 1) {
        const index = siblings.indexOf(element) + 1;
        path = `${parent.tagName.toLowerCase()} > ${element.tagName.toLowerCase()}:nth-of-type(${index})`;
      } else {
        path = `${parent.tagName.toLowerCase()} > ${path}`;
      }
      if (parent.id) {
        path = `#${cssEscape(parent.id)} > ${path}`;
        break;
      }
      parent = parent.parentElement;
    }
    return path;
  };

  /**
   * Returns the element when it is interactable, otherwise null.
   * @param {Element|null} element - Candidate node.
   * @returns {Element|null} Interactable element or null.
   * @example const el = ensureValidElement(document.querySelector('button'));
   */
  const ensureValidElement = (element) => (isElementInteractable(element) ? element : null);

  const SEARCH_KEYWORDS = ['search', 'find', 'поиск', 'найти', 'buscar'];

  const elementHasSearchAffinity = (element) => {
    if (!element) return false;
    const attributeMatches = (value) => {
      if (!value) return false;
      const normalized = String(value).toLowerCase();
      return SEARCH_KEYWORDS.some((keyword) => normalized.includes(keyword));
    };
    const attributesToCheck = ['aria-label', 'placeholder', 'data-testid', 'id', 'name'];
    for (const attr of attributesToCheck) {
      if (attributeMatches(element.getAttribute?.(attr))) return true;
    }
    if (attributeMatches(element.className)) return true;
    let current = element;
    let depth = 0;
    while (current && depth < 3) {
      if (attributeMatches(current.getAttribute?.('data-testid'))) return true;
      if (attributeMatches(current.id)) return true;
      if (attributeMatches(current.className)) return true;
      current = current.parentElement;
      depth += 1;
    }
    return false;
  };

  const validateElementForType = (elementType, element, context = {}) => {
    if (!element) return false;
    const tag = element.tagName?.toUpperCase?.() || '';
    const role = element.getAttribute?.('role')?.toLowerCase?.() || '';
    if (!ensureValidElement(element)) return false;
    const { constraints } = context;
    if (constraints?.exclude?.length) {
      const isExcluded = constraints.exclude.some((selector) => {
        if (!selector) return false;
        try {
          return element.matches?.(selector) || element.closest?.(selector);
        } catch (err) {
          console.warn('[SelectorFinder] Invalid exclusion selector', selector, err);
          return false;
        }
      });
      if (isExcluded) return false;
    }

    switch (elementType) {
      case 'composer': {
        const isTextual = tag === 'TEXTAREA' ||
          element.getAttribute?.('contenteditable') === 'true' ||
          role === 'textbox';
        if (!isTextual) return false;
        if (elementHasSearchAffinity(element)) return false;
        return true;
      }
      case 'sendButton': {
        if (element.disabled) return false;
        const isButtonLike = tag === 'BUTTON' || role === 'button';
        if (!isButtonLike) return false;
        if (elementHasSearchAffinity(element)) return false;
        const { referenceElement } = context;
        if (referenceElement && referenceElement instanceof Element) {
          let sharedContainer = referenceElement.closest('form, section, article, div, main');
          let depth = 0;
          let withinSharedHierarchy = false;
          while (sharedContainer && depth < 3) {
            if (sharedContainer.contains(element)) {
              withinSharedHierarchy = true;
              break;
            }
            const nextCandidate = sharedContainer.parentElement?.closest?.('form, section, article, div, main');
            sharedContainer = nextCandidate || sharedContainer.parentElement;
            depth += 1;
          }
          if (!withinSharedHierarchy) return false;
        }
        return true;
      }
      case 'response': {
        if (tag === 'BODY' || tag === 'HTML') return false;
        if (elementHasSearchAffinity(element)) return false;
        return true;
      }
      default:
        return true;
    }
  };

  /**
   * Reads versioned selectors for the specified model from the config registry.
   * @param {string} modelName - LLM model name.
   * @param {string} elementType - Element type identifier.
   * @param {string} uiVersion - Detected UI version id or 'unknown'.
   * @returns {string[]} Selector candidates in priority order.
   * @example const selectors = gatherSelectorsFromConfig('Grok', 'composer', 'grok-2024-q4');
   */
  const gatherSelectorsFromConfig = (modelName, elementType, uiVersion) => {
    const cfg = globalObject.SelectorConfig;
    if (!cfg) return [];
    const modelConfig = cfg.getModelConfig?.(modelName) || cfg.models?.[modelName];
    if (!modelConfig) return [];
    const versionEntry = (modelConfig.versions || []).find((v) => v.version === uiVersion);
    if (versionEntry?.selectors?.[elementType]) {
      return normalizeSelectorList(versionEntry.selectors[elementType]);
    }
    const aggregate = [];
    for (const version of modelConfig.versions || []) {
      const list = normalizeSelectorList(version.selectors?.[elementType]);
      if (list.length) aggregate.push(...list);
    }
    return aggregate;
  };

  /**
   * Reads constraint metadata for the specified model/element from the config registry.
   * @param {string} modelName - LLM model name.
   * @param {string} elementType - Element type identifier.
   * @param {string} uiVersion - Detected UI version.
   * @returns {{exclude?: string[]}|null} Constraint descriptor.
   */
  const gatherConstraintsFromConfig = (modelName, elementType, uiVersion) => {
    const cfg = globalObject.SelectorConfig;
    if (!cfg?.getConstraintsFor) return null;
    const bundle = cfg.getConstraintsFor(modelName, uiVersion, elementType);
    if (bundle) return bundle;
    if (uiVersion !== 'unknown') {
      return cfg.getConstraintsFor(modelName, 'unknown', elementType);
    }
    return null;
  };

  const gatherAnchorsFromConfig = (modelName, elementType, uiVersion) => {
    const cfg = globalObject.SelectorConfig;
    if (!cfg?.getAnchorsFor) return [];
    return cfg.getAnchorsFor(modelName, uiVersion, elementType) || [];
  };

  const gatherSelectorBuckets = (modelName, elementType, uiVersion) => {
    const cfg = globalObject.SelectorConfig;
    const modelConfig = cfg?.getModelConfig?.(modelName) || cfg?.models?.[modelName];
    const buckets = { primary: [], fallback: [] };
    if (!modelConfig) return buckets;

    const mergeFrom = (value) => {
      if (!value) return;
      if (Array.isArray(value)) {
        buckets.primary.push(...value);
        return;
      }
      if (typeof value === 'object') {
        if (Array.isArray(value.primary)) buckets.primary.push(...value.primary);
        if (Array.isArray(value.fallback)) buckets.fallback.push(...value.fallback);
        for (const key of Object.keys(value)) {
          if (['primary', 'fallback', 'extraction'].includes(key)) continue;
          const arr = value[key];
          if (Array.isArray(arr)) buckets.fallback.push(...arr);
        }
      }
    };

    if (uiVersion && uiVersion !== 'unknown') {
      const versionEntry = (modelConfig.versions || []).find((v) => v.version === uiVersion);
      mergeFrom(versionEntry?.selectors?.[elementType]);
    } else {
      for (const versionEntry of modelConfig.versions || []) {
        mergeFrom(versionEntry.selectors?.[elementType]);
      }
    }

    if (!buckets.primary.length) {
      mergeFrom(modelConfig.emergencyFallbacks?.[elementType]);
    }
    if (!buckets.fallback.length) {
      mergeFrom(modelConfig.emergencyFallbacks?.[elementType]);
    }

    buckets.primary = Array.from(new Set(buckets.primary.filter(Boolean)));
    buckets.fallback = Array.from(new Set(buckets.fallback.filter(Boolean)));
    return buckets;
  };

  const gatherObservationConfig = (modelName, elementType, uiVersion) => {
    const cfg = globalObject.SelectorConfig;
    const modelConfig = cfg?.getModelConfig?.(modelName) || cfg?.models?.[modelName];
    if (!modelConfig) return null;

    const cloneObservation = (source) => {
      if (!source) return null;
      const copy = { ...source };
      if (Array.isArray(source.targetSelectors)) {
        copy.targetSelectors = Array.from(new Set(source.targetSelectors.filter(Boolean)));
      }
      if (Array.isArray(source.endGenerationMarkers)) {
        copy.endGenerationMarkers = source.endGenerationMarkers.map((marker) => ({ ...marker }));
      }
      return copy;
    };

    if (uiVersion && uiVersion !== 'unknown') {
      const versionEntry = (modelConfig.versions || []).find((v) => v.version === uiVersion);
      const observation = cloneObservation(versionEntry?.observation);
      if (observation) return observation;
    }

    for (const versionEntry of modelConfig.versions || []) {
      const observation = cloneObservation(versionEntry.observation);
      if (observation) return observation;
    }

    return cloneObservation(modelConfig.observationDefaults) || null;
  };

  const gatherExtractionStrategy = (modelName, elementType, uiVersion) => {
    const cfg = globalObject.SelectorConfig;
    const extraction = cfg?.getExtractionConfig?.(modelName, uiVersion, elementType);
    if (extraction) return { ...extraction };
    return null;
  };

  /**
   * Returns emergency fallback selectors for a given model and element type.
   * @param {string} modelName - LLM model name.
   * @param {string} elementType - Element type identifier.
   * @returns {string[]} Fallback selectors.
   * @example const fallbacks = gatherEmergencyFallbacks('Grok', 'composer');
   */
  const gatherEmergencyFallbacks = (modelName, elementType) => {
    const cfg = globalObject.SelectorConfig;
    if (!cfg) return [];
    const modelConfig = cfg.getModelConfig?.(modelName) || cfg.models?.[modelName];
    if (!modelConfig) return [];
    return Array.from(modelConfig.emergencyFallbacks?.[elementType] || []);
  };

  /**
   * Detects the active UI version for the given model using the selector config.
   * @param {string} modelName - LLM model name.
   * @returns {string} Version identifier or 'unknown'.
   * @example const version = detectUIVersion('Grok');
   */
  const detectUIVersion = (modelName) => {
    const cfg = globalObject.SelectorConfig;
    if (cfg?.detectUIVersion) {
      const version = cfg.detectUIVersion(modelName, document);
      if (version) return version;
    }
    return 'unknown';
  };

  /**
   * Attempts to resolve an element using cached selectors.
   * @param {Object} params - Parameter bag.
   * @param {string} params.modelName - LLM model name.
   * @param {string} params.elementType - Element type identifier.
   * @param {number} params.timeout - Unused currently, included for parity.
   * @param {boolean} params.forceDiscovery - Skip cache when true.
   * @returns {Promise<{selector: string, element: Element, method: string}|null>} Result object or null.
   * @example await runLayerCached({ modelName: 'Grok', elementType: 'composer', timeout: 1000, forceDiscovery: false });
   */
  const runLayerCached = async ({ modelName, elementType, timeout, forceDiscovery, referenceElement }) => {
    if (forceDiscovery) return null;
    const cached = await readCache(modelName, elementType);
    if (!cached || !cached.selector) return null;
    const element = queryDeep(cached.selector, document);
    const constraints = gatherConstraintsFromConfig(modelName, elementType, cached?.uiVersion || 'unknown');
    const fingerprintOk = fingerprintMatchesElement(cached.fingerprint, element);
    if (ensureValidElement(element) && fingerprintOk && validateElementForType(elementType, element, { referenceElement, constraints })) {
      log(modelName, elementType, `Cache hit (${cached.selector})`);
      sendMetric('selector_cache_hit', { modelName, elementType, selector: cached.selector });
      debugTrace(modelName, elementType, `Cache hit with selector ${cached.selector}`);
      highlightElement(element, `${modelName}/${elementType}: cache`);
      return { selector: cached.selector, element, method: 'cache', layer: 'cache' };
    }
    warn(modelName, elementType, `Cached selector invalid (${cached.selector})`);
    debugTrace(modelName, elementType, `Cached selector invalid (${cached.selector})`);
    try {
      await chrome.storage.local.remove(getCacheKey(modelName, elementType));
    } catch (err) {
      console.warn('[SelectorFinder] Failed to purge invalid cache entry', err);
    }
    return null;
  };

  /**
   * Iterates through selector candidates until an interactable element is found.
   * @param {string[]} selectors - Selector candidates.
   * @param {Document|Element} [scope=document] - Search scope.
   * @returns {{selector: string, element: Element}|null} Matched selector and element, or null.
   * @example const result = trySelectors(['textarea'], document);
   */
  const trySelectors = (selectors, scope = document, validateFn = () => true, context = {}) => {
    for (const selector of selectors) {
      try {
        const element = queryDeep(selector, scope);
        if (ensureValidElement(element) && validateFn(element, selector, context)) {
          return { selector, element };
        }
      } catch (err) {
        console.warn('[SelectorFinder] Invalid selector syntax', selector, err);
      }
    }
    return null;
  };

  /**
   * Uses versioned selectors defined in the configuration registry.
   * @param {Object} params - Parameter bag.
   * @param {string} params.modelName - LLM model name.
   * @param {string} params.elementType - Element type identifier.
   * @param {string} params.uiVersion - Detected UI version.
   * @returns {Promise<{selector: string, element: Element, method: string}|null>} Found element or null.
   * @example await runLayerVersioned({ modelName: 'Grok', elementType: 'composer', uiVersion: 'grok-2024-q4' });
   */
  const runLayerVersioned = async ({ modelName, elementType, uiVersion, referenceElement }) => {
    const selectors = gatherSelectorsFromConfig(modelName, elementType, uiVersion);
    if (!selectors.length) return null;
    const constraints = gatherConstraintsFromConfig(modelName, elementType, uiVersion);
    const result = trySelectors(
      selectors,
      document,
      (element) => validateElementForType(elementType, element, { referenceElement, constraints }),
      { referenceElement, constraints }
    );
    if (result) {
      stats.versionedHits += 1;
      log(modelName, elementType, `Found via version ${uiVersion}, selector: ${result.selector}`);
      sendMetric('selector_versioned_hit', { modelName, elementType, uiVersion, selector: result.selector });
      debugTrace(modelName, elementType, `Versioned selector success (${result.selector})`);
      highlightElement(result.element, `${modelName}/${elementType}: version:${uiVersion}`);
      await writeCache(modelName, elementType, result.selector, {
        uiVersion,
        method: 'versioned',
        fingerprint: buildElementFingerprint(result.element)
      });
      return { selector: result.selector, element: result.element, method: `versioned:${uiVersion}`, layer: 'versioned' };
    }
    return null;
  };

  /**
   * Executes heuristic strategies to auto-discover matching elements.
   * @param {Object} params - Parameter bag.
   * @param {string} params.modelName - LLM model name.
   * @param {string} params.elementType - Element type identifier.
   * @param {number} params.timeout - Maximum discovery duration.
   * @param {Element|null} params.referenceElement - Optional element to guide the search.
   * @returns {Promise<{selector: string, element: Element, method: string}|null>} Result or null.
   * @example await runAutoDiscovery({ modelName: 'Grok', elementType: 'composer', timeout: 30000, referenceElement: null });
   */
  const computeAnchorBoost = (element, anchors = []) => {
    if (!element || !anchors.length) return 0;
    const haystack = [
      element.textContent,
      element.getAttribute?.('aria-label'),
      element.getAttribute?.('title'),
      element.getAttribute?.('placeholder')
    ].filter(Boolean).join(' ').toLowerCase();
    if (!haystack) return 0;
    return anchors.reduce((score, anchor) => {
      if (!anchor) return score;
      return haystack.includes(anchor.toLowerCase()) ? score + 12 : score;
    }, 0);
  };

  const runAutoDiscovery = async ({ modelName, elementType, timeout, referenceElement, uiVersion }) => {
    const start = Date.now();
    stats.autoDiscoveryRuns += 1;
    let attempt = 0;
    const strategies = autoDiscoveryStrategies[elementType] || [];
    const constraints = gatherConstraintsFromConfig(modelName, elementType, uiVersion);
    const anchors = gatherAnchorsFromConfig(modelName, elementType, uiVersion);
    while (Date.now() - start < timeout) {
      for (const strategy of strategies) {
        try {
          const outcome = strategy(referenceElement);
          if (!outcome) continue;

          const element = outcome?.element instanceof Element ? outcome.element : (outcome instanceof Element ? outcome : null);
          let confidence = typeof outcome?.confidence === 'number'
            ? outcome.confidence
            : (outcome instanceof Element ? 80 : 0);
          const anchorBoost = anchors.length ? computeAnchorBoost(element, anchors) : 0;
          if (anchorBoost > 0) {
            debugTrace(modelName, elementType, `Anchor boost +${anchorBoost} for candidate`);
          }
          confidence += anchorBoost;

          if (confidence < MIN_AUTODISCOVERY_CONFIDENCE) {
            debugTrace(modelName, elementType, `Auto-discovery candidate rejected (confidence=${confidence})`);
            continue;
          }

          if (ensureValidElement(element) && validateElementForType(elementType, element, { referenceElement, constraints })) {
            const selector = getSelectorFromElement(element);
            if (selector) {
              await writeCache(modelName, elementType, selector, {
                method: 'autodiscovery',
                uiVersion: 'unknown',
                fingerprint: buildElementFingerprint(element)
              });
              log(modelName, elementType, `Auto-discovery success (${selector})`);
              sendMetric('selector_discovery_success', { modelName, elementType, selector, confidence });
              debugTrace(modelName, elementType, `Auto-discovery success (${selector}) [confidence=${confidence}]`);
              highlightElement(element, `${modelName}/${elementType}: auto-discovery`);
              return { selector, element, method: 'auto-discovery', layer: 'autodiscovery', confidence };
            }
          }
        } catch (err) {
          console.warn('[SelectorFinder] Auto-discovery strategy failed', err);
        }
      }
      attempt += 1;
      const delay = Math.min(BASE_BACKOFF_MS * Math.pow(2, attempt), MAX_BACKOFF_MS);
      await new Promise((resolve) => setTimeout(resolve, delay));
    }
    return null;
  };

  /**
   * Applies emergency fallback selectors when other layers fail.
   * @param {Object} params - Parameter bag.
   * @param {string} params.modelName - LLM model name.
   * @param {string} params.elementType - Element type identifier.
   * @returns {Promise<{selector: string, element: Element, method: string}|null>} Result or null.
   * @example await runEmergencyFallback({ modelName: 'Grok', elementType: 'composer' });
   */
  const runEmergencyFallback = async ({ modelName, elementType, referenceElement, uiVersion }) => {
    const selectors = gatherEmergencyFallbacks(modelName, elementType);
    if (!selectors.length) return null;
    const constraints = gatherConstraintsFromConfig(modelName, elementType, uiVersion);
    const result = trySelectors(
      selectors,
      document,
      (element) => validateElementForType(elementType, element, { referenceElement, constraints }),
      { referenceElement, constraints }
    );
    if (result) {
      warn(modelName, elementType, `Emergency fallback used (${result.selector})`);
      sendMetric('selector_emergency_fallback', { modelName, elementType, selector: result.selector });
      debugTrace(modelName, elementType, `Emergency fallback success (${result.selector})`);
      highlightElement(result.element, `${modelName}/${elementType}: emergency`);
      await writeCache(modelName, elementType, result.selector, {
        method: 'emergency',
        uiVersion: 'unknown',
        fingerprint: buildElementFingerprint(result.element)
      });
      return { selector: result.selector, element: result.element, method: 'emergency-fallback', layer: 'emergency' };
    }
    return null;
  };

  /**
   * Ensures selector discovery calls run sequentially per element key.
   * @param {string} key - Discovery namespace (model/element type).
   * @param {Function} executor - Async function returning a Promise with the discovery result.
   * @returns {Promise<*>} Resolves with executor result.
   * @example await withDiscoveryQueue('Grok:composer', () => Promise.resolve(null));
   */
  const withDiscoveryQueue = (key, executor) => {
    return new Promise((resolve, reject) => {
      const queue = discoveryQueues.get(key) || [];
      const runTask = () => {
        discoveryState.set(key, true);
        executor()
          .then(resolve)
          .catch(reject)
          .finally(() => {
            queue.shift();
            if (queue.length) {
              queue[0]();
            } else {
              discoveryQueues.delete(key);
              discoveryState.delete(key);
            }
          });
      };
      queue.push(runTask);
      discoveryQueues.set(key, queue);
      if (queue.length === 1) {
        runTask();
      }
    });
  };

  /**
   * Public API entry point: resolves a selector for the requested model + element type.
   * Applies Cache → Versioned → Auto-discovery → Emergency fallback layers.
   * @param {Object} [options={}] - Search options.
   * @param {string} options.modelName - LLM model name.
   * @param {string} options.elementType - Element type identifier.
   * @param {number} [options.timeout=30000] - Maximum search duration in milliseconds.
   * @param {boolean} [options.forceDiscovery=false] - Skip cache lookup when true.
   * @param {Element|null} [options.referenceElement=null] - Optional element to guide heuristics.
   * @returns {Promise<{selector: string, element: Element, method: string, duration: number}|null>} Result object or null.
   * @example const result = await SelectorFinder.findOrDetectSelector({ modelName: 'Grok', elementType: 'composer' });
   */
  const findOrDetectSelector = async (options = {}) => {
    const {
      modelName = 'Unknown',
      elementType = 'composer',
      timeout = DEFAULT_TIMEOUT_MS,
      forceDiscovery = false,
      referenceElement = null
    } = options;

    const key = `${modelName}:${elementType}`;
    stats.requests += 1;
    sendMetric('selector_search', { modelName, elementType, forceDiscovery });

    const effectiveTimeout = Number.isFinite(timeout) ? timeout : DEFAULT_TIMEOUT_MS;

    const attemptSearch = async () => {
      const start = Date.now();
      const resolutionSteps = [];
      const finalizeResult = (result, layer, extra = '') => {
        if (layer) {
          reportResolutionLayer(modelName, elementType, layer);
        }
        const pathSummary = resolutionSteps.join(' -> ');
        const detail = extra ? `${pathSummary} (${extra})` : pathSummary;
        if (pathSummary) {
          debugTrace(modelName, elementType, `Resolution path: ${detail}`);
        }
        return { ...result, duration: Date.now() - start };
      };
      try {
        if (isDebugEnabled()) {
          clearDebugHighlights();
        }
        resolutionSteps.push(`Ищу ${elementType}`);
        if (!forceDiscovery) {
          const cached = await runLayerCached({ modelName, elementType, timeout: effectiveTimeout, forceDiscovery, referenceElement });
          if (cached) {
            stats.successes += 1;
            resolutionSteps.push(`L1 (Кэш): успех – ${cached.selector}`);
            return finalizeResult(cached, cached.layer || 'cache');
          }
          resolutionSteps.push('L1 (Кэш): промах');
          log(modelName, elementType, 'Cache miss, attempting versioned selectors');
          debugTrace(modelName, elementType, 'Cache miss, proceeding to versioned selectors');
        } else {
          log(modelName, elementType, 'Force discovery enabled, skipping cache layer');
          debugTrace(modelName, elementType, 'Force discovery active, skipping cache');
          resolutionSteps.push('L1 (Кэш): пропущен (forceDiscovery)');
        }

        const uiVersion = detectUIVersion(modelName);
        debugTrace(modelName, elementType, `Detected UI version ${uiVersion}`);
        if (!forceDiscovery) {
          const versioned = await runLayerVersioned({ modelName, elementType, uiVersion, referenceElement });
          if (versioned) {
            stats.successes += 1;
            resolutionSteps.push(`L2 (Версия "${uiVersion}"): успех – ${versioned.selector}`);
            return finalizeResult(versioned, versioned.layer || 'versioned');
          }
          resolutionSteps.push(`L2 (Версия "${uiVersion}"): промах`);
        }

        log(modelName, elementType, 'Versioned selectors failed, attempting auto-discovery');
        debugTrace(modelName, elementType, 'Versioned selectors failed, trying auto-discovery');
        const discovered = await runAutoDiscovery({ modelName, elementType, timeout: effectiveTimeout, referenceElement, uiVersion });
        if (discovered) {
          stats.successes += 1;
          resolutionSteps.push(`L3 (Эвристика): успех – ${discovered.selector}${discovered.confidence ? ` (уверенность=${discovered.confidence})` : ''}`);
          return finalizeResult(discovered, discovered.layer || 'autodiscovery', discovered.confidence ? `уверенность=${discovered.confidence}` : '');
        }
        resolutionSteps.push('L3 (Эвристика): промах');

        warn(modelName, elementType, 'Auto-discovery failed, attempting emergency fallback');
        debugTrace(modelName, elementType, 'Auto-discovery failed, trying emergency fallbacks');
        const fallback = await runEmergencyFallback({ modelName, elementType, referenceElement, uiVersion });
        if (fallback) {
          stats.successes += 1;
          resolutionSteps.push(`L4 (Аварийный фолбэк): успех – ${fallback.selector}`);
          return finalizeResult(fallback, fallback.layer || 'emergency');
        }
        resolutionSteps.push('L4 (Аварийный фолбэк): промах');

        stats.failures += 1;
        error(modelName, elementType, 'All layers failed to locate selector');
        sendMetric('selector_search_failed', { modelName, elementType });
        debugTrace(modelName, elementType, `All layers failed to locate selector. Path: ${resolutionSteps.join(' -> ')}`);
        return null;
      } catch (err) {
        stats.failures += 1;
        error(modelName, elementType, `Search errored: ${err?.message || err}`);
        sendMetric('selector_search_error', { modelName, elementType, message: err?.message || String(err) });
        throw err;
      }
    };

    return withDiscoveryQueue(key, () => {
      const controller = new AbortController();
      const timeoutId = setTimeout(() => {
        controller.abort();
      }, effectiveTimeout);

      const timeoutPromise = new Promise((_, reject) => {
        controller.signal.addEventListener('abort', () => {
          const err = new Error(`Selector search timed out after ${effectiveTimeout}ms`);
          err.code = 'timeout';
          reject(err);
        }, { once: true });
      });

      return Promise.race([attemptSearch(), timeoutPromise])
        .finally(() => clearTimeout(timeoutId));
    });
  };

  const waitForElement = async ({
    modelName = 'Unknown',
    elementType = 'response',
    timeout = 150000,
    prompt = '',
    referenceElement = null
  } = {}) => {
    const effectiveTimeout = Number.isFinite(timeout) ? timeout : 150000;
    const uiVersion = detectUIVersion(modelName);
    debugTrace(modelName, elementType, `waitForElement started (uiVersion=${uiVersion})`);
    if (isDebugEnabled()) clearDebugHighlights();

    const selectorBuckets = gatherSelectorBuckets(modelName, elementType, uiVersion);
    const observationConfig = gatherObservationConfig(modelName, elementType, uiVersion);
    const extraction = gatherExtractionStrategy(modelName, elementType, uiVersion) || {};

    if (!observationConfig) {
      const direct = await findOrDetectSelector({ modelName, elementType, timeout: effectiveTimeout, referenceElement });
      if (direct?.element) {
        const text = extractTextFromNode(direct.element, extraction);
        debugTrace(modelName, elementType, 'waitForElement returning direct selector match');
        return { ...direct, text, extraction };
      }
      return { element: null, text: '', selector: null, method: 'direct', extraction };
    }

    const initialMatch = await findOrDetectSelector({ modelName, elementType, timeout: effectiveTimeout, referenceElement });
    const baseScope = initialMatch?.element instanceof Element ? initialMatch.element : document;
    const observationRoot = await resolveObservationRoot(observationConfig, baseScope, effectiveTimeout);
    const searchScope = baseScope instanceof Element ? baseScope : observationRoot;

    const fallbackDelay = typeof observationConfig.fallbackDelayMs === 'number'
      ? observationConfig.fallbackDelayMs
      : 10000;
    const targetSelectors = Array.isArray(observationConfig.targetSelectors) && observationConfig.targetSelectors.length
      ? observationConfig.targetSelectors
      : Array.from(new Set([...selectorBuckets.primary, ...selectorBuckets.fallback]));

    return new Promise((resolve, reject) => {
      let lastResult = null;
      let timeoutId = null;
      let observer = null;
      let hashIntervalId = null;
      const hashHistory = [];
      let settled = false;
      const startTime = Date.now();

      const cleanup = () => {
        if (observer) observer.disconnect();
        if (timeoutId) clearTimeout(timeoutId);
        if (hashIntervalId) clearInterval(hashIntervalId);
      };

      const finalize = (result) => {
        if (settled) return;
        settled = true;
        cleanup();
        const payload = result || lastResult;
        if (payload?.node) {
          highlightElement(payload.node, `${modelName}/${elementType}: waitForElement`);
        }
        if (payload?.text) {
          debugTrace(modelName, elementType, `waitForElement resolved with ${payload.bucket || 'primary'} selector`, payload.selector);
          resolve({
            element: payload.node,
            text: payload.text,
            selector: payload.selector,
            bucket: payload.bucket,
            method: `observation:${payload.bucket || 'primary'}`,
            extraction
          });
          return;
        }
        if (initialMatch?.element) {
          const fallbackText = extractTextFromNode(initialMatch.element, extraction);
          resolve({
            element: initialMatch.element,
            text: fallbackText,
            selector: initialMatch.selector,
            bucket: 'initial',
            method: initialMatch.method || 'initial',
            extraction
          });
          return;
        }
        reject(new Error('waitForElement resolved without content'));
      };

      const evaluate = (force = false) => {
        const allowFallback = force || (Date.now() - startTime) >= fallbackDelay;
        const primaryCandidate = extractFromSelectors(searchScope, selectorBuckets.primary, extraction, prompt);
        const fallbackCandidate = allowFallback
          ? extractFromSelectors(searchScope, selectorBuckets.fallback, extraction, prompt)
          : null;
        const candidate = primaryCandidate || fallbackCandidate;
        if (!candidate) {
          return;
        }
        if (!lastResult || candidate.text !== lastResult.text) {
          lastResult = {
            ...candidate,
            bucket: primaryCandidate ? 'primary' : 'fallback'
          };
          hashHistory.length = 0;
        }
      };

      const matchesTarget = (node) => {
        if (!(node instanceof Element)) return false;
        if (!targetSelectors.length) return true;
        return targetSelectors.some((selector) => {
          try {
            return node.matches(selector) || !!node.closest(selector);
          } catch {
            return false;
          }
        });
      };

      observer = new MutationObserver((mutations) => {
        const relevant = mutations.some((mutation) => {
          if (mutation.type === 'characterData') {
            const parent = mutation.target?.parentElement;
            return parent ? matchesTarget(parent) : false;
          }
          if (matchesTarget(mutation.target)) return true;
          return Array.from(mutation.addedNodes || []).some((added) => matchesTarget(added));
        });
        if (relevant) {
          evaluate(false);
        }
      });

      try {
        observer.observe(observationRoot, {
          childList: true,
          subtree: true,
          characterData: true
        });
      } catch (err) {
        cleanup();
        reject(err);
        return;
      }

      evaluate(true);

      hashIntervalId = setInterval(() => {
        const activeResult = lastResult || (initialMatch?.element ? {
          node: initialMatch.element,
          text: extractTextFromNode(initialMatch.element, extraction),
          selector: initialMatch.selector,
          bucket: 'initial'
        } : null);

        if (!activeResult || !activeResult.node) return;

        const currentText = extractTextFromNode(activeResult.node, extraction);
        if (!currentText) return;

        const currentHash = computeHash(currentText);
        hashHistory.push({ hash: currentHash, text: currentText, selector: activeResult.selector, bucket: activeResult.bucket, node: activeResult.node });
        if (hashHistory.length > 4) hashHistory.shift();

        const allStable = hashHistory.length >= 3 && hashHistory.every((entry) => entry.hash === hashHistory[0].hash);
        if (allStable && checkEndMarkers(observationConfig.endGenerationMarkers)) {
          const stableEntry = hashHistory[hashHistory.length - 1];
          finalize({
            node: stableEntry.node,
            text: stableEntry.text,
            selector: stableEntry.selector,
            bucket: stableEntry.bucket || 'primary'
          });
        }
      }, 250);

      timeoutId = setTimeout(() => {
        cleanup();
        if (lastResult && lastResult.text) {
          resolve({
            element: lastResult.node,
            text: lastResult.text,
            selector: lastResult.selector,
            bucket: lastResult.bucket,
            method: `timeout:${lastResult.bucket}`,
            extraction
          });
        } else if (initialMatch?.element) {
          const fallbackText = extractTextFromNode(initialMatch.element, extraction);
          resolve({
            element: initialMatch.element,
            text: fallbackText,
            selector: initialMatch.selector,
            bucket: 'initial',
            method: 'timeout:initial',
            extraction
          });
        } else {
          reject(new Error('waitForElement timed out without matching content'));
        }
      }, effectiveTimeout);
    });
  };

  /**
   * Validates a selector within the provided scope and returns the interactable element.
   * @param {string} selector - CSS selector string.
   * @param {Document|Element} [scope=document] - Search scope.
   * @returns {Element|null} Interactable element or null when missing.
   * @example const element = SelectorFinder.validateSelector('#prompt');
   */
  const validateSelector = (selector, scope = document) => {
    try {
      const element = queryDeep(selector, scope);
      return ensureValidElement(element);
    } catch (err) {
      console.warn('[SelectorFinder] validateSelector failed', err);
      return null;
    }
  };

  const runHealthCheck = async ({
    modelName = 'Unknown',
    elementTypes = DEFAULT_ELEMENT_TYPES,
    timeout = DEFAULT_TIMEOUT_MS
  } = {}) => {
    const report = [];
    const targets = Array.isArray(elementTypes) && elementTypes.length ? elementTypes : DEFAULT_ELEMENT_TYPES;
    for (const elementType of targets) {
      try {
        const result = await findOrDetectSelector({ modelName, elementType, timeout, forceDiscovery: false });
        report.push({
          elementType,
          success: !!result,
          selector: result?.selector || null,
          layer: result?.layer || null
        });
      } catch (err) {
        report.push({
          elementType,
          success: false,
          error: err?.message || 'unknown error'
        });
      }
    }
    return report;
  };

  const previewSelector = (selector, label = 'Selector preview') => {
    if (!selector) return false;
    try {
      const element = queryDeep(selector, document);
      if (!ensureValidElement(element)) return false;
      highlightElement(element, `${label}: ${selector}`);
      return true;
    } catch (err) {
      console.warn('[SelectorFinder] previewSelector failed', err);
      return false;
    }
  };

  /**
   * Returns accumulated runtime statistics for diagnostics.
   * @returns {Object} Snapshot of selector finder metrics.
   * @example const stats = SelectorFinder.getStats();
   */
  const getStats = () => ({
    ...stats,
    lastCleanupRun,
    discoveryInProgress: Array.from(discoveryState.keys())
  });

  globalObject.SelectorFinder = {
    findOrDetectSelector,
    waitForElement,
    healthCheck: runHealthCheck,
    clearCache: clearCacheForModel,
    validateSelector,
    previewSelector,
    getStats,
    isElementInteractable
  };
  const waitForSelectorMatch = (selector, { root = document, timeout = 10000 } = {}) => {
    if (!selector || !root) return Promise.resolve(null);
    try {
      const existing = queryDeep(selector, root);
      if (existing) return Promise.resolve(existing);
    } catch (err) {
      console.warn('[SelectorFinder] waitForSelectorMatch initial query failed', selector, err);
      return Promise.resolve(null);
    }

    return new Promise((resolve) => {
      let settled = false;
      const finish = (node) => {
        if (settled) return;
        settled = true;
        observer.disconnect();
        clearTimeout(timer);
        resolve(node);
      };
      const observer = new MutationObserver(() => {
        try {
          const candidate = queryDeep(selector, root);
          if (candidate) {
            finish(candidate);
          }
        } catch (err) {
          console.warn('[SelectorFinder] waitForSelectorMatch mutation query failed', selector, err);
          finish(null);
        }
      });
      observer.observe(root, { childList: true, subtree: true });
      const timer = setTimeout(() => finish(null), timeout);
    });
  };

  const looksLikeUserEcho = (text, prompt) => {
    if (!prompt || !text) return false;
    const prefix = prompt.slice(0, Math.min(prompt.length, 60)).trim();
    if (!prefix) return false;
    return text.trim().startsWith(prefix);
  };

  const extractTextFromNode = (node, extraction) => {
    if (!node) return '';
    const method = extraction?.method || 'innerText';
    if (method.startsWith('attribute:')) {
      const attr = method.split(':')[1];
      return (node.getAttribute?.(attr) || '').trim();
    }
    if (method === 'innerHTML') {
      return (node.innerHTML || '').trim();
    }
    if (method === 'textContent') {
      return (node.textContent || '').trim();
    }
    // Default innerText strategy
    if (node.tagName === 'ARTICLE') {
      const textContainers = node.querySelectorAll('div[lang], div[dir="auto"]');
      let buf = '';
      textContainers.forEach((n) => {
        const t = (n.innerText || n.textContent || '').trim();
        if (t) {
          if (buf) buf += '\n';
          buf += t;
        }
      });
      if (buf) return buf.trim();
    }
    return (node.innerText || node.textContent || '').trim();
  };

  const computeHash = (value) => {
    if (!value) return 0;
    let hash = 0;
    for (let i = 0; i < value.length; i += 1) {
      hash = ((hash << 5) - hash) + value.charCodeAt(i);
      hash |= 0; // Convert to 32bit integer
    }
    return hash >>> 0; // make non-negative
  };

  const extractFromSelectors = (scope, selectors, extraction, prompt) => {
    if (!scope || !Array.isArray(selectors) || !selectors.length) return null;
    for (const selector of selectors) {
      let nodes = [];
      try {
        nodes = queryDeepAll(selector, scope);
      } catch (err) {
        console.warn('[SelectorFinder] Failed to query selector', selector, err);
        continue;
      }
      for (const node of nodes) {
        const text = extractTextFromNode(node, extraction);
        if (text && !looksLikeUserEcho(text, prompt)) {
          return { text, node, selector };
        }
      }
    }
    return null;
  };

  const checkEndMarkers = (markers) => {
    if (!Array.isArray(markers) || !markers.length) return true;
    const doc = document;
    return markers.every((marker) => {
      if (!marker) return true;
      if (marker.type === 'disappear' && marker.selector) {
        try {
          return !queryDeep(marker.selector, doc);
        } catch (err) {
          console.warn('[SelectorFinder] end marker selector failed', marker.selector, err);
          return false;
        }
      }
      const selector = marker.selector || 'body';
      let node = null;
      try {
        node = queryDeep(selector, doc);
      } catch (err) {
        console.warn('[SelectorFinder] end marker selector invalid', selector, err);
        return false;
      }
      if (!node) return false;
      if (marker.attribute) {
        const attrName = typeof marker.attribute === 'string' ? marker.attribute : marker.attribute?.name;
        if (!attrName) return false;
        const expected = marker.value ?? marker.attribute?.value;
        const actual = node.getAttribute(attrName);
        if (expected === undefined) {
          return actual === null || actual === 'false' || actual === '0' || actual === '';
        }
        if (Array.isArray(expected)) {
          return expected.includes(actual);
        }
        return actual === String(expected);
      }
      if (marker.type === 'text') {
        const textContent = (node.textContent || '').trim();
        if (marker.value === undefined) return textContent.length > 0;
        return textContent.includes(marker.value);
      }
      return true;
    });
  };
  const resolveObservationRoot = async (observationConfig, fallbackScope, timeout) => {
    if (observationConfig?.rootSelector) {
      const root = await waitForSelectorMatch(observationConfig.rootSelector, {
        root: document,
        timeout: Math.min(timeout, 15000)
      });
      if (root) return root;
    }
    if (fallbackScope instanceof Element) return fallbackScope;
    return document;
  };

})();

;
// selectors-config.js
(function () {
  const globalObject = typeof window !== 'undefined' ? window : self;
  if (globalObject.SelectorConfig) {
    console.warn('[SelectorConfig] Duplicate load prevented');
    return;
  }

  /**
   * Evaluates whether a marker definition matches the current DOM.
   * @param {Object} marker - Marker descriptor.
   * @param {Document} doc - Document to evaluate against.
   * @returns {boolean} True when the marker is satisfied.
   */
  const buildMarkerChecker = (marker, doc) => {
    if (!marker) return false;
    if (marker.selector) {
      return !!doc.querySelector(marker.selector);
    }
    if (marker.exists) {
      return marker.exists.every((sel) => !!doc.querySelector(sel));
    }
    if (marker.bodyClass) {
      return doc.body?.classList?.contains(marker.bodyClass);
    }
    if (marker.attribute) {
      const node = doc.querySelector(marker.attribute.selector || 'body');
      if (!node) return false;
      const value = node.getAttribute(marker.attribute.name);
      if (typeof marker.attribute.value === 'string') return value === marker.attribute.value;
      if (Array.isArray(marker.attribute.value)) return marker.attribute.value.includes(value);
      return !!value;
    }
    return false;
  };

  const normalizeSelectorCandidates = (value) => {
    if (!value) return [];
    if (Array.isArray(value)) return Array.from(value);
    if (typeof value === 'object') {
      const preferredOrder = ['primary', 'secondary', 'tertiary', 'fallback', 'all'];
      const result = [];
      for (const key of preferredOrder) {
        if (Array.isArray(value[key])) {
          result.push(...value[key]);
        }
      }
      for (const key of Object.keys(value)) {
        if (!preferredOrder.includes(key) && Array.isArray(value[key])) {
          result.push(...value[key]);
        }
      }
      return result;
    }
    return [];
  };

  const baseModels = globalObject.SelectorConfigRegistry || {};
  let activeModels = cloneModelTree(baseModels);
  let remoteFullModels = {};
  let remoteOverridePatch = null;
  let manualOverrideRegistry = {};

  function cloneModelTree(source) {
    if (typeof structuredClone === 'function') {
      try {
        return structuredClone(source);
      } catch (_) { /* fallback to JSON */ }
    }
    try {
      return JSON.parse(JSON.stringify(source));
    } catch (err) {
      console.warn('[SelectorConfig] Failed to clone base models', err);
      return {};
    }
  }

  function mergeConfigs(base, override) {
    if (!override || typeof override !== 'object') return base;
    const output = Array.isArray(base) ? base.slice() : { ...base };
    Object.keys(override).forEach((key) => {
      const nextValue = override[key];
      const currentValue = output[key];
      if (Array.isArray(nextValue)) {
        output[key] = nextValue.slice();
      } else if (
        nextValue &&
        typeof nextValue === 'object' &&
        currentValue &&
        typeof currentValue === 'object' &&
        !Array.isArray(currentValue)
      ) {
        output[key] = mergeConfigs(currentValue, nextValue);
      } else {
        output[key] = nextValue;
      }
    });
    return output;
  }

  const hasEntries = (obj) => !!obj && typeof obj === 'object' && Object.keys(obj).length > 0;

  function rebuildActiveModels() {
    const combined = cloneModelTree(baseModels);
    if (hasEntries(remoteFullModels)) {
      Object.entries(remoteFullModels).forEach(([modelName, definition]) => {
        if (definition && typeof definition === 'object') {
          combined[modelName] = cloneModelTree(definition);
        }
      });
    }
    activeModels = hasEntries(remoteOverridePatch)
      ? mergeConfigs(combined, remoteOverridePatch)
      : combined;
  }

  function normalizeRemotePayload(payload) {
    if (!payload || typeof payload !== 'object') return { models: {}, overrides: null, manualOverrides: null };
    const bundle = payload.bundle?.selectors || payload;
    const models =
      bundle.fullModels ||
      bundle.models ||
      bundle.configs ||
      bundle.modules ||
      bundle.files ||
      null;
    const overrides =
      bundle.overrides ||
      bundle.patch ||
      bundle.deltas ||
      (models ? null : bundle);
    const manualOverrides =
      bundle.manualOverrides ||
      payload.manualOverrides ||
      null;
    return {
      models: hasEntries(models) ? models : {},
      overrides: hasEntries(overrides) ? overrides : null,
      manualOverrides: hasEntries(manualOverrides) ? manualOverrides : null
    };
  }

  function applyRemoteConfigPayload(payload) {
    const { models, overrides, manualOverrides } = normalizeRemotePayload(payload);
    remoteFullModels = cloneModelTree(models || {});
    remoteOverridePatch = overrides ? cloneModelTree(overrides) : null;
    manualOverrideRegistry = manualOverrides ? cloneModelTree(manualOverrides) : {};
    rebuildActiveModels();
  }

  function primeRemoteOverrides() {
    if (!chrome?.storage?.local?.get) return;
    chrome.storage.local.get('selectors_remote_override', (res) => {
      if (chrome.runtime?.lastError) return;
      if (res?.selectors_remote_override) {
        applyRemoteConfigPayload(res.selectors_remote_override);
        console.info('[SelectorConfig] Remote registry payload applied');
      } else {
        remoteFullModels = {};
        remoteOverridePatch = null;
        rebuildActiveModels();
      }
    });
    if (chrome.storage.onChanged) {
      chrome.storage.onChanged.addListener((changes, areaName) => {
        if (areaName !== 'local' || !changes.selectors_remote_override) return;
        applyRemoteConfigPayload(changes.selectors_remote_override.newValue || null);
        console.info('[SelectorConfig] Remote registry payload updated via storage change');
      });
    }
  }

  primeRemoteOverrides();

  const getModelConfig = (modelName) => activeModels[modelName] || null;

  const detectUIVersion = (modelName, doc = document) => {
    const modelConfig = getModelConfig(modelName);
    if (!modelConfig) return 'unknown';
    for (const version of modelConfig.versions || []) {
      const matchAllMarkers = (version.markers || []).every((marker) => buildMarkerChecker(marker, doc));
      if (matchAllMarkers) {
        return version.version;
      }
    }
    return 'unknown';
  };

  const getSelectorsFor = (modelName, versionId, elementType) => {
    const modelConfig = getModelConfig(modelName);
    if (!modelConfig) return [];
    const manualList = Array.isArray(manualOverrideRegistry?.[modelName]?.[elementType])
      ? manualOverrideRegistry[modelName][elementType]
      : [];
    if (versionId === 'emergency') {
      const emergency = Array.from(modelConfig.emergencyFallbacks?.[elementType] || []);
      return manualList.length ? Array.from(new Set([...manualList, ...emergency])) : emergency;
    }
    const versionEntry = (modelConfig.versions || []).find((v) => v.version === versionId);
    if (!versionEntry) {
      return manualList.length ? Array.from(new Set(manualList)) : [];
    }
    const selectors = normalizeSelectorCandidates(versionEntry.selectors?.[elementType]);
    if (!manualList.length) return selectors;
    return Array.from(new Set([...manualList, ...selectors]));
  };

  const getConstraintsFor = (modelName, versionId, elementType) => {
    const modelConfig = getModelConfig(modelName);
    if (!modelConfig) return null;
    const consolidate = [];
    const includeFrom = (versionEntry) => {
      const constraint = versionEntry?.constraints?.[elementType];
      if (constraint?.exclude) {
        consolidate.push(...constraint.exclude);
      }
    };
    if (versionId && versionId !== 'unknown') {
      const versionEntry = (modelConfig.versions || []).find((v) => v.version === versionId);
      includeFrom(versionEntry);
    } else {
      for (const versionEntry of modelConfig.versions || []) {
        includeFrom(versionEntry);
      }
    }
    if (!consolidate.length && Array.isArray(modelConfig?.constraints?.[elementType]?.exclude)) {
      consolidate.push(...modelConfig.constraints[elementType].exclude);
    }
    if (!consolidate.length) return null;
    return { exclude: Array.from(new Set(consolidate)) };
  };

  const getExtractionConfig = (modelName, versionId, elementType) => {
    const modelConfig = getModelConfig(modelName);
    if (!modelConfig) return null;
    const pick = (versionEntry) => versionEntry?.selectors?.[elementType]?.extraction || null;
    if (versionId && versionId !== 'unknown') {
      const versionEntry = (modelConfig.versions || []).find((v) => v.version === versionId);
      const extraction = pick(versionEntry);
      if (extraction) return { ...extraction };
    }
    for (const versionEntry of modelConfig.versions || []) {
      const extraction = pick(versionEntry);
      if (extraction) return { ...extraction };
    }
    return null;
  };

  const listVersions = (modelName) => {
    const modelConfig = getModelConfig(modelName);
    if (!modelConfig) return [];
    return modelConfig.versions.map(({ version, dateCreated, description }) => ({
      version,
      dateCreated,
      description
    }));
  };

  const normalizeVersionMeta = (versionEntry, nowTs) => {
    if (!versionEntry) return null;
    const expiresAtTs = versionEntry.expiresAt ? Date.parse(versionEntry.expiresAt) : null;
    const daysRemaining = Number.isFinite(expiresAtTs)
      ? Math.ceil((expiresAtTs - nowTs) / (24 * 60 * 60 * 1000))
      : null;
    return {
      version: versionEntry.version,
      uiRevision: versionEntry.uiRevision || versionEntry.version || 'unknown',
      expiresAt: versionEntry.expiresAt || null,
      qaNotes: versionEntry.qaNotes || '',
      expired: Number.isFinite(expiresAtTs) ? expiresAtTs < nowTs : false,
      daysRemaining,
      description: versionEntry.description || ''
    };
  };

  const getVersionStatus = (modelName) => {
    const modelConfig = getModelConfig(modelName);
    if (!modelConfig) {
      return { modelName, versions: [], hasVersions: false, fullyExpired: false };
    }
    const now = Date.now();
    const versions = (modelConfig.versions || []).map((entry) => normalizeVersionMeta(entry, now)).filter(Boolean);
    const activeVersions = versions.filter((entry) => !entry.expired);
    return {
      modelName,
      versions,
      hasVersions: versions.length > 0,
      fullyExpired: versions.length > 0 && activeVersions.length === 0,
      updatedAt: new Date(now).toISOString()
    };
  };

  const getAllVersionStatuses = () => {
    const snapshot = {};
    Object.keys(activeModels).forEach((modelName) => {
      snapshot[modelName] = getVersionStatus(modelName);
    });
    return snapshot;
  };

  const getAnchorsFor = (modelName, versionId, elementType) => {
    const modelConfig = getModelConfig(modelName);
    if (!modelConfig) return [];
    const collectAnchors = (versionEntry) => {
      const anchors = versionEntry?.anchors?.[elementType];
      return Array.isArray(anchors) ? anchors : [];
    };
    if (versionId && versionId !== 'unknown') {
      const versionEntry = (modelConfig.versions || []).find((v) => v.version === versionId);
      const anchors = collectAnchors(versionEntry);
      if (anchors.length) return anchors;
    }
    const aggregated = [];
    (modelConfig.versions || []).forEach((versionEntry) => aggregated.push(...collectAnchors(versionEntry)));
    return Array.from(new Set(aggregated));
  };

  globalObject.SelectorConfig = {
    get models() {
      return activeModels;
    },
    detectUIVersion,
    getModelConfig,
    getSelectorsFor,
    getConstraintsFor,
    getExtractionConfig,
    listVersions,
    getVersionStatus,
    getAllVersionStatuses,
    getAnchorsFor
  };
})();

;
(function initHumanoidLifecycle() {
  const globalObject = typeof window !== 'undefined' ? window : self;
  if (globalObject.HumanoidEvents) {
    return;
  }

  const hasChromeRuntime = () => typeof chrome !== 'undefined' && !!chrome.runtime?.id;

  class HumanoidLifecycle extends EventTarget {
    constructor() {
      super();
      this.activeActivities = new Map();
      this.activityHistory = new Map();
      this.watchdogTimers = new Map();
      this.TIMEOUTS = {
        'anti-sleep': 300000,
        scroll: 120000,
        read: 120000,
        pipeline: 600000,
        default: 180000
      };
      this.pendingEvents = [];
      this.pendingKey = '__humanoid_pending_events';
      this.debugLogKey = '__humanoid_debug_log';
      this.debugEnabled = false;
      this.pendingFlushInterval = null;
      this._restorePendingEvents();
      this._initDebugFlag();
      this._startPendingFlush();
    }

    start(source, context = {}) {
      const traceId = context.traceId || this._generateTraceId();
      const timestamp = Date.now();
      const activity = Object.assign({ traceId, source, timestamp }, context);
      this.activeActivities.set(traceId, activity);
      this._emit('activity:start', activity);
      this._startWatchdog(traceId, source);
      return traceId;
    }

    stop(traceId, result = {}) {
      const activity = this.activeActivities.get(traceId);
      if (!activity) return;
      const duration = Date.now() - activity.timestamp;
      const stopData = Object.assign({}, activity, result, {
        duration,
        stoppedAt: Date.now()
      });
      this._saveToHistory(traceId, stopData);
      this.activeActivities.delete(traceId);
      this._clearWatchdog(traceId);
      this._emit('activity:stop', stopData);
    }

    heartbeat(traceId, progress = 0, meta = {}) {
      const activity = this.activeActivities.get(traceId);
      if (!activity) return;
      this._resetWatchdog(traceId, activity.source);
      const heartbeatData = Object.assign({
        traceId,
        source: activity.source,
        progress,
        timestamp: Date.now()
      }, meta);
      this._emit('activity:heartbeat', heartbeatData);
    }

    error(traceId, error, fatal = false) {
      const payload = {
        traceId,
        error: error?.message || String(error || 'unknown'),
        stack: error?.stack,
        fatal,
        timestamp: Date.now()
      };
      this._emit('activity:error', payload);
      if (fatal && traceId) {
        this.stop(traceId, { status: 'error', error: payload });
      }
    }

    stopAll(reason = 'force') {
      const ids = Array.from(this.activeActivities.keys());
      ids.forEach((traceId) => {
        this.stop(traceId, { status: 'forced', reason, forced: true });
      });
    }

    get isBusy() {
      return this.activeActivities.size > 0;
    }

    _emit(eventType, detail) {
      this.dispatchEvent(new CustomEvent(eventType, { detail }));
      this._mirrorToBackground(eventType, detail);
      this._logDebug(eventType, detail);
    }

    _mirrorToBackground(eventType, detail) {
      if (!hasChromeRuntime()) {
        this._queuePendingEvent(eventType, detail);
        return;
      }
      try {
        chrome.runtime.sendMessage(
          {
            type: 'HUMANOID_EVENT',
            event: eventType,
            detail
          },
          () => {
            if (chrome.runtime.lastError) {
              this._queuePendingEvent(eventType, detail);
            }
          }
        );
      } catch (_) {
        this._queuePendingEvent(eventType, detail);
      }
    }

    _queuePendingEvent(eventType, detail) {
      this.pendingEvents.push({ eventType, detail, timestamp: Date.now() });
      if (this.pendingEvents.length > 50) {
        this.pendingEvents.shift();
      }
      this._persistPendingEvents();
    }

    _startPendingFlush() {
      if (this.pendingFlushInterval) return;
      this.pendingFlushInterval = setInterval(() => this._flushPendingEvents(), 10000);
    }

    _flushPendingEvents() {
      if (!this.pendingEvents.length || !hasChromeRuntime()) {
        return;
      }
      const queue = [...this.pendingEvents];
      this.pendingEvents.length = 0;
      this._persistPendingEvents();
      queue.forEach(({ eventType, detail }) => this._mirrorToBackground(eventType, detail));
    }

    _persistPendingEvents() {
      try {
        sessionStorage.setItem(this.pendingKey, JSON.stringify(this.pendingEvents));
      } catch (_) {
        // ignore storage errors
      }
    }

    _restorePendingEvents() {
      try {
        const stored = sessionStorage.getItem(this.pendingKey);
        if (stored) {
          this.pendingEvents = JSON.parse(stored) || [];
        }
      } catch (_) {
        this.pendingEvents = [];
      }
    }

    _safeStorageGet(key, defaultValue = null) {
      try {
        return globalObject.localStorage?.getItem(key) ?? defaultValue;
      } catch (_) {
        return defaultValue;
      }
    }

    _safeStorageSet(key, value) {
      try {
        globalObject.localStorage?.setItem(key, value);
        return true;
      } catch (_) {
        return false;
      }
    }

    _initDebugFlag() {
      const flag = this._safeStorageGet('HUMANOID_DEBUG', 'false');
      this.debugEnabled = flag === 'true';
      if (this.debugEnabled) {
        console.log('🐛 HumanoidLifecycle debug mode enabled');
      }
    }

    _logDebug(eventType, detail) {
      if (!this.debugEnabled) return;
      const entry = {
        type: eventType,
        detail,
        timestamp: Date.now(),
        url: globalObject.location?.href
      };
      try {
        const stored = this._safeStorageGet(this.debugLogKey, '[]');
        const existing = JSON.parse(stored) || [];
        existing.push(entry);
        this._safeStorageSet(this.debugLogKey, JSON.stringify(existing.slice(-500)));
      } catch (_) {
        // ignore
      }
      console.log('[HumanoidLifecycle]', eventType, detail);
    }

    _startWatchdog(traceId, source) {
      const timeout = this.TIMEOUTS[source] || this.TIMEOUTS.default;
      if (this.watchdogTimers.has(traceId)) {
        clearTimeout(this.watchdogTimers.get(traceId));
      }
      const timer = setTimeout(() => {
        if (!this.activeActivities.has(traceId)) return;
        console.warn(`[HumanoidLifecycle] Watchdog timeout for ${traceId} (${source})`);
        this.stop(traceId, { status: 'timeout', forced: true, reason: 'watchdog' });
      }, timeout);
      this.watchdogTimers.set(traceId, timer);
    }

    _resetWatchdog(traceId, source) {
      this._startWatchdog(traceId, source);
    }

    _clearWatchdog(traceId) {
      const timer = this.watchdogTimers.get(traceId);
      if (timer) {
        clearTimeout(timer);
        this.watchdogTimers.delete(traceId);
      }
    }

    _saveToHistory(traceId, data) {
      this.activityHistory.set(traceId, data);
      if (this.activityHistory.size > 100) {
        const firstKey = this.activityHistory.keys().next().value;
        this.activityHistory.delete(firstKey);
      }
    }

    async runActivity(source, context = {}, executor) {
      if (typeof executor !== 'function') {
        throw new Error('HumanoidLifecycle.runActivity requires executor function');
      }
      const traceId = this.start(source, context);
      let stopped = false;
      const controller = {
        traceId,
        heartbeat: (progress, meta) => this.heartbeat(traceId, progress, meta),
        stop: (result = {}) => {
          if (stopped) return;
          if (this.activeActivities.has(traceId)) {
            this.stop(traceId, result);
          }
          stopped = true;
        },
        error: (error, fatal = false) => this.error(traceId, error, fatal)
      };
      try {
        const result = await executor(controller);
        if (!stopped) {
          controller.stop({ status: 'success' });
        }
        return result;
      } catch (error) {
        controller.error(error, true);
        if (!stopped) {
          controller.stop({ status: 'error', error: error?.message || String(error) });
        }
        throw error;
      }
    }

    _generateTraceId() {
      if (typeof crypto !== 'undefined' && crypto.randomUUID) {
        return crypto.randomUUID();
      }
      return `humanoid-${Date.now()}-${Math.random().toString(16).slice(2, 10)}`;
    }
  }

  const lifeCycle = new HumanoidLifecycle();
  globalObject.HumanoidEvents = lifeCycle;
  globalObject.HumanoidLifecycle = HumanoidLifecycle;

  globalObject.HumanoidDebug = {
    getActivities: () => Array.from(lifeCycle.activeActivities.values()),
    getHistory: () => Array.from(lifeCycle.activityHistory.values()),
    getPending: () => [...lifeCycle.pendingEvents],
    clearHistory: () => lifeCycle.activityHistory.clear(),
    stopAll: (reason) => lifeCycle.stopAll(reason || 'manual-debug')
  };

  globalObject.withHumanoidActivity = function (source, context = {}, executor) {
    const lifecycle = globalObject.HumanoidEvents;
    if (lifecycle?.runActivity) {
      return lifecycle.runActivity(source, context, executor);
    }
    if (typeof executor === 'function') {
      return executor({
        traceId: null,
        heartbeat: () => {},
        stop: () => {},
        error: () => {}
      });
    }
    return undefined;
  };

  if (globalObject.addEventListener) {
    globalObject.addEventListener('pagehide', () => {
      lifeCycle.stopAll('pagehide');
    });
    globalObject.addEventListener('beforeunload', () => {
      lifeCycle.stopAll('page-unload');
    });
  }
})();

;
(function initHumanoidCleanupRegistry() {
  if (typeof window === 'undefined') return;
  if (window.HumanoidCleanup?.createScope) return;

  const toArray = (iterable) => (Array.isArray(iterable) ? iterable : Array.from(iterable || []));

  function createScope(label = 'default') {
    const intervals = new Set();
    const timeouts = new Set();
    const animationFrames = new Set();
    const observers = new Set();
    const abortControllers = new Set();
    const disposables = new Set();
    const listeners = new Set();
    let cleaned = false;
    let cleanupReason = null;

    const track = (collection, value) => {
      if (value == null) return value;
      collection.add(value);
      return value;
    };

    const forget = (collection, value) => {
      if (value == null) return;
      collection.delete(value);
    };

    const scope = {
      label,
      trackInterval: (id) => track(intervals, id),
      trackTimeout: (id) => track(timeouts, id),
      trackAnimationFrame: (id) => track(animationFrames, id),
      trackObserver: (observer) => {
        if (observer && typeof observer.disconnect === 'function') {
          observers.add(observer);
        }
        return observer;
      },
      trackAbortController: (controller) => {
        if (controller && typeof controller.abort === 'function') {
          abortControllers.add(controller);
        }
        return controller;
      },
      register: (fn) => {
        if (typeof fn !== 'function') return () => {};
        disposables.add(fn);
        return () => disposables.delete(fn);
      },
      addEventListener: (target, event, handler, options) => {
        if (!target?.addEventListener || typeof handler !== 'function') {
          return () => {};
        }
        target.addEventListener(event, handler, options);
        const entry = { target, event, handler, options };
        listeners.add(entry);
        return () => {
          listeners.delete(entry);
          try {
            target.removeEventListener(event, handler, options);
          } catch (_) {}
        };
      },
      isCleaned: () => cleaned,
      getReason: () => cleanupReason,
      cleanup: (reason = 'manual-stop') => {
        if (cleaned) return cleanupReason;
        cleaned = true;
        cleanupReason = reason;
        toArray(intervals).forEach((id) => {
          try { clearInterval(id); } catch (_) {}
        });
        toArray(timeouts).forEach((id) => {
          try { clearTimeout(id); } catch (_) {}
        });
        toArray(animationFrames).forEach((id) => {
          try { cancelAnimationFrame(id); } catch (_) {}
        });
        toArray(observers).forEach((observer) => {
          try { observer.disconnect(); } catch (_) {}
        });
        observers.clear();
        toArray(abortControllers).forEach((controller) => {
          try { controller.abort(reason); } catch (_) {}
        });
        abortControllers.clear();
        toArray(listeners).forEach(({ target, event, handler, options }) => {
          try {
            target.removeEventListener(event, handler, options);
          } catch (_) {}
        });
        listeners.clear();
        toArray(disposables).forEach((fn) => {
          try { fn(reason); } catch (_) {}
        });
        disposables.clear();
        intervals.clear();
        timeouts.clear();
        animationFrames.clear();
        return cleanupReason;
      },
      forgetInterval: (id) => forget(intervals, id),
      forgetTimeout: (id) => forget(timeouts, id),
      forgetAnimationFrame: (id) => forget(animationFrames, id)
    };

    // Convenience helpers to reduce boilerplate in long waits
    scope.setTrackedTimeout = (fn, ms) => {
      const id = setTimeout(fn, ms);
      return scope.trackTimeout(id);
    };
    scope.setTrackedInterval = (fn, ms) => {
      const id = setInterval(fn, ms);
      return scope.trackInterval(id);
    };
    scope.requestTrackedAnimationFrame = (fn) => {
      const id = requestAnimationFrame(fn);
      return scope.trackAnimationFrame(id);
    };
    scope.createTrackedMutationObserver = (callback) => {
      if (typeof MutationObserver === 'undefined') return null;
      const observer = new MutationObserver(callback);
      return scope.trackObserver(observer);
    };
    scope.createTrackedIntersectionObserver = (callback, options) => {
      if (typeof IntersectionObserver === 'undefined') return null;
      const observer = new IntersectionObserver(callback, options);
      return scope.trackObserver(observer);
    };
    scope.observeMutations = (target, options, callback) => {
      const observer = scope.createTrackedMutationObserver(callback);
      if (observer && target) {
        observer.observe(target, options);
      }
      return observer;
    };

    return scope;
  }

  window.HumanoidCleanup = {
    createScope
  };
})();

;
(function () {
  const globalObject = typeof window !== 'undefined' ? window : self;
  if (globalObject.Humanoid) {
    console.warn('[Humanoid] Duplicate load prevented');
    return;
  }

  globalObject.LLMExtension = globalObject.LLMExtension || {};

  const sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

  const randomBetween = (min, max) => Math.random() * (max - min) + min;

  class CursorGhost {
    constructor() {
      this.node = null;
      this.styleNode = null;
      this.enabled = this.shouldEnable();
      this.hideTimer = null;
      if (this.enabled) {
        this.ensure();
      }
    }

    shouldEnable() {
      try {
        return localStorage.getItem('__debug_cursor') === 'true';
      } catch (_) {
        return false;
      }
    }

    enable() {
      this.enabled = true;
      this.ensure();
    }

    disable() {
      this.enabled = false;
      if (this.node?.parentNode) this.node.parentNode.removeChild(this.node);
      if (this.styleNode?.parentNode) this.styleNode.parentNode.removeChild(this.styleNode);
      this.node = null;
      this.styleNode = null;
      if (this.hideTimer) clearTimeout(this.hideTimer);
    }

    ensure() {
      if (this.node) return;
      const style = document.createElement('style');
      style.id = 'cursor-ghost-style';
      style.textContent = `
        #cursor-ghost {
          position: fixed;
          width: 16px;
          height: 16px;
          margin: -8px 0 0 -8px;
          border: 2px solid rgba(255,138,0,0.95);
          border-radius: 50%;
          background: rgba(255,138,0,0.25);
          pointer-events: none;
          z-index: 2147483647;
          transition: transform 0.25s ease, opacity 0.4s ease;
          opacity: 0;
        }
      `;
      const node = document.createElement('div');
      node.id = 'cursor-ghost';
      document.documentElement.appendChild(style);
      document.documentElement.appendChild(node);
      this.node = node;
      this.styleNode = style;
    }

    move(x, y) {
      if (!this.enabled) {
        if (!this.shouldEnable()) return;
        this.enable();
      }
      if (!this.node) this.ensure();
      if (!this.node) return;
      this.node.style.transform = `translate(${Math.round(x)}px, ${Math.round(y)}px)`;
      this.node.style.opacity = '1';
      if (this.hideTimer) clearTimeout(this.hideTimer);
      this.hideTimer = setTimeout(() => {
        if (this.node) this.node.style.opacity = '0';
      }, 900);
    }
  }

  const cursorGhost = new CursorGhost();
  globalObject.LLMExtension.cursorGhost = cursorGhost;

  class MouseSimulator {
    constructor() {
      this.currentX = (globalObject.innerWidth || 0) / 2;
      this.currentY = (globalObject.innerHeight || 0) / 2;
    }

    dispatchMouseMove(x, y) {
      this.currentX = x;
      this.currentY = y;
      const evt = new MouseEvent('mousemove', {
        bubbles: true,
        cancelable: true,
        clientX: x,
        clientY: y,
        movementX: 0,
        movementY: 0,
        view: globalObject
      });
      globalObject.dispatchEvent(evt);
      cursorGhost.move(x, y);
    }

    async moveTo(x, y) {
      const steps = 4;
      const startX = this.currentX;
      const startY = this.currentY;
      for (let i = 1; i <= steps; i += 1) {
        const t = i / steps;
        const eased = t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t; // easeInOutQuad
        const jitterX = (Math.random() - 0.5) * 6;
        const jitterY = (Math.random() - 0.5) * 3;
        this.dispatchMouseMove(
          startX + (x - startX) * eased + jitterX,
          startY + (y - startY) * eased + jitterY
        );
        await sleep(12 + Math.random() * 18);
      }
    }

    async scrollWithMouse(deltaY) {
      const steps = Math.abs(deltaY) > 500 ? 5 : 3;
      const stepAmount = deltaY / steps;
      for (let i = 0; i < steps; i += 1) {
        const jitterX = (Math.random() - 0.5) * 20;
        const jitterY = (Math.random() - 0.5) * 10;
        this.dispatchMouseMove(
          this.currentX + jitterX,
          this.currentY + jitterY
        );
        globalObject.dispatchEvent(new WheelEvent('wheel', {
          bubbles: true,
          cancelable: true,
          deltaY: stepAmount,
          deltaMode: WheelEvent.DOM_DELTA_PIXEL,
          clientX: this.currentX,
          clientY: this.currentY
        }));
        await sleep(100 + Math.random() * 100);
      }
    }
  }

  const READING_CONFIG = {
    WPM_SLOW: 150,
    WPM_NORMAL: 250,
    WPM_FAST: 350,
    AVG_WORD_LENGTH: 5,
    PARAGRAPH_PAUSE_MS: 500,
    SECTION_PAUSE_MS: 1000,
    SCROLL_STEP_PX: 100,
    SCROLL_PAUSE_MS: 200
  };

  class ReadingSimulator {
    constructor(mouseSimulator) {
      this.wpm = READING_CONFIG.WPM_NORMAL;
      this.isReading = false;
      this.mouseSimulator = mouseSimulator;
    }

    setSpeed(speed) {
      if (speed === 'slow') this.wpm = READING_CONFIG.WPM_SLOW;
      else if (speed === 'fast') this.wpm = READING_CONFIG.WPM_FAST;
      else this.wpm = READING_CONFIG.WPM_NORMAL;
    }

    calculateReadingTime(text) {
      if (!text) return 0;
      const words = text.length / READING_CONFIG.AVG_WORD_LENGTH;
      const minutes = words / this.wpm;
      const variation = 0.8 + Math.random() * 0.4;
      return Math.round(minutes * 60 * 1000 * variation);
    }

    async readPage(durationMs = 1500) {
      if (this.isReading) return;
      this.isReading = true;
      try {
        const startTime = Date.now();
        while (Date.now() - startTime < durationMs) {
          const action = Math.random();
          if (action < 0.4) {
            const scrollAmount = (Math.random() - 0.3) * READING_CONFIG.SCROLL_STEP_PX * 2;
            if (this.mouseSimulator) {
              await this.mouseSimulator.scrollWithMouse(scrollAmount);
            } else {
              globalObject.scrollBy({ top: scrollAmount, behavior: 'smooth' });
            }
          } else if (action < 0.7 && this.mouseSimulator) {
            const x = this.mouseSimulator.currentX + (Math.random() - 0.5) * 100;
            const y = this.mouseSimulator.currentY + (Math.random() - 0.5) * 50;
            const safeX = Math.max(50, Math.min((globalObject.innerWidth || 0) - 50, x));
            const safeY = Math.max(50, Math.min((globalObject.innerHeight || 0) - 50, y));
            await this.mouseSimulator.moveTo(safeX, safeY);
          } else {
            await sleep(200 + Math.random() * 300);
          }
          await sleep(100 + Math.random() * 200);
        }
      } finally {
        this.isReading = false;
      }
    }

    async readElement(element) {
      if (!element) return;
      const text = element.textContent || '';
      const readingTime = this.calculateReadingTime(text);
      element.scrollIntoView({ behavior: 'smooth', block: 'center' });
      await sleep(300);
      await this.readPage(readingTime);
    }

    async preInputScan() {
      await this.readPage(500 + Math.random() * 500);
    }
  }

  const mouseSimulator = new MouseSimulator();
  const readingSimulator = new ReadingSimulator(mouseSimulator);
  globalObject.LLMExtension.mouseSimulator = mouseSimulator;
  globalObject.LLMExtension.readingSimulator = readingSimulator;


  const getScrollToolkit = (() => {
    let cached = null;
    let failed = false;
    return () => {
      if (cached) return cached;
      if (failed) return null;
      try {
        const Toolkit = window.__UniversalScrollToolkit;
        if (!Toolkit) return null;
        cached = new Toolkit({
          idleThreshold: 900,
          driftStepMs: 40,
          maxShadowDepth: 6,
          maxIframeDepth: 3
        });
        return cached;
      } catch (err) {
        console.warn('[Humanoid] ScrollToolkit init failed', err);
        failed = true;
        return null;
      }
    };
  })();

  const isElement = (value) => value && typeof value === 'object' && value instanceof Element;

  const ensureElement = (element) => {
    if (!isElement(element)) {
      throw new Error('[Humanoid] Provided target is not a valid DOM element');
    }
    return element;
  };

  const dispatchMouseEvent = (element, type) => {
    const rect = element.getBoundingClientRect();
    const clientX = rect.left + rect.width / 2 + randomBetween(-3, 3);
    const clientY = rect.top + rect.height / 2 + randomBetween(-3, 3);
    const event = new MouseEvent(type, {
      bubbles: true,
      cancelable: true,
      view: window,
      clientX,
      clientY
    });
    element.dispatchEvent(event);
  };

//-- 1.1. Надёжный плавный скролл: вычисляет целевую позицию и использует native smooth, а при отсутствии — rAF-фоллбек --//
const scrollIntoViewSmoothly = async (element) => {
  try {
    const toolkit = getScrollToolkit();
    if (toolkit?.scrollElementIntoView) {
      await toolkit.scrollElementIntoView(element, { settle: true, offset: 18 });
      return;
    }
  } catch (_) {
    // fallback ниже
  }
  const rect = element.getBoundingClientRect();
  const elementCenterY = rect.top + rect.height / 2 + window.scrollY;
  const targetY = Math.max(0, Math.round(elementCenterY - window.innerHeight / 2));

  // Если браузер поддерживает объектный аргумент для scrollTo - используем native smooth
  try {
    if (typeof window.scrollTo === 'function') {
      window.scrollTo({ top: targetY, behavior: 'smooth' });
      const start = Date.now();
      // Ждём завершения (или таймаут) — с небольшими паузами, чтобы не блокировать поток
      while (Math.abs(window.scrollY - targetY) > 2 && Date.now() - start < 1200) {
        // eslint-disable-next-line no-await-in-loop
        await sleep(30);
      }
    } else {
      throw new Error('no-native-scroll');
    }
  } catch (_) {
    // rAF fallback: плавная анимация с easeInOut
    const startY = window.scrollY;
    const delta = targetY - startY;
    const duration = 420 + Math.floor(Math.random() * 160);
    await new Promise((resolve) => {
      let startTs = null;
      function step(ts) {
        if (!startTs) startTs = ts;
        const t = Math.min(1, (ts - startTs) / duration);
        const ease = t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t; // easeInOutQuad
        window.scrollTo(0, Math.round(startY + delta * ease));
        if (t < 1) requestAnimationFrame(step);
        else resolve();
      }
      requestAnimationFrame(step);
    });
  }

  await sleep(randomBetween(120, 220));
};




  const dispatchInputEvent = (element, data = '', inputType = 'insertText') => {
    try {
      const inputEvent = new InputEvent('input', { data, bubbles: true, inputType });
      element.dispatchEvent(inputEvent);
    } catch (_) {
      element.dispatchEvent(new Event('input', { bubbles: true }));
    }
  };

  const setCaretToEnd = (element) => {
    try {
      element.focus({ preventScroll: true });
    } catch (_) {
      element.focus();
    }
    const selection = window.getSelection?.();
    if (!selection) return;
    const range = document.createRange();
    range.selectNodeContents(element);
    range.collapse(false);
    selection.removeAllRanges();
    selection.addRange(range);
  };

  const sanitizeValue = (value) => String(value ?? '').replace(/\u200b/g, '');

  const readElementValue = (element) => {
    if (!element) return '';
    if (typeof element.value === 'string') return sanitizeValue(element.value);
    if (typeof element.innerText === 'string' && element.innerText.trim()) return sanitizeValue(element.innerText);
    if (typeof element.textContent === 'string') return sanitizeValue(element.textContent);
    return '';
  };

  const replaceContentEditableText = (element, text) => {
    const selection = window.getSelection?.();
    const normalized = sanitizeValue(text);
    try {
      element.focus({ preventScroll: true });
    } catch (_) {
      element.focus?.();
    }

    let range = null;
    if (selection) {
      range = document.createRange();
      range.selectNodeContents(element);
      selection.removeAllRanges();
      selection.addRange(range);
    }

    let execOk = false;
    try {
      if (typeof InputEvent === 'function') {
        const beforeEvent = new InputEvent('beforeinput', {
          data: normalized,
          inputType: 'insertReplacementText',
          bubbles: true,
          cancelable: true
        });
        element.dispatchEvent(beforeEvent);
        if (beforeEvent.defaultPrevented) {
          execOk = true;
        } else if (document.execCommand) {
          execOk = document.execCommand('insertText', false, normalized);
        }
      } else if (document.execCommand) {
        execOk = document.execCommand('insertText', false, normalized);
      }
    } catch (_) {
      execOk = false;
    }

    if (!execOk && range) {
      range.deleteContents();
      range.insertNode(document.createTextNode(normalized));
      selection?.removeAllRanges();
      selection?.addRange(range);
    }
    if (!execOk && typeof element.textContent === 'string') {
      element.textContent = normalized;
    }
    element.dispatchEvent(new InputEvent('input', {
      data: normalized,
      inputType: 'insertFromPaste',
      bubbles: true
    }));
    element.dispatchEvent(new Event('change', { bubbles: true }));
    setCaretToEnd(element);
  };

  const typeCharacter = async (element, char, isContentEditable) => {
    const keyboardEventInit = {
      bubbles: true,
      cancelable: true,
      key: char,
      char,
      keyCode: char.charCodeAt(0),
      which: char.charCodeAt(0)
    };
    element.dispatchEvent(new KeyboardEvent('keydown', keyboardEventInit));
    element.dispatchEvent(new KeyboardEvent('keypress', keyboardEventInit));

    if (isContentEditable) {
      setCaretToEnd(element);
      const execSucceeded = document.execCommand && document.execCommand('insertText', false, char);
      if (!execSucceeded) {
        const selection = window.getSelection?.();
        const range = selection && selection.rangeCount ? selection.getRangeAt(0) : document.createRange();
        if (range) {
          range.deleteContents();
          const textNode = document.createTextNode(char);
          range.insertNode(textNode);
          range.setStartAfter(textNode);
          range.setEndAfter(textNode);
          selection?.removeAllRanges();
          selection?.addRange(range);
        }
      }
    } else if ('value' in element) {
      const start = element.selectionStart ?? element.value.length;
      const end = element.selectionEnd ?? element.value.length;
      const newValue = `${element.value.slice(0, start)}${char}${element.value.slice(end)}`;
      element.value = newValue;
      element.selectionStart = element.selectionEnd = start + 1;
    }

    dispatchInputEvent(element, char);
    element.dispatchEvent(new KeyboardEvent('keyup', keyboardEventInit));
  };

  const humanoid = {
    async lookAt(target) {
      const element = ensureElement(target);
      await scrollIntoViewSmoothly(element);
      await sleep(randomBetween(180, 320));
    },

    async moveTo(target) {
      const element = ensureElement(target);
      await this.lookAt(element);
      dispatchMouseEvent(element, 'mouseover');
      await sleep(randomBetween(60, 140));
    },

    async humanScroll(distance, options = {}) {
      const target = options.targetNode?.element || options.targetNode || window;
      try {
        if (mouseSimulator) {
          await mouseSimulator.scrollWithMouse(distance);
          return true;
        }
      } catch (err) {
        console.warn('[Humanoid] humanScroll via MouseSimulator failed, continue', err);
      }
      try {
        const toolkit = getScrollToolkit();
        if (toolkit?.humanScrollBy) {
          await toolkit.humanScrollBy(distance, Object.assign({ settle: true }, options));
          return true;
        }
      } catch (err) {
        console.warn('[Humanoid] humanScroll via ScrollToolkit failed, fallback', err);
      }

      if (target && typeof target.scrollBy === 'function') {
        try {
          target.scrollBy({ top: distance, behavior: 'smooth' });
        } catch (_) {
          target.scrollTop += distance;
        }
      } else {
        window.scrollBy({ top: distance, behavior: 'smooth' });
      }
      await sleep(Math.min(Math.max(Math.abs(distance) * 0.4, 120), 600));
      return false;
    },

    async click(target) {
      const element = ensureElement(target);
      await this.moveTo(element);
      dispatchMouseEvent(element, 'mousedown');
      await sleep(randomBetween(30, 90));
      dispatchMouseEvent(element, 'mouseup');
      element.click();
      await sleep(randomBetween(90, 180));
    },

    async typeText(target, text, options = {}) {
      const element = ensureElement(target);
      const wpm = Number.isFinite(options.wpm) ? Math.max(20, options.wpm) : 120;
      const averageMsPerChar = (60000 / (wpm * 5)) * randomBetween(0.9, 1.1);
      /*.  Включаем выключаем печать посимвольно */
      /* const useInstantMode = options.instant === true || options.mode === 'instant';*/
      //-- 1.1. Принудительно вставлять весь текст целиком (instant mode) --//
      const useInstantMode = true;


      
      const isContentEditable = element.isContentEditable || element.getAttribute?.('contenteditable') === 'true';

      await this.lookAt(element);
      await this.click(element);

      if (!isContentEditable && 'value' in element) {
        element.value = '';
        dispatchInputEvent(element, '', 'deleteContentBackward');
      } else if (!isContentEditable) {
        element.textContent = '';
        dispatchInputEvent(element, '', 'deleteContentBackward');
      }

      if (useInstantMode) {
        if (isContentEditable) {
          replaceContentEditableText(element, text);
        } else if ('value' in element) {
          const normalized = sanitizeValue(text);
          element.value = normalized;
          element.selectionStart = element.selectionEnd = element.value.length;
          dispatchInputEvent(element, normalized, 'insertFromPaste');
          element.dispatchEvent(new Event('change', { bubbles: true }));
        } else {
          const normalized = sanitizeValue(text);
          element.textContent = normalized;
          dispatchInputEvent(element, normalized, 'insertFromPaste');
          element.dispatchEvent(new Event('change', { bubbles: true }));
        }
        await sleep(randomBetween(120, 220));
        if (readElementValue(element).trim().length) {
          return;
        }
        console.warn('[Humanoid:typeText] Instant insertion empty, falling back to manual typing');
      }

      for (const char of String(text)) {
        await typeCharacter(element, char, isContentEditable);
        const jitter = randomBetween(-averageMsPerChar * 0.2, averageMsPerChar * 0.2);
        await sleep(Math.max(30, averageMsPerChar + jitter));
      }
      await sleep(randomBetween(120, 220));
    },

    async readPage(durationMs = 1500) {
      const end = Date.now() + durationMs;
      while (Date.now() < end) {
        const direction = Math.random() > 0.5 ? 1 : -1;
        const distance = randomBetween(150, 450) * direction;
        window.scrollBy({ top: distance, behavior: 'smooth' });
        await sleep(randomBetween(180, 320));
      }
      await sleep(randomBetween(150, 280));
    }
  };

  globalObject.Humanoid = humanoid;

})();

;
/**
 * UniversalScrollToolkit v2.0 - Production-Ready (Nov 2025)
 * Единый модуль для всех LLM-платформ (GPT, Claude, Gemini, Grok, etc.)
 * Скомпоновано в ES5-совместимом виде для прямой загрузки в content scripts.
 */

const __scrollToolkitKeepAlive = (() => {
  if (typeof window === 'undefined') return () => {};
  let traceId = null;
  let stopTimer = null;
  const mode = () => (document?.visibilityState === 'hidden' ? 'background' : (window.__humanoidActivityMode || 'interactive'));
  return (meta = {}) => {
    const events = window.HumanoidEvents;
    if (!events) return;
    try {
      if (!traceId && typeof events.start === 'function') {
        traceId = events.start('keep-alive', { mode: mode(), source: 'scroll-toolkit' });
      }
      if (traceId && typeof events.heartbeat === 'function') {
        events.heartbeat(traceId, 0, Object.assign({ action: 'keep-alive-ping', source: 'scroll-toolkit' }, meta));
      }
      if (stopTimer) clearTimeout(stopTimer);
      stopTimer = setTimeout(() => {
        if (traceId && typeof events.stop === 'function') {
          events.stop(traceId, { status: 'idle', source: 'scroll-toolkit' });
        }
        traceId = null;
        stopTimer = null;
      }, 5000);
    } catch (_) {}
  };
})();

// ============================================================================//
// StickyCalculator
// ============================================================================//
class StickyCalculator {
  constructor(maxElements = 50) {
    this.cache = new WeakMap();
    this.maxElements = maxElements;
  }

  async compute(container) {
    const cacheKey = container === window ? document.documentElement : container;
    if (this.cache.has(cacheKey)) {
      const cached = this.cache.get(cacheKey);
      return { top: cached, bottom: 0 };
    }

    const isWindow = container === window;
    const root = isWindow ? document.documentElement : container;
    const stickies = this._findVisibleSticky(root, isWindow);

    let topOffset = 0;
    let bottomOffset = 0;
    for (const el of stickies.slice(0, this.maxElements)) {
      const rect = el.getBoundingClientRect();
      const style = getComputedStyle(el);
      if (rect.height === 0) continue;
      if (style.position === 'fixed' || style.position === 'sticky') {
        if (rect.top < 100) topOffset = Math.max(topOffset, rect.bottom);
        if (rect.bottom > window.innerHeight - 100) {
          bottomOffset = Math.max(bottomOffset, window.innerHeight - rect.top);
        }
      }
    }

    this.cache.set(cacheKey, topOffset);
    return { top: topOffset, bottom: bottomOffset };
  }

  _findVisibleSticky(root, isWindow) {
    const results = [];
    const walker = document.createTreeWalker(
      root,
      NodeFilter.SHOW_ELEMENT,
      {
        acceptNode: (node) => {
          if (results.length >= this.maxElements) return NodeFilter.FILTER_REJECT;
          const el = node;
          const style = getComputedStyle(el);
          if (!['fixed', 'sticky'].includes(style.position)) return NodeFilter.FILTER_SKIP;
          const rect = el.getBoundingClientRect();
          if (rect.height === 0 || rect.width === 0) return NodeFilter.FILTER_SKIP;
          if (!isWindow && !this._belongsToContainer(el, root)) return NodeFilter.FILTER_SKIP;
          return NodeFilter.FILTER_ACCEPT;
        }
      }
    );
    let node;
    while ((node = walker.nextNode()) && results.length < this.maxElements) {
      results.push(node);
    }
    return results;
  }

  _belongsToContainer(el, container) {
    let parent = el;
    while (parent && parent !== document.body) {
      if (parent === container) return true;
      parent = parent.parentElement;
    }
    return false;
  }

  invalidate(container) {
    if (container) this.cache.delete(container);
    else this.cache = new WeakMap();
  }
}

// ============================================================================//
// SecureTelemetry (opt-in debug batching)
// ============================================================================//
class SecureTelemetry {
  constructor() {
    this.buffer = [];
    this.lastFlush = Date.now();
    this.config = {
      maxBufferSize: 50,
      flushInterval: 60000 // 60s
    };
    this._bindLifecycle();
    this._startTimer();
  }

  isDebug() {
    try {
      return typeof localStorage !== 'undefined' && localStorage.getItem('__debug_telemetry') === 'true';
    } catch (_) {
      return false;
    }
  }

  sanitize(data) {
    const clean = Object.assign({}, data);
    delete clean.content;
    delete clean.text;
    delete clean.value;
    if (clean.selector && clean.selector.length > 100) {
      clean.selector = `${clean.selector.slice(0, 100)}...`;
    }
    return clean;
  }

  log(event, data) {
    if (!this.isDebug()) return;
    const sanitized = this.sanitize({ event, ts: Date.now(), ...data });
    this.buffer.push(sanitized);
    if (this.buffer.length >= this.config.maxBufferSize) {
      this.flush();
    }
  }

  flush() {
    if (!this.isDebug()) {
      this.buffer = [];
      this.lastFlush = Date.now();
      return;
    }
    if (!this.buffer.length) return;
    try {
      console.debug('[Telemetry][batch]', this.buffer);
      if (typeof chrome !== 'undefined' && chrome.runtime) {
        chrome.runtime.sendMessage({
          type: 'TELEMETRY_BATCH',
          data: this.buffer.slice(),
          sessionId: `telemetry-${this.lastFlush}`
        }).catch(() => {});
      }
    } catch (_) {
      // ignore
    } finally {
      this.buffer = [];
      this.lastFlush = Date.now();
    }
  }

  _bindLifecycle() {
    if (typeof window === 'undefined') return;
    ['pagehide', 'visibilitychange', 'beforeunload'].forEach((evt) => {
      window.addEventListener(evt, () => this.flush(), { passive: true });
    });
  }

  _startTimer() {
    setInterval(() => this.flush(), this.config.flushInterval);
  }
}

const secureTelemetry = new SecureTelemetry();

// ============================================================================//
// ScrollCoordinator - shared SmartScroll orchestrator
// ============================================================================//
class ScrollCoordinator {
  constructor(config = {}) {
    this.config = Object.assign({
      source: 'smart-scroll',
      keepAliveInterval: 2000,
      operationTimeout: 300000,
      logPrefix: '[SmartScroll]',
      getLifecycleMode: () => (document?.visibilityState === 'hidden' ? 'background' : 'interactive'),
      registerForceStopHandler: () => () => {},
      startDrift: () => {},
      stopDrift: () => {},
      emitLog: () => {}
    }, config);
  }

  async run(asyncOperation, overrides = {}) {
    const {
      keepAliveInterval = this.config.keepAliveInterval,
      operationTimeout = this.config.operationTimeout,
      debug = false
    } = overrides;

    const log = (...args) => {
      if (debug) {
        console.log(this.config.logPrefix, ...args);
      } else if (typeof this.config.emitLog === 'function') {
        this.config.emitLog(...args);
      }
    };

    const heartbeatSource = this.config.source || 'smart-scroll';
    const events = typeof window !== 'undefined' ? window.HumanoidEvents : null;
    const mode = typeof this.config.getLifecycleMode === 'function'
      ? this.config.getLifecycleMode()
      : (document?.visibilityState === 'hidden' ? 'background' : 'interactive');
    const traceId = events?.start
      ? events.start(heartbeatSource, { mode, keepAliveInterval, timeout: operationTimeout })
      : null;

    let intervalId = null;
    let timeoutId = null;
    let cleaned = false;
    let active = true;
    let unregisterForceStop = null;
    let forceStopReject = null;
    let scrollDirection = 1;
    let scrollAnimating = false;

    const heartbeat = (meta = {}) => {
      if (!traceId || !events?.heartbeat) return;
      try {
        events.heartbeat(traceId, 0, Object.assign({ phase: 'tick', source: heartbeatSource }, meta));
      } catch (_) {}
    };

    const cleanup = (reason = 'success') => {
      if (cleaned) return;
      cleaned = true;
      active = false;
      try { this.config.stopDrift(reason); } catch (_) {}
      if (intervalId) {
        clearInterval(intervalId);
        intervalId = null;
      }
      if (timeoutId) {
        clearTimeout(timeoutId);
        timeoutId = null;
      }
      if (typeof unregisterForceStop === 'function') {
        try { unregisterForceStop(); } catch (_) {}
        unregisterForceStop = null;
      }
      if (traceId && events?.stop) {
        const status = reason === 'force-stop'
          ? 'forced'
          : reason === 'error'
            ? 'error'
            : reason === 'timeout'
              ? 'timeout'
              : 'success';
        try {
          events.stop(traceId, { status, reason, source: heartbeatSource });
        } catch (_) {}
      }
      log('stopped:', reason);
    };

    const smoothDriftTo = (targetY, durationMs = 720) => new Promise((resolve) => {
      const startY = window.scrollY;
      const delta = targetY - startY;
      if (Math.abs(delta) < 1) {
        resolve();
        return;
      }
      const duration = Math.max(400, durationMs + (Math.random() * 240 - 120));
      let startTs = null;
      const ease = (t) => (t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t);
      const step = (ts) => {
        if (!startTs) startTs = ts;
        const t = Math.min(1, (ts - startTs) / duration);
        const eased = ease(t);
        const nextY = Math.round(startY + delta * eased);
        window.scrollTo({ top: nextY, behavior: 'auto' });
        if (t < 1 && active) {
          requestAnimationFrame(step);
        } else {
          resolve();
        }
      };
      requestAnimationFrame(step);
    });

    const EDGE_MARGIN = 120;
    const MIN_DELTA = 8;
    const scrollTick = () => {
      if (scrollAnimating) return;
      try {
        const doc = document.documentElement || document.body;
        const maxScroll = Math.max(0, (doc?.scrollHeight ?? document.body.scrollHeight) - window.innerHeight);
        if (maxScroll <= EDGE_MARGIN * 2) {
          this.config.startDrift('limited');
          return;
        }
        const minY = EDGE_MARGIN;
        const maxY = Math.max(minY, maxScroll - EDGE_MARGIN);
        const baseStep = Math.max(MIN_DELTA, Math.round(window.innerHeight * 0.12));
        const delta = Math.min(Math.max(baseStep, Math.round(maxScroll * 0.01)), Math.round(window.innerHeight * 0.25));
        let next = window.scrollY + scrollDirection * delta;
        if (next < minY || next > maxY) {
          scrollDirection *= -1;
          next = window.scrollY + scrollDirection * delta;
        }
        next = Math.max(minY, Math.min(maxY, next));
        if (Math.abs(next - window.scrollY) < 1) {
          scrollDirection *= -1;
          next = Math.max(minY, Math.min(maxY, window.scrollY + scrollDirection * delta));
        }
        scrollAnimating = true;
        smoothDriftTo(next).finally(() => {
          scrollAnimating = false;
        });
      } catch (err) {
        log('scrollTick failed', err);
      }
    };

    const tick = () => {
      if (!active) return;
      if (document.hidden) {
        try {
          this.config.startDrift('hidden');
          // force layout
          document.body.offsetHeight;
          heartbeat({ phase: 'tick-hidden', scrollY: window.scrollY });
          log('tick-hidden', window.scrollY);
        } catch (_) {}
      } else {
        try { this.config.stopDrift('visible'); } catch (_) {}
        scrollTick();
        heartbeat({ phase: 'tick-visible', scrollY: window.scrollY });
        log('tick-visible', window.scrollY);
      }
    };

    const timeoutPromise = new Promise((_, rej) => {
      timeoutId = setTimeout(() => {
        const err = new Error(`Timeout ${operationTimeout}ms`);
        err.code = 'smart-scroll-timeout';
        rej(err);
      }, operationTimeout);
    });

    let forceStopPromise = Promise.resolve();
    if (typeof this.config.registerForceStopHandler === 'function') {
      forceStopPromise = new Promise((_, reject) => { forceStopReject = reject; });
      unregisterForceStop = this.config.registerForceStopHandler(() => {
        if (typeof forceStopReject === 'function') {
          const err = new Error('background-force-stop');
          err.code = 'background-force-stop';
          forceStopReject(err);
        }
      });
    }

    try {
      heartbeat({ phase: 'init' });
      intervalId = setInterval(tick, keepAliveInterval);
      const result = await Promise.race([asyncOperation(), timeoutPromise, forceStopPromise]);
      cleanup('success');
      return result;
    } catch (error) {
      if (error?.code === 'background-force-stop') {
        cleanup('force-stop');
      } else if (error?.code === 'smart-scroll-timeout') {
        cleanup('timeout');
      } else {
        cleanup('error');
      }
      throw error;
    } finally {
      cleanup('finalize');
    }
  }
}

const globalRef = typeof globalThis !== 'undefined'
  ? globalThis
  : (typeof window !== 'undefined' ? window : undefined);

if (globalRef) {
  globalRef.ScrollCoordinator = ScrollCoordinator;
}

if (typeof module !== 'undefined' && module.exports) {
  module.exports = ScrollCoordinator;
}

// ============================================================================//
// VirtualizationHandler
// ============================================================================//
class VirtualizationHandler {
  async detect(target) {
    const el = target.element === window ? document.documentElement : target.element;
    const fiberCtrl = this._findFiberController(el);
    if (fiberCtrl) return fiberCtrl;
    const domCtrl = this._findDomController(el);
    if (domCtrl) return domCtrl;
    const devtoolsCtrl = this._findDevToolsController();
    if (devtoolsCtrl) return devtoolsCtrl;
    const adapterCtrl = this._findAdapterController(el);
    if (adapterCtrl) return adapterCtrl;
    const globalCtrl = this._findGlobalOrCustomController(el);
    if (globalCtrl) return globalCtrl;
    return null;
  }

  _findFiberController(el) {
    const fiber = this._getFiber(el);
    if (!fiber) return null;
    const checkProps = (props) => {
      if (!props) return null;
      if (props.scrollToItem || props.scrollToIndex || props.scrollToOffset || props.scrollTo) {
        const method = props.scrollToItem || props.scrollToIndex || props.scrollToOffset || props.scrollTo;
        return {
          type: 'fiber',
          scrollToEnd: () => {
            try { method.call(null, Infinity); } catch (_) { method.call(null, 999999); }
          },
          scrollByItems: (count) => {
            if (props.scrollToIndex) {
              const cur = props.overscanStartIndex || props.startIndex || 0;
              props.scrollToIndex(cur + count);
            }
          }
        };
      }
      return null;
    };
    let current = fiber;
    while (current) {
      const props = current.memoizedProps || current.pendingProps;
      const ctrl = checkProps(props);
      if (ctrl) return ctrl;
      current = current.return;
    }
    // fallback: смотрим в owner (родительский fiber с memoizedProps.children)
    current = fiber.return;
    while (current) {
      const props = current.memoizedProps || current.pendingProps;
      if (props && props.children && typeof props.children === 'object') {
        const ctrl = checkProps(props.children.props || props.children);
        if (ctrl) return ctrl;
      }
      current = current.return;
    }
    return null;
  }

  _getFiber(el) {
    for (const key in el) {
      if (key.startsWith('__reactFiber') || key.startsWith('__reactInternalInstance')) {
        return el[key];
      }
    }
    const hook = window.__REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (hook && hook.getFiberRoots) {
      try {
        const roots = Array.from(hook.getFiberRoots(1));
        for (const root of roots) {
          const fiber = this._findFiberByDOMNode(root.current, el);
          if (fiber) return fiber;
        }
      } catch (_) {}
    }
    return null;
  }

  _findFiberByDOMNode(fiber, target) {
    if (!fiber) return null;
    if (fiber.stateNode === target) return fiber;
    let child = fiber.child;
    while (child) {
      const result = this._findFiberByDOMNode(child, target);
      if (result) return result;
      child = child.sibling;
    }
    return null;
  }

  _findDomController(el) {
    if (typeof el.scrollToItem === 'function') {
      return { type: 'dom-api', scrollToEnd: () => el.scrollToItem(Infinity) };
    }
    if (el.dataset && el.dataset.virtualList) {
      const ref = window[el.dataset.virtualList];
      if (ref && typeof ref.scrollToIndex === 'function') {
        return { type: 'dom-api', scrollToEnd: () => ref.scrollToIndex(Infinity) };
      }
    }
    return null;
  }

  _findDevToolsController() {
    const directCandidates = ['listRef', 'virtualListRef', 'scrollerRef'];
    for (const key of directCandidates) {
      const ctrl = this._extractControllerMethods(window[key], key);
      if (ctrl) return ctrl;
    }

    try {
      const keys = Object.getOwnPropertyNames(window).slice(0, 2000);
      for (const key of keys) {
        if (!/[Rr]ef|list|virtual|scroll/i.test(key)) continue;
        const ctrl = this._extractControllerMethods(window[key], key);
        if (ctrl) return ctrl;
      }
    } catch (_) {}
    return null;
  }

  _findAdapterController(el) {
    const doc = (el && el.ownerDocument) || document;

    // React-window / React-virtualized
    const reactWindowContainer = el && el.closest
      ? el.closest('[data-react-window-list],[data-test-id*="react-window"],.ReactVirtualized__Grid')
      : null;
    const reactWindow = reactWindowContainer || doc.querySelector('[data-react-window-list],[data-test-id*="react-window"],.ReactVirtualized__Grid');
    if (reactWindow || window.__REACT_WINDOW__) {
      const targetEl = reactWindow || el;
      return {
        type: 'adapter/react-window',
        element: targetEl,
        scrollToEnd: () => {
          try {
            targetEl.scrollTo({ top: Number.MAX_SAFE_INTEGER, behavior: 'auto' });
          } catch (_) {
            targetEl.scrollTop = targetEl.scrollHeight || Number.MAX_SAFE_INTEGER;
          }
        }
      };
    }

    // TanStack virtual (data-index pattern)
    const dataIndexNode = doc.querySelector('[data-index]');
    if (dataIndexNode) {
      const container = dataIndexNode.parentElement || el;
      return {
        type: 'adapter/tanstack-virtual',
        element: container,
        scrollToEnd: () => {
          try {
            container.scrollTo({ top: Number.MAX_SAFE_INTEGER, behavior: 'auto' });
          } catch (_) {
            container.scrollTop = (container.scrollHeight || 0) + 2000;
          }
        }
      };
    }

    // Virtuoso
    const virtuosoNode = doc.querySelector('[data-test-id*="virtuoso"],[class*="virtuoso"]');
    if (virtuosoNode) {
      const scroller = virtuosoNode.querySelector('[data-test-id*="virtuoso-scroller"]') || virtuosoNode;
      return {
        type: 'adapter/virtuoso',
        element: scroller,
        scrollToEnd: () => {
          try {
            scroller.scrollTo({ top: Number.MAX_SAFE_INTEGER, behavior: 'auto' });
          } catch (_) {
            scroller.scrollTop = (scroller.scrollHeight || 0) + 2000;
          }
        }
      };
    }

    const attrVirtual = doc.querySelector('[data-virtualized],[data-virtual-scroll],[data-virtual-list],[data-recycle-list],[data-infinite-scroll]');
    if (attrVirtual) {
      const container = attrVirtual.closest('[data-scroll-container]') || attrVirtual.parentElement || el;
      return this._buildHeuristicController(container, 'adapter/data-virtual');
    }

    const classVirtual = doc.querySelector('[class*="Virtualized"],[class*="virtualized"],[class*="recycle-list"],[class*="RecycleList"],[class*="InfiniteScroller"],[class*="virtual-scroller"]');
    if (classVirtual) {
      const container = classVirtual.closest('[data-scroll-container]') || classVirtual.parentElement || el;
      return this._buildHeuristicController(container, 'adapter/class-virtual');
    }

    const items = Array.from(doc.querySelectorAll('[data-index],[data-idx],[role="row"],[role="option"]'));
    if (items.length > 20) {
      const heights = new Set(items.slice(0, 80).map((n) => n.getBoundingClientRect().height.toFixed(1)));
      if (heights.size > 0 && heights.size <= 10) {
        const container = items[0].parentElement || el;
        return this._buildHeuristicController(container, 'adapter/heuristic');
      }
    }
    return null;
  }

  _extractControllerMethods(ref, label = 'custom-ref') {
    if (!ref) return null;
    const target = ref.current || ref;
    if (!target) return null;
    const methodMap = [
      { key: 'scrollToItem', invoke: (fn) => fn.call(target, Infinity) },
      { key: 'scrollToIndex', invoke: (fn) => fn.call(target, Infinity) },
      { key: 'scrollToOffset', invoke: (fn) => fn.call(target, Number.MAX_SAFE_INTEGER) },
      { key: 'scrollTo', invoke: (fn) => fn.call(target, Number.MAX_SAFE_INTEGER) },
      { key: 'scrollToRow', invoke: (fn) => fn.call(target, Infinity) }
    ];
    for (const entry of methodMap) {
      const fn = target[entry.key];
      if (typeof fn === 'function') {
        return {
          type: `devtools:${label}`,
          scrollToEnd: () => {
            try { entry.invoke(fn); } catch (_) { fn.call(target, { top: Number.MAX_SAFE_INTEGER }); }
          }
        };
      }
    }
    if (typeof target.scrollTop === 'number' && typeof target.scrollHeight === 'number') {
      return {
        type: `devtools:${label}:element`,
        scrollToEnd: () => {
          target.scrollTop = target.scrollHeight || Number.MAX_SAFE_INTEGER;
        }
      };
    }
    return null;
  }

  _buildHeuristicController(container, type) {
    const targetEl = container || document.documentElement;
    return {
      type,
      element: targetEl,
      scrollToEnd: () => {
        try {
          targetEl.scrollTo({ top: Number.MAX_SAFE_INTEGER, behavior: 'auto' });
        } catch (_) {
          targetEl.scrollTop = (targetEl.scrollHeight || 0) + 2000;
        }
      }
    };
  }

  _extractControllerMethods(obj) {
    if (!obj) return null;
    if (typeof obj.scrollToIndex === 'function') {
      return { type: 'global', scrollToEnd: () => obj.scrollToIndex(Number.MAX_SAFE_INTEGER) };
    }
    if (typeof obj.scrollToItem === 'function') {
      return { type: 'global', scrollToEnd: () => obj.scrollToItem(Number.MAX_SAFE_INTEGER) };
    }
    if (typeof obj.scrollToBottom === 'function') {
      return { type: 'global', scrollToEnd: () => obj.scrollToBottom() };
    }
    if (typeof obj.scrollTo === 'function') {
      return { type: 'global', scrollToEnd: () => obj.scrollTo({ top: Number.MAX_SAFE_INTEGER }) };
    }
    if (obj.current) {
      return this._extractControllerMethods(obj.current);
    }
    return null;
  }

  _findGlobalOrCustomController(element) {
    const customProps = ['_virtualList', '__vue_app__', '$scroller', 'simplebar', 'lenis', 'locomotive', 'overlayscrollbars'];
    for (const prop of customProps) {
      if (element && element[prop]) {
        const c = this._extractControllerMethods(element[prop]);
        if (c) return c;
      }
    }
    if (element && element.id && window[element.id]) {
      const c = this._extractControllerMethods(window[element.id]);
      if (c) return c;
    }
    return null;
  }
}

// ============================================================================//
// SettlementWatcher
// ============================================================================//
class SettlementWatcher {
  constructor(idleThreshold = 1500) {
    this.idleThreshold = idleThreshold;
    this.abortController = undefined;
  }

  async watch(container, sentinel, maxDuration) {
    this.abortController = new AbortController();
    const signal = this.abortController.signal;
    let mutations = 0;
    let idleTimer;
    const startTime = Date.now();

    return new Promise((resolve) => {
      const mutationObs = new MutationObserver((muts) => {
        if (signal.aborted) return;
        mutations += muts.length;
        clearTimeout(idleTimer);
        idleTimer = setTimeout(() => checkSettlement(), this.idleThreshold);
      });
      mutationObs.observe(container, { childList: true, subtree: true, characterData: true });

      let sentinelVisible = false;
      const ioObs = new IntersectionObserver((entries) => {
        if (signal.aborted) return;
        sentinelVisible = entries.some((e) => e.isIntersecting && e.intersectionRatio > 0.5);
      });
      ioObs.observe(sentinel);

      const deadlineTimer = setTimeout(() => {
        cleanup();
        resolve({
          settled: false,
          reason: 'timeout',
          mutations,
          sentinelVisible,
          duration: Date.now() - startTime
        });
      }, maxDuration);

      const checkSettlement = () => {
        if (signal.aborted) return;
        if (sentinelVisible) {
          cleanup();
          resolve({
            settled: true,
            reason: 'idle+sentinel',
            mutations,
            sentinelVisible: true,
            duration: Date.now() - startTime
          });
        }
      };

      const cleanup = () => {
        mutationObs.disconnect();
        ioObs.disconnect();
        clearTimeout(idleTimer);
        clearTimeout(deadlineTimer);
      };

      signal.addEventListener('abort', () => {
        cleanup();
        resolve({
          settled: false,
          reason: 'manual-abort',
          mutations,
          sentinelVisible,
          duration: Date.now() - startTime
        });
      });

      idleTimer = setTimeout(checkSettlement, this.idleThreshold);
    });
  }

  abort() {
    this.abortController && this.abortController.abort();
  }
}

// ============================================================================//
// DriftEngine
// ============================================================================//
class DriftEngine {
  constructor(stepMs = 50, emitWheel = true) {
    this.stepMs = stepMs;
    this.emitWheel = emitWheel;
    this.abortController = undefined;
  }

  async scrollTo(target, targetY, stickyOffset = 0) {
    this.abortController = new AbortController();
    const signal = this.abortController.signal;
    const el = target.element === window ? window : target.element;
    const getCurrentScroll = () => (el === window ? window.scrollY : el.scrollTop);
    const setScroll = (y) => {
      if (el === window) window.scrollTo(0, y);
      else el.scrollTop = y;
    };

    const start = getCurrentScroll();
    const end = Math.max(0, targetY - stickyOffset);
    const distance = end - start;
    if (Math.abs(distance) < 10) return;

    const startTime = performance.now();
    const duration = Math.min(Math.abs(distance) * 0.5, 2000);

    return new Promise((resolve) => {
      const animate = (currentTime) => {
        if (signal.aborted) {
          resolve();
          return;
        }
        const elapsed = currentTime - startTime;
        const progress = Math.min(elapsed / duration, 1);
        const eased = progress < 0.5
          ? 4 * progress * progress * progress
          : 1 - Math.pow(-2 * progress + 2, 3) / 2;

        const current = start + distance * eased;
        setScroll(current);

        if (this.emitWheel && elapsed % 100 < this.stepMs) {
          const wheelEvent = new WheelEvent('wheel', {
            deltaY: distance > 0 ? 120 : -120,
            deltaMode: 0,
            bubbles: true,
            cancelable: true
          });
          const targetEl = el === window ? document.documentElement : el;
          targetEl.dispatchEvent(wheelEvent);
        }

        if (progress < 1) {
          requestAnimationFrame(animate);
        } else {
          resolve();
        }
      };
      requestAnimationFrame(animate);
    });
  }

  abort() {
    this.abortController && this.abortController.abort();
  }
}

// ============================================================================//
// ContainerDetector
// ============================================================================//
class ContainerDetector {
  constructor(config = {}) {
    this.config = {
      maxShadowDepth: typeof config.maxShadowDepth === 'number' ? config.maxShadowDepth : 5,
      maxIframeDepth: typeof config.maxIframeDepth === 'number' ? config.maxIframeDepth : 2,
      logBreadcrumbs: config.logBreadcrumbs !== false
    };
    this.answerSelectors = [
      '[data-testid=\"conversation-turn\"]',
      'main article',
      'article',
      '[class*=\"response\"]',
      '.chat-message',
      '.prose',
      '.answer',
      '.assistant-message'
    ];
  }

  _findRecentAnswer() {
    const nodes = Array.from(document.querySelectorAll(this.answerSelectors.join(',')))
      .filter((el) => (el.innerText || el.textContent || '').trim().length > 20);
    return nodes.length ? nodes[nodes.length - 1] : null;
  }

  _collectShadowScrollable(root, depth = 0, maxDepth = this.config.maxShadowDepth || 5, acc = []) {
    if (!root || depth > maxDepth) return;
    const list = root.querySelectorAll('*');
    list.forEach((el) => {
      if (this._isScrollable(el)) {
        acc.push({
          element: el,
          type: 'container',
          selector: 'shadow-scrollable',
          isVirtualized: this._hasVirtualHints(el)
        });
      }
      if (el.shadowRoot) {
        this._collectShadowScrollable(el.shadowRoot, depth + 1, maxDepth, acc);
      }
    });
    return acc;
  }

  findScrollable(hint) {
    const candidates = [];

    const seed = hint || this._findRecentAnswer();

    const tryPush = (el, selectorHint) => {
      candidates.push({
        element: el,
        type: el === window ? 'window' : 'container',
        selector: selectorHint || this._getSelector(el),
        isVirtualized: this._hasVirtualHints(el)
      });
    };

    // 1) От seed вверх по родителям
    if (seed) {
      let parent = seed instanceof Element ? seed : null;
      let depth = 0;
      while (parent && parent !== document.body && depth < 8) {
        if (this._isScrollable(parent) && parent.contains(seed)) {
          tryPush(parent);
        }
        parent = parent.parentElement;
        depth += 1;
      }
    }

    // 2) ShadowRoot shallow scan вокруг seed
    if (seed && seed.getRootNode && seed.getRootNode() instanceof ShadowRoot) {
      const host = seed.getRootNode().host;
      if (host && this._isScrollable(host)) {
        tryPush(host, 'shadow-host');
      }
      if (host && host.parentElement && this._isScrollable(host.parentElement)) {
        tryPush(host.parentElement, 'shadow-host-parent');
      }
      this._collectShadowScrollable(seed.getRootNode(), 0, Math.min(1, this.config.maxShadowDepth), candidates);
    }

    // 3) Известные селекторы
    const knownSelectors = [
      'main[class*=\"conversation\"]',
      'div[class*=\"thread\"]',
      'div[class*=\"messages\"]',
      '[role=\"main\"]',
      'div.overflow-y-auto',
      'div.overflow-y-scroll'
    ];

    for (const sel of knownSelectors) {
      document.querySelectorAll(sel).forEach((el) => {
        if (this._isScrollable(el)) {
          tryPush(el, sel);
        }
      });
    }

    // 3.1) Глобальный shadow scan документа (shallow)
    this._collectShadowScrollable(document, 0, Math.min(2, this.config.maxShadowDepth), candidates);

    this._scanIframeDocuments(document, 0, this.config.maxIframeDepth || 2, candidates, 'document');

    if (!candidates.length) {
      tryPush(window, 'window');
    }
    return candidates;
  }

  _scanIframeDocuments(doc, depth, maxDepth, acc, breadcrumb) {
    if (!doc || depth > maxDepth) return;
    const frames = doc.querySelectorAll('iframe');
    frames.forEach((frame, index) => {
      const label = `${breadcrumb}>iframe[${index}]`;
      try {
        const frameDoc = frame.contentWindow?.document;
        if (!frameDoc || !frameDoc.body) return;
        const scrollEl = frameDoc.scrollingElement || frameDoc.documentElement;
        if (scrollEl && this._isScrollable(scrollEl)) {
          acc.push({
            element: scrollEl,
            type: 'container',
            selector: label,
            isVirtualized: this._hasVirtualHints(scrollEl)
          });
        }
        const nextDepth = depth + 1;
        if (nextDepth > maxDepth) {
          if (this.config.logBreadcrumbs) {
            console.warn(`[ContainerDetector] iframe depth limit reached at ${label}`);
          }
          return;
        }
        const shadowDepth = Math.min(this.config.maxShadowDepth || 5, nextDepth + 1);
        this._collectShadowScrollable(frameDoc, 0, shadowDepth, acc);
        this._scanIframeDocuments(frameDoc, nextDepth, maxDepth, acc, label);
      } catch (err) {
        if (this.config.logBreadcrumbs) {
          console.warn(`[ContainerDetector] iframe traversal blocked at ${label}`, err);
        }
      }
    });
  }

  _isScrollable(el) {
    const style = getComputedStyle(el);
    const hasOverflow = ['auto', 'scroll'].includes(style.overflowY);
    const hasContent = el.scrollHeight > el.clientHeight + 10;
    return hasOverflow && hasContent;
  }

  _hasVirtualHints(el) {
    const classList = el.className || '';
    const patterns = ['virtual', 'react-window', 'virtuoso', 'infinite-scroll'];
    return patterns.some((p) => classList.includes(p));
  }

  _getSelector(el) {
    if (el.id) return `#${el.id}`;
    if (el.className) return `${el.tagName.toLowerCase()}.${(el.className || '').split(' ')[0]}`;
    return el.tagName.toLowerCase();
  }
}

// ============================================================================//
// MetricsCollector
// ============================================================================//
class MetricsCollector {
  constructor() {
    this.entries = [];
  }

  startSession() {
    return {
      sessionId: `scroll-${Date.now()}-${Math.random().toString(36).slice(2, 9)}`,
      timestamp: Date.now(),
      target: { selector: '', type: '', scrollHeight: 0, clientHeight: 0 },
      sticky: { offsetTop: 0, offsetBottom: 0, elementsFound: 0 },
      virtual: { detected: false, attempts: 0 },
      settlement: { settled: false, reason: 'timeout', mutations: 0, sentinelVisible: false, duration: 0 },
      performance: { scanDurationMs: 0, scrollDurationMs: 0, totalDurationMs: 0 }
    };
  }

  async flush(entry) {
    this.entries.push(entry);
    secureTelemetry.log('scroll', entry);
    console.info(
      `[ScrollToolkit] ${entry.sessionId}: ${entry.settlement.settled ? '✓' : '✗'} ` +
      `${entry.performance.totalDurationMs}ms (${entry.settlement.reason})`
    );
  }

  getEntries() {
    return this.entries.slice();
  }
}

// ============================================================================//
// UniversalScrollToolkit
// ============================================================================//
class UniversalScrollToolkit {
  constructor(config = {}) {
    this.config = Object.assign({
      maxDuration: 30000,
      idleThreshold: 1500,
      maxStickyElements: 50,
      maxShadowDepth: 6,
      maxIframeDepth: 3,
      virtualRetries: 5,
      driftStepMs: 50,
      sentinelMargin: 100,
      wheelEventDelta: 120,
      logLevel: 'info',
      logBreadcrumbs: true
    }, config);

    this.containerDetector = new ContainerDetector({
      maxShadowDepth: this.config.maxShadowDepth,
      maxIframeDepth: this.config.maxIframeDepth,
      logBreadcrumbs: this.config.logBreadcrumbs
    });
    this.stickyCalc = new StickyCalculator(this.config.maxStickyElements);
    this.virtualHandler = new VirtualizationHandler();
    this.metrics = new MetricsCollector();
  }

  async scrollToBottom(options = {}) {
    const session = this.metrics.startSession();
    const startTime = performance.now();
    try {
      const scanStart = performance.now();
      const candidates = this.containerDetector.findScrollable(options.targetNode);
      const container = candidates[0];
      if (!container) throw new Error('No scrollable container found');

      session.target = {
        selector: container.selector || 'window',
        type: container.type,
        scrollHeight: this._getScrollHeight(container.element),
        clientHeight: this._getClientHeight(container.element)
      };
      session.performance.scanDurationMs = performance.now() - scanStart;

      const virtualCtrl = await this.virtualHandler.detect(container);
      session.virtual.detected = !!virtualCtrl;
      if (virtualCtrl) {
        session.virtual.method = virtualCtrl.type;
        return await this._handleVirtualized(container, virtualCtrl, session);
      }
      return await this._classicScroll(container, session);
    } catch (err) {
      console.error('[ScrollToolkit] Error:', err);
      return false;
    } finally {
      session.performance.totalDurationMs = performance.now() - startTime;
      await this.metrics.flush(session);
    }
  }

  async _handleVirtualized(container, ctrl, session) {
    const scrollStart = performance.now();
    const targetContainer = ctrl.element
      ? { element: ctrl.element, type: ctrl.element === window ? 'window' : 'container', isVirtualized: true }
      : container;
    try {
      await ctrl.scrollToEnd();
      await this._wait(300);
    } catch (e) {
      console.warn('[ScrollToolkit] Virtual API failed:', e);
    }

    const sentinel = this._injectSentinel(targetContainer);
    let visible = false;
    for (let i = 0; i < this.config.virtualRetries; i++) {
      session.virtual.attempts++;
      visible = this._isSentinelVisible(sentinel);
      if (visible) break;
      const drift = new DriftEngine(this.config.driftStepMs);
      const el = targetContainer.element === window ? window : targetContainer.element;
      const current = el === window ? window.scrollY : el.scrollTop;
      await drift.scrollTo(targetContainer, current + 500, 0);
      await this._wait(200);
    }
    this._removeSentinel(sentinel);
    session.settlement = {
      settled: visible,
      reason: visible ? 'idle+sentinel' : 'timeout',
      mutations: 0,
      sentinelVisible: visible,
      duration: performance.now() - scrollStart
    };
    session.performance.scrollDurationMs = performance.now() - scrollStart;
    return visible;
  }

  async _classicScroll(container, session) {
    const scrollStart = performance.now();
    const el = container.element === window ? window : container.element;
    const stickyOffsets = await this.stickyCalc.compute(el);
    session.sticky.offsetTop = stickyOffsets.top;
    session.sticky.offsetBottom = stickyOffsets.bottom;

    const scrollHeight = this._getScrollHeight(el);
    const clientHeight = this._getClientHeight(el);
    const targetY = scrollHeight - clientHeight;

    const sentinel = this._injectSentinel(container);
    const drift = new DriftEngine(this.config.driftStepMs);
    await drift.scrollTo(container, targetY, stickyOffsets.top);

    const containerEl = el === window ? document.documentElement : el;
    const watcher = new SettlementWatcher(this.config.idleThreshold);
    const result = await watcher.watch(containerEl, sentinel, this.config.maxDuration);
    this._removeSentinel(sentinel);

    session.settlement = result;
    session.performance.scrollDurationMs = performance.now() - scrollStart;
    return result.settled;
  }

  _injectSentinel(container) {
    const sentinel = document.createElement('div');
    sentinel.id = `scroll-sentinel-${Date.now()}`;
    sentinel.style.cssText = `
      position: absolute;
      bottom: ${this.config.sentinelMargin}px;
      height: 1px;
      width: 1px;
      pointer-events: none;
      opacity: 0;
    `;
    const target = container.type === 'window' ? document.body : container.element;
    target.appendChild(sentinel);
    return sentinel;
  }

  _isSentinelVisible(sentinel) {
    const rect = sentinel.getBoundingClientRect();
    return rect.top >= 0 && rect.top <= window.innerHeight;
  }

  _removeSentinel(sentinel) {
    if (sentinel && sentinel.parentNode) sentinel.parentNode.removeChild(sentinel);
  }

  _getScrollHeight(el) {
    return el === window ? document.documentElement.scrollHeight : el.scrollHeight;
  }

  _getClientHeight(el) {
    return el === window ? window.innerHeight : el.clientHeight;
  }

  _wait(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }

  async driftStep(distance = 20) {
    const drift = new DriftEngine(this.config.driftStepMs, false);
    await drift.scrollTo(
      { element: window, type: 'window', isVirtualized: false },
      window.scrollY + distance,
      0
    );
  }

  async scrollElementIntoView(element, options = {}) {
    if (!element || !(element instanceof Element)) return false;
    const container = this.containerDetector.findScrollable(element)[0] || { element: window, type: 'window', isVirtualized: false };
    const el = container.element === window ? window : container.element;
    const stickyOffsets = await this.stickyCalc.compute(el);
    const rect = element.getBoundingClientRect();
    const current = el === window ? window.scrollY : el.scrollTop;
    const targetY = current + rect.top - (options.offset || (stickyOffsets.top + 12));
    const drift = new DriftEngine(this.config.driftStepMs, true);
    await drift.scrollTo(container, targetY, stickyOffsets.top);
    if (options.settle) {
      await this.waitForSettlement(container, { maxDuration: options.maxDuration || 5000 });
    }
    return true;
  }

  async humanScrollBy(distance, options = {}) {
    const container = this.containerDetector.findScrollable(options.targetNode)[0] || { element: window, type: 'window', isVirtualized: false };
    const el = container.element === window ? window : container.element;
    const stickyOffsets = await this.stickyCalc.compute(el);
    const jitter = options.jitter ? ((Math.random() - 0.5) * Math.abs(distance) * 0.15) : 0;
    const totalDistance = distance + jitter;
    const base = el === window ? window.scrollY : el.scrollTop;
    const drift = new DriftEngine(this.config.driftStepMs, true);
    await drift.scrollTo(container, base + totalDistance, stickyOffsets.top);
    if (options.settle !== false) {
      await this.waitForSettlement(container, { maxDuration: options.settleTimeout || Math.min(this.config.maxDuration, 8000) });
    }
    return true;
  }

  async waitForSettlement(container, opts = {}) {
    const target = container || this.containerDetector.findScrollable(opts.targetNode)[0] || { element: window, type: 'window', isVirtualized: false };
    const targetEl = target.element === window ? document.documentElement : target.element;
    const sentinel = this._injectSentinel(target);
    const watcher = new SettlementWatcher(opts.idleThreshold || this.config.idleThreshold);
    const result = await watcher.watch(targetEl, sentinel, opts.maxDuration || Math.min(this.config.maxDuration, 8000));
    this._removeSentinel(sentinel);
    return result;
  }

  /**
   * Anti-sleep tick с событийным watcher: если sentinel уже виден и нет мутаций — скролл не делаем.
   */
  async keepAliveTick(distance = 16) {
    const target = { element: window, type: 'window', isVirtualized: false };
    __scrollToolkitKeepAlive({ phase: 'watcher-start', distance });
    const sentinel = this._injectSentinel(target);
    const watcher = new SettlementWatcher(Math.min(this.config.idleThreshold, 800));
    const containerEl = document.documentElement;
    const result = await watcher.watch(containerEl, sentinel, 4000);
    if (!result.settled) {
      const drift = new DriftEngine(this.config.driftStepMs, false);
      await drift.scrollTo(target, window.scrollY + distance, 0);
      __scrollToolkitKeepAlive({ phase: 'drift', distance });
    } else {
      __scrollToolkitKeepAlive({ phase: 'watcher-stable', distance: 0 });
    }
    this._removeSentinel(sentinel);
    return result;
  }

  invalidateCache() {
    this.stickyCalc.invalidate();
  }
}

if (typeof window !== 'undefined') {
  window.__UniversalScrollToolkit = UniversalScrollToolkit;
}

;
(function initAnswerPipelineConfig() {
  if (window.AnswerPipelineConfig) return;

  const CONFIG = {
    preparation: {
      tabActivationTimeout: 5000,
      streamStartTimeout: 45000,
      streamStartPollInterval: 100
    },
    streaming: {
      coordinationMode: 'balanced',
      adaptiveTimeout: {
        short: { maxChars: 500, timeout: 15000 },
        medium: { maxChars: 2000, timeout: 30000 },
        long: { maxChars: 5000, timeout: 60000 },
        veryLong: { maxChars: Infinity, timeout: 120000 },
        softExtension: 15000,
        hardMax: 120000
      },
      intelligentRetry: {
        enabled: true,
        maxRetries: 5,
        backoffSequence: [300, 600, 1200, 2000, 2000],
        noGrowthThreshold: 2
      },
      initialScrollKick: {
        enabled: true,
        delay: 0
      },
      settlementWatcher: {
        idleThreshold: 2000,
        maxDuration: 45000
      },
      completionCriteria: {
        completionSignalEnabled: true,
        mutationIdle: 1500,
        scrollStable: 2000,
        contentStable: 1500,
        minMetCriteria: 3,
        checkInterval: 500
      },
      continuousActivity: {
        enabled: true,
        interval: 5000,
        scrollRange: [50, 200],
        pauseBetweenMoves: 300
      },
      maintenanceScroll: {
        enabled: true,
        checkInterval: 3000,
        growthThreshold: 50,
        scrollStep: 120,
        idleThreshold: 5000,
        maxDuration: 20000
      }
    },
    finalization: {
      stabilityChecks: 3,
      stabilityInterval: 800,
      sanityCheck: {
        enabled: true,
        warnOnHardTimeout: true,
        warnOnActiveIndicators: true,
        recentGrowthWindow: 2000,
        recentGrowthThreshold: 10
      }
    },
    telemetry: {
      enabled: true,
      useTraceId: true,
      sendToBackground: true,
      consoleLog: false,
      sessionStorage: false,
      sessionStorageKey: '__answer_pipeline_telemetry'
    },
    platforms: {}
  };

  window.AnswerPipelineConfig = CONFIG;
})();

;
(function initPlatformSelectors() {
  if (window.AnswerPipelineSelectors) return;

  const PLATFORM_SELECTORS = {
    claude: {
      streamStart: [
        '[data-testid*="conversation"] > div:last-child',
        '[class*="font-claude-message"]',
        'div[data-testid="user-message"] + div'
      ],
      streaming: [
        '[data-test-render-count]',
        '[class*="streaming"]',
        '[class*="loading"]'
      ],
      spinner: [
        '.animate-spin',
        '[aria-busy="true"]',
        'svg[class*="animate-spin"]'
      ],
      stopButton: 'button[aria-label*="Stop"], button:has-text("Stop generating")',
      regenerateButton: 'button:has-text("Regenerate")',
      lastMessage: '[data-testid*="conversation"] > div:last-child',
      answerContainer: '[data-testid*="conversation"], [class*="conversation"]'
    },
    gpt: {
      streamStart: [
        '[data-message-author-role="assistant"]:last-child',
        'div[class*="agent-turn"]:last-child'
      ],
      streaming: [
        '[data-message-author-role="assistant"]:last-child [class*="result-streaming"]',
        '.result-streaming',
        '[data-streaming="true"]'
      ],
      generatingIndicators: [
        '[data-streaming="true"]',
        '.result-streaming'
      ],
      completionIndicators: [
        '[data-streaming="false"]'
      ],
      spinner: [
        '[class*="loading"]',
        '[aria-busy="true"]',
        'svg[class*="animate-spin"]'
      ],
      stopButton: 'button[data-testid="stop-button"], button[aria-label*="Stop"]',
      regenerateButton: 'button[data-testid="regenerate-button"]',
      lastMessage: '[data-message-author-role="assistant"]:last-child',
      answerContainer: '[data-testid="conversation-turn"], main[class*="conversation"]'
    },
    grok: {
      streamStart: [
        '[data-testid="message"]:last-child',
        '[role="article"]:last-child'
      ],
      streaming: [
        '[data-streaming="true"]',
        '[class*="typing"]',
        '.message-streaming'
      ],
      spinner: [
        '.spinner',
        '[aria-busy="true"]',
        'svg[class*="animate"]'
      ],
      stopButton: 'button[aria-label*="Stop"]',
      lastMessage: '[role="article"]:last-child, [data-testid="message"]:last-child',
      answerContainer: '[role="log"], [data-testid="conversation"]'
    },
    perplexity: {
      streamStart: [
        '[class*="answer-container"] > div:last-child',
        'div[class*="prose"]:last-child'
      ],
      streaming: [
        '[class*="streaming"]',
        '.answer-streaming',
        '[data-generating="true"]'
      ],
      spinner: [
        'svg.fa-spinner',
        '.loading-indicator',
        '[aria-busy="true"]',
        '.animate-spin'
      ],
      stopButton: 'button[aria-label*="Stop"]',
      lastMessage: '[class*="answer-container"] > div:last-child',
      answerContainer: '[class*="answer-container"], main'
    },
    gemini: {
      streamStart: [
        '[data-test-id*="model-response"]:last-child',
        '.model-response:last-child'
      ],
      streaming: [
        '[class*="streaming"]',
        '[data-streaming="true"]'
      ],
      generatingIndicators: [
        '[data-streaming="true"]'
      ],
      completionIndicators: [
        '[data-streaming="false"]'
      ],
      spinner: [
        '.spinner',
        '[aria-busy="true"]'
      ],
      stopButton: 'button[aria-label*="Stop"]',
      lastMessage: '[data-test-id*="model-response"]:last-child',
      answerContainer: '[role="main"]'
    },
    deepseek: {
      streamStart: [
        '.message-item:last-child[data-role="assistant"]',
        'div[class*="assistant"]:last-child'
      ],
      streaming: [
        '[class*="streaming"]',
        '[data-generating="true"]'
      ],
      spinner: [
        '.loading',
        '[aria-busy="true"]'
      ],
      stopButton: 'button:has-text("Stop")',
      lastMessage: '.message-item:last-child[data-role="assistant"]',
      answerContainer: '.chat-content, [class*="conversation"]'
    },
    qwen: {
      streamStart: [
        'div[class*="message-bot"]:last-child',
        '.message-bot:last-child'
      ],
      streaming: [
        '[class*="typing"]',
        '[data-status="generating"]'
      ],
      generatingIndicators: [
        '[data-status="generating"]'
      ],
      completionIndicators: [
        '[data-status="finished"]'
      ],
      spinner: [
        '.loading-icon',
        '[aria-busy="true"]'
      ],
      stopButton: 'button[class*="stop"]',
      lastMessage: 'div[class*="message-bot"]:last-child',
      answerContainer: '.chat-messages, [class*="conversation"]'
    },
    lechat: {
      streamStart: [
        '[data-role="assistant"]:last-child',
        '.assistant-message:last-child'
      ],
      streaming: [
        '[class*="generating"]',
        '[data-streaming="true"]'
      ],
      generatingIndicators: [
        '[data-streaming="true"]',
        '[class*="generating"]'
      ],
      completionIndicators: [
        '[data-streaming="false"]'
      ],
      spinner: [
        '.spinner',
        '[aria-busy="true"]'
      ],
      stopButton: 'button:has-text("Stop")',
      lastMessage: '[data-role="assistant"]:last-child',
      answerContainer: '.messages-container'
    },
    generic: {
      streamStart: [
        '[role="article"]:last-child',
        '.message:last-child',
        'div[class*="message"]:last-child'
      ],
      streaming: [
        '[data-streaming]',
        '[class*="streaming"]',
        '[class*="generating"]',
        '[class*="typing"]'
      ],
      generatingIndicators: [],
      completionIndicators: [],
      spinner: [
        '[class*="spin"]',
        '[class*="loading"]',
        '[class*="loader"]',
        '[aria-busy="true"]',
        '[aria-live="polite"]'
      ],
      stopButton: 'button[aria-label*="Stop"], button[aria-label*="stop"]',
      lastMessage: null,
      answerContainer: '[role="log"], [role="main"], main'
    }
  };

  function detectPlatform() {
    const hostname = window.location.hostname.toLowerCase();
    if (hostname.includes('claude.ai')) return 'claude';
    if (hostname.includes('openai.com') || hostname.includes('chatgpt.com')) return 'gpt';
    if (hostname.includes('x.ai')) return 'grok';
    if (hostname.includes('perplexity.ai')) return 'perplexity';
    if (hostname.includes('gemini.google.com')) return 'gemini';
    if (hostname.includes('deepseek.com')) return 'deepseek';
    if (hostname.includes('qwen.ai')) return 'qwen';
    if (hostname.includes('mistral.ai')) return 'lechat';
    return 'generic';
  }

  window.AnswerPipelineSelectors = {
    PLATFORM_SELECTORS,
    detectPlatform
  };
})();

;
/* eslint-disable no-console */

(function initUnifiedPipelineModules() {
  if (window.UnifiedPipelineModules) return;

  const detectLifecycleMode = () => {
    if (typeof document !== 'undefined' && document.visibilityState === 'hidden') {
      return 'background';
    }
    return window.__humanoidActivityMode || 'interactive';
  };

  const startLifecycleTrace = (source, context = {}) => {
    const events = window.HumanoidEvents;
    if (!events?.start) return null;
    try {
      return events.start(source, Object.assign({ mode: detectLifecycleMode() }, context));
    } catch (_) {
      return null;
    }
  };

  const heartbeatLifecycle = (traceId, progress = 0, meta = {}) => {
    if (!traceId) return;
    const events = window.HumanoidEvents;
    if (!events?.heartbeat) return;
    try {
      events.heartbeat(traceId, progress, meta);
    } catch (_) {}
  };

  const stopLifecycleTrace = (traceId, result = {}) => {
    if (!traceId) return;
    const events = window.HumanoidEvents;
    if (!events?.stop) return;
    try {
      events.stop(traceId, result);
    } catch (_) {}
  };

  const registerForceStopHandler = (handler) => {
    const registry = window.__humanoidForceStopRegistry;
    if (registry?.register) {
      return registry.register(handler);
    }
    if (typeof window.__registerHumanoidForceStopHandler === 'function') {
      return window.__registerHumanoidForceStopHandler(handler);
    }
    return () => {};
  };

  class AdaptiveTimeoutManager {
    constructor(customConfig = {}) {
      const defaults = {
        short: { maxChars: 500, timeout: 15000 },
        medium: { maxChars: 2000, timeout: 30000 },
        long: { maxChars: 5000, timeout: 60000 },
        veryLong: { maxChars: Infinity, timeout: 120000 },
        softExtension: 15000,
        hardMax: 120000
      };
      this.config = Object.assign({}, defaults, customConfig);
      this.softDeadline = null;
      this.hardDeadline = null;
    }

    calculateTimeout(currentContent = '') {
      const length = typeof currentContent === 'string'
        ? currentContent.length
        : (Number(currentContent) || 0);
      const base = this.getBaseTimeout(length);
      const hard = Math.min(base * 2, this.config.hardMax);
      this.softDeadline = Date.now() + base;
      this.hardDeadline = Date.now() + hard;
      return { soft: base, hard };
    }

    getBaseTimeout(length) {
      if (length <= this.config.short.maxChars) return this.config.short.timeout;
      if (length <= this.config.medium.maxChars) return this.config.medium.timeout;
      if (length <= this.config.long.maxChars) return this.config.long.timeout;
      return this.config.veryLong.timeout;
    }

    extendSoftTimeout() {
      if (!this.softDeadline || !this.hardDeadline) return false;
      const now = Date.now();
      if (now >= this.hardDeadline) return false;
      const newDeadline = Math.min(
        this.softDeadline + this.config.softExtension,
        this.hardDeadline
      );
      const extended = newDeadline > this.softDeadline;
      if (extended) {
        this.softDeadline = newDeadline;
      }
      return extended;
    }

    checkExpiration() {
      const now = Date.now();
      return {
        softExpired: this.softDeadline ? now >= this.softDeadline : false,
        hardExpired: this.hardDeadline ? now >= this.hardDeadline : false,
        softRemaining: this.softDeadline ? Math.max(0, this.softDeadline - now) : Infinity,
        hardRemaining: this.hardDeadline ? Math.max(0, this.hardDeadline - now) : Infinity
      };
    }

    getStatus() {
      return {
        softDeadline: this.softDeadline,
        hardDeadline: this.hardDeadline,
        ...this.checkExpiration()
      };
    }

    reset() {
      this.softDeadline = null;
      this.hardDeadline = null;
    }
  }

  const coordinationModes = {
    balanced: {
      waitFor: 'both',
      priority: 'answer',
      description: 'Wait for both, prioritize answer completion'
    },
    fast: {
      waitFor: 'first',
      earlyExit: true,
      description: 'First to complete (scroll OR answer)'
    }
  };

  function selectMode(context = {}) {
    if (context.expectedLength === 'short') return coordinationModes.fast;
    return coordinationModes.balanced;
  }

  class IntelligentRetryManager {
    constructor(customConfig = {}) {
      const defaults = {
        enabled: true,
        maxRetries: 5,
        backoffSequence: [300, 600, 1200, 2000, 2000],
        noGrowthThreshold: 2
      };
      this.config = Object.assign({}, defaults, customConfig);
      this.maxRetries = this.config.maxRetries;
    }

    async retryWithBackoff(attempt, operation, context) {
      const progress = this.checkProgress(context);
      if (progress.noGrowth && attempt >= 2) {
        console.log('[Retry] No growth detected, early exit');
        return { success: false, reason: 'no_progress' };
      }
      const delay = this.config.backoffSequence[Math.min(
        attempt - 1,
        this.config.backoffSequence.length - 1
      )];
      console.log(`[Retry] Attempt ${attempt}/${this.maxRetries}, backoff: ${delay}ms`);
      await this.sleep(delay);
      return operation();
    }

    checkProgress(context = {}) {
      const { lastScrollHeight = 0, currentScrollHeight = 0 } = context;
      const growth = currentScrollHeight - lastScrollHeight;
      return { growth, noGrowth: growth < (this.config.noGrowthThreshold ?? 2) };
    }

    sleep(ms) {
      return new Promise((resolve) => setTimeout(resolve, ms));
    }
  }

  class ContinuousHumanActivity {
    constructor(config = {}) {
      this.intervalId = null;
      this.config = Object.assign({
        interval: 5000,
        scrollRange: [50, 200],
        pauseBetweenMoves: 300,
        enabled: false,
        sessionTimeoutMs: 3 * 60 * 1000
      }, config);
      this.lifecycleTraceId = null;
      this.unregisterForceStop = null;
      this.sessionStopTimer = null;
    }

    startDuringWait() {
      if (this.intervalId || !this.config.enabled) return;
      this._startSessionTimer();
      if (!this.lifecycleTraceId) {
        this.lifecycleTraceId = startLifecycleTrace('continuous-activity', {
          mode: detectLifecycleMode(),
          interval: this.config.interval
        });
      }
      if (!this.unregisterForceStop) {
        this.unregisterForceStop = registerForceStopHandler(() => this.stop('background-force-stop'));
      }
      this.intervalId = setInterval(() => this.performMicroActivity(), this.config.interval);
    }

    async performMicroActivity() {
      if (this.lifecycleTraceId) {
        heartbeatLifecycle(this.lifecycleTraceId, 0, {
          phase: 'micro-activity',
          action: 'micro-scroll'
        });
      }
      const direction = Math.random() > 0.5 ? 1 : -1;
      const distance = this.config.scrollRange[0] +
        Math.random() * (this.config.scrollRange[1] - this.config.scrollRange[0]);
      const mouseSim = window.LLMExtension?.mouseSimulator;
      const humanoid = window.Humanoid;
      if (mouseSim?.scrollWithMouse) {
        await mouseSim.scrollWithMouse(direction * distance);
        setTimeout(() => {
          mouseSim.scrollWithMouse?.(-direction * distance);
        }, this.config.pauseBetweenMoves || (200 + Math.random() * 200));
        return;
      }
      if (humanoid?.humanScroll) {
        await humanoid.humanScroll(direction * distance, {
          style: 'micro',
          settle: false,
          waitForIdle: false,
          jitter: false
        });
        setTimeout(() => {
          humanoid.humanScroll?.(-direction * distance, {
            style: 'micro',
            settle: false,
            waitForIdle: false,
            jitter: false
          });
        }, this.config.pauseBetweenMoves || (200 + Math.random() * 200));
        return;
      }
      window.scrollBy({ top: direction * distance, behavior: 'smooth' });
      setTimeout(() => {
        window.scrollBy({ top: -direction * distance, behavior: 'smooth' });
      }, this.config.pauseBetweenMoves || (200 + Math.random() * 200));
    }

    stop(reason = 'manual-stop') {
      if (this.intervalId) {
        clearInterval(this.intervalId);
        this.intervalId = null;
      }
      if (this.unregisterForceStop) {
        try { this.unregisterForceStop(); } catch (_) {}
        this.unregisterForceStop = null;
      }
      if (this.sessionStopTimer) {
        clearTimeout(this.sessionStopTimer);
        this.sessionStopTimer = null;
      }
      if (this.lifecycleTraceId) {
        stopLifecycleTrace(this.lifecycleTraceId, {
          status: reason === 'background-force-stop' ? 'forced' : 'stopped',
          reason
        });
        this.lifecycleTraceId = null;
      }
    }

    _startSessionTimer() {
      if (!this.config.sessionTimeoutMs || this.sessionStopTimer) return;
      this.sessionStopTimer = setTimeout(() => {
        this.stop('session-timeout');
      }, this.config.sessionTimeoutMs);
    }
  }

  class HumanSessionController {
    constructor(deps = {}, config = {}) {
      this.continuousActivity = deps.continuousActivity || null;
      this.getHumanoid = deps.getHumanoid || (() => window.Humanoid || null);
      this.baseTimeoutMs = config.baseTimeoutMs || 180000;
      this.jitterPct = typeof config.jitterPct === 'number' ? config.jitterPct : 0.2;
      this.passiveMin = config.passiveMin || 30000;
      this.passiveMax = config.passiveMax || 60000;
      this.hardStopMin = config.hardStopMin || 480000; // 8 мин
      this.hardStopMax = config.hardStopMax || 600000; // 10 мин
      this.activityExtendMs = config.activityExtendMs || 120000; // продление при активности
      this.onHardStop = typeof config.onHardStop === 'function' ? config.onHardStop : null;
      this.state = 'IDLE';
      this.expireTimer = null;
      this.passiveTimer = null;
      this.visibilityHandler = null;
      this.hardStopTimer = null;
      this.hardStopDeadline = null;
      this.lastActivity = null;
    }

    startSession() {
      this.stopSession('restart');
      this.state = 'ACTIVE';
      const duration = this._computeDuration();
      this.lastActivity = Date.now();
      this.expireTimer = setTimeout(() => this.expireSession('time-limit'), duration);
      this._scheduleHardStop();
      this._attachVisibilityHandler();
    }

    expireSession(reason = 'time-limit') {
      if (this.state !== 'ACTIVE') return;
      this.state = 'EXPIRED';
      this._stopActiveModules(reason);
      this._startPassiveHeartbeat();
    }

    stopSession(reason = 'manual-stop') {
      if (this.expireTimer) {
        clearTimeout(this.expireTimer);
        this.expireTimer = null;
      }
      if (this.passiveTimer) {
        clearTimeout(this.passiveTimer);
        this.passiveTimer = null;
      }
      if (this.hardStopTimer) {
        clearTimeout(this.hardStopTimer);
        this.hardStopTimer = null;
      }
      this._detachVisibilityHandler();
      this._stopActiveModules(reason);
      this.state = 'IDLE';
    }

    reportActivity(label = 'activity') {
      if (this.state === 'IDLE') return;
      this.lastActivity = Date.now();
      const extendTo = this.lastActivity + this.activityExtendMs;
      if (!this.hardStopDeadline || extendTo > this.hardStopDeadline) {
        this.hardStopDeadline = extendTo;
        this._scheduleHardStop();
      }
    }

    _stopActiveModules(reason) {
      if (this.continuousActivity) {
        try { this.continuousActivity.stop(reason); } catch (_) {}
      }
      const humanoid = this.getHumanoid();
      if (humanoid?.stopAntiSleepDrift) {
        try { humanoid.stopAntiSleepDrift(); } catch (_) {}
      }
    }

    _startPassiveHeartbeat() {
      const beat = () => {
        if (this.state !== 'EXPIRED') return;
        try {
          const delta = 1;
          window.scrollBy({ top: delta, behavior: 'auto' });
          setTimeout(() => {
            window.scrollBy({ top: -delta, behavior: 'auto' });
        }, 50);
      } catch (_) {}
      const next = this.passiveMin + Math.random() * (this.passiveMax - this.passiveMin);
      this.passiveTimer = setTimeout(beat, next);
      };
      const first = this.passiveMin + Math.random() * (this.passiveMax - this.passiveMin);
      this.passiveTimer = setTimeout(beat, first);
    }

    _computeDuration() {
      const jitter = this.jitterPct;
      const base = this.baseTimeoutMs;
      const delta = base * jitter * (Math.random() * 2 - 1);
      return Math.max(60000, Math.round(base + delta));
    }

    _scheduleHardStop() {
      if (this.hardStopTimer) {
        clearTimeout(this.hardStopTimer);
        this.hardStopTimer = null;
      }
      const now = Date.now();
      if (!this.hardStopDeadline) {
        const min = this.hardStopMin;
        const max = this.hardStopMax;
        this.hardStopDeadline = now + (min + Math.random() * (max - min));
      }
      const delay = Math.max(0, this.hardStopDeadline - now);
      this.hardStopTimer = setTimeout(() => this._hardStop(), delay);
    }

    _hardStop() {
      this.stopSession('hard-stop');
      if (this.onHardStop) {
        try { this.onHardStop(); } catch (_) {}
      }
    }

    _attachVisibilityHandler() {
      this._detachVisibilityHandler();
      this.visibilityHandler = () => {
        if (document.hidden && this.state === 'ACTIVE') {
          this.expireSession('hidden');
        }
      };
      document.addEventListener('visibilitychange', this.visibilityHandler, { passive: true });
    }

    _detachVisibilityHandler() {
      if (this.visibilityHandler) {
        document.removeEventListener('visibilitychange', this.visibilityHandler, { passive: true });
        this.visibilityHandler = null;
      }
    }
  }

  class MaintenanceScroll {
    constructor(config = {}) {
      this.intervalId = null;
      this.enabled = false;
      this.config = Object.assign({
        checkInterval: 3000,
        growthThreshold: 50,
        scrollStep: 120,
        idleThreshold: 5000,
        maxDuration: 20000
      }, config);
      this.lifecycleTraceId = null;
      this.unregisterForceStop = null;
      this.currentCleanup = null;
    }

    run(target) {
      if (!target) return Promise.resolve({ ran: false, reason: 'no_target' });
      if (this.enabled) return Promise.resolve({ ran: false, reason: 'already_running' });
      this.enabled = true;
      const isWindowTarget = target.element === window;
      const container = isWindowTarget ? document.documentElement : target.element;
      if (!container) {
        this.enabled = false;
        return Promise.resolve({ ran: false, reason: 'invalid_container' });
      }

      let lastHeight = container.scrollHeight || document.documentElement.scrollHeight || 0;
      let lastGrowthTs = Date.now();
      let cycles = 0;
      const startTime = Date.now();

      return new Promise((resolve) => {
        let finished = false;
        const cleanup = (reason = 'manual_stop') => {
          if (finished) return;
          finished = true;
          if (this.intervalId) {
            clearInterval(this.intervalId);
            this.intervalId = null;
          }
          if (this.unregisterForceStop) {
            try { this.unregisterForceStop(); } catch (_) {}
            this.unregisterForceStop = null;
          }
          this.enabled = false;
          const duration = Date.now() - startTime;
          stopLifecycleTrace(this.lifecycleTraceId, {
            status: reason === 'stable' ? 'success' : reason === 'background-force-stop' ? 'forced' : 'stopped',
            reason,
            cycles,
            duration
          });
          this.lifecycleTraceId = null;
          this.currentCleanup = null;
          resolve({
            ran: true,
            reason,
            cycles,
            duration
          });
        };
        this.currentCleanup = cleanup;
        if (!this.lifecycleTraceId) {
          this.lifecycleTraceId = startLifecycleTrace('maintenance-scroll', {
            mode: detectLifecycleMode(),
            target: container === window ? 'window' : container.tagName || 'unknown'
          });
        }
        if (!this.unregisterForceStop) {
          this.unregisterForceStop = registerForceStopHandler(() => cleanup('background-force-stop'));
        }

        this.intervalId = setInterval(() => {
          const currentHeight = container.scrollHeight || document.documentElement.scrollHeight || 0;
          const growth = currentHeight - lastHeight;
          if (growth > this.config.growthThreshold) {
            this.scroll(container, this.config.scrollStep, isWindowTarget);
            lastHeight = currentHeight;
            lastGrowthTs = Date.now();
            cycles += 1;
            heartbeatLifecycle(this.lifecycleTraceId, Math.min(0.95, cycles / 10), {
              phase: 'maintenance',
              action: 'growth-scroll',
              scrollHeight: currentHeight,
              growth,
              cycles
            });
          } else if (Date.now() - lastGrowthTs >= this.config.idleThreshold) {
            cleanup('stable');
          }

          if (Date.now() - startTime >= this.config.maxDuration) {
            cleanup('timeout');
          }
          heartbeatLifecycle(this.lifecycleTraceId, Math.min(0.95, cycles / 10), {
            phase: 'maintenance-watch',
            scrollHeight: currentHeight,
            growth,
            cycles
          });
        }, this.config.checkInterval);
      });
    }

    async scroll(container, amount, isWindowTarget) {
      try {
        const humanoid = window.Humanoid;
        if (humanoid?.humanScroll) {
          await humanoid.humanScroll(amount, {
            style: 'maintenance',
            settle: false,
            waitForIdle: false,
            targetNode: { element: container, type: isWindowTarget ? 'window' : 'container' }
          });
          return;
        }
        if (isWindowTarget) {
          window.scrollBy({ top: amount, behavior: 'smooth' });
        } else if (typeof container.scrollBy === 'function') {
          container.scrollBy({ top: amount, behavior: 'smooth' });
        } else {
          container.scrollTop += amount;
        }
      } catch (err) {
        console.warn('[MaintenanceScroll] scroll failed', err);
      }
    }

    stop(reason = 'manual_stop') {
      if (typeof this.currentCleanup === 'function') {
        this.currentCleanup(reason);
        return;
      }
      if (this.intervalId) {
        clearInterval(this.intervalId);
        this.intervalId = null;
      }
      if (this.unregisterForceStop) {
        try { this.unregisterForceStop(); } catch (_) {}
        this.unregisterForceStop = null;
      }
      if (this.lifecycleTraceId) {
        stopLifecycleTrace(this.lifecycleTraceId, {
          status: reason === 'background-force-stop' ? 'forced' : 'stopped',
          reason
        });
        this.lifecycleTraceId = null;
      }
      this.enabled = false;
    }
  }

  class UniversalCompletionCriteria {
    constructor(customConfig = {}) {
      const defaults = {
        mutationIdle: 1500,
        scrollStable: 2000,
        contentStable: 1500,
        completionSignalEnabled: true
      };
      this.config = Object.assign({}, defaults, customConfig);
      this.criteria = {
        mutationIdle: { threshold: this.config.mutationIdle, met: false },
        scrollStable: { threshold: this.config.scrollStable, met: false },
        typingGone: { met: false },
        sentinelVisible: { met: false },
        contentStable: { threshold: this.config.contentStable, met: false },
        completionSignal: { enabled: this.config.completionSignalEnabled !== false, met: false }
      };
    }

    reset() {
      Object.keys(this.criteria).forEach((key) => {
        if (typeof this.criteria[key].met !== 'undefined') {
          this.criteria[key].met = false;
        }
      });
    }

    mark(name, met = true) {
      if (this.criteria[name]) {
        this.criteria[name].met = met;
      }
    }

    metCount() {
      return Object.values(this.criteria).filter((c) => c.met && (c.enabled !== false)).length;
    }

    getPriorityScore() {
      const total = Object.values(this.criteria).filter((c) => c.enabled !== false).length || 1;
      if (this.criteria.typingGone.met) return 1;
      return this.metCount() / total;
    }
  }

  class ComprehensiveTelemetry {
    constructor() {
      this.traceId = this.generateTraceId();
      this.events = [];
    }

    logPhase(phaseName, data = {}) {
      const event = {
        traceId: this.traceId,
        timestamp: Date.now(),
        phase: phaseName,
        ...data
      };
      this.events.push(event);
      try {
        chrome.runtime?.sendMessage?.({ type: 'TELEMETRY_EVENT', event });
      } catch (err) {
        console.warn('[Telemetry] sendMessage failed', err);
      }
    }

    generateReport() {
      if (!this.events.length) {
        return { traceId: this.traceId, totalDuration: 0, phases: [] };
      }
      return {
        traceId: this.traceId,
        totalDuration: this.events[this.events.length - 1].timestamp - this.events[0].timestamp,
        phases: this.groupByPhase(),
        completionReason: this.getCompletionReason(),
        retryCount: this.getRetryCount(),
        confidence: this.getConfidenceScore()
      };
    }

    groupByPhase() {
      return this.events.reduce((acc, event) => {
        acc[event.phase] = acc[event.phase] || [];
        acc[event.phase].push(event);
        return acc;
      }, {});
    }

    getCompletionReason() {
      const reasons = [
        'typing-gone',
        'stable-text',
        'scroll-plateau',
        'sentinel-visible',
        'mutation-idle',
        'soft-timeout',
        'hard-timeout',
        'error'
      ];
      for (const reason of reasons) {
        if (this.hasReason(reason)) return reason;
      }
      return 'unknown';
    }

    hasReason(reason) {
      return this.events.some((event) => event.reason === reason);
    }

    getRetryCount() {
      return this.events.filter((event) => event.type === 'retry').length;
    }

    getConfidenceScore() {
      const reason = this.getCompletionReason();
      const mapping = {
        'typing-gone': 1,
        'stable-text': 0.9,
        'scroll-plateau': 0.8,
        'sentinel-visible': 0.75,
        'mutation-idle': 0.7,
        'soft-timeout': 0.5,
        'hard-timeout': 0.3,
        error: 0.2,
        unknown: 0.4
      };
      return mapping[reason] ?? 0.4;
    }

    generateTraceId() {
      return `trace-${Date.now().toString(36)}-${Math.random().toString(36).slice(2, 8)}`;
    }
  }

  class PerplexityStabilization {
    constructor() {
      this.lastTextContent = '';
      this.stableChecks = 0;
      this.requiredStableChecks = 3;
    }

    async waitForStabilization(element) {
      return new Promise((resolve) => {
        const observer = new MutationObserver(() => {
          const currentText = element.textContent || '';
          if (currentText === this.lastTextContent) {
            this.stableChecks += 1;
            if (this.stableChecks >= this.requiredStableChecks) {
              observer.disconnect();
              resolve({ stable: true, text: currentText });
            }
          } else {
            this.stableChecks = 0;
            this.lastTextContent = currentText;
          }
        });

        observer.observe(element, {
          characterData: true,
          subtree: true,
          childList: false
        });
      });
    }
  }

  window.UnifiedPipelineModules = {
    AdaptiveTimeoutManager,
    coordinationModes,
    selectMode,
    IntelligentRetryManager,
    ContinuousHumanActivity,
    HumanSessionController,
    MaintenanceScroll,
    UniversalCompletionCriteria,
    ComprehensiveTelemetry,
    PerplexityStabilization
  };
})();

;
/* eslint-disable no-console */

(function initUnifiedAnswerWatcher() {
  const namespace = window.AnswerPipeline = window.AnswerPipeline || {};
  if (namespace.UnifiedAnswerCompletionWatcher) return;

  const Modules = window.UnifiedPipelineModules;
  const Config = window.AnswerPipelineConfig;
  const SelectorBundle = window.AnswerPipelineSelectors;
  if (!Modules || !Config || !SelectorBundle) {
    console.warn('[AnswerWatcher] Missing dependencies (modules/config/selectors)');
    return;
  }

  const { PLATFORM_SELECTORS, detectPlatform } = SelectorBundle;
  const {
    UniversalCompletionCriteria,
    AdaptiveTimeoutManager
  } = Modules;

  class UnifiedAnswerCompletionWatcher {
    constructor(platform, options = {}) {
      this.platform = platform || detectPlatform?.() || 'generic';
      this.selectors = PLATFORM_SELECTORS[this.platform] || PLATFORM_SELECTORS.generic || {};
      const completionConfig = Object.assign({}, Config.streaming?.completionCriteria || {}, options.completionCriteria || {});
      const adaptiveConfig = Object.assign({}, Config.streaming?.adaptiveTimeout || {}, options.adaptiveTimeout || {});
      this.humanSession = options.humanSession || null;
      this.criteria = new UniversalCompletionCriteria(completionConfig);
      this.timeoutManager = new AdaptiveTimeoutManager(adaptiveConfig);
      this.checkInterval = completionConfig.checkInterval || 500;
      this.options = options;
      this.scrollHeightHistory = [];
      this.invalidSelectors = new Set();
    }

    async waitForCompletion(params = {}) {
      this.container = params.container?.element === window
        ? document.body
        : (params.container?.element || document.body);
      this.criteria.reset();
      this.scrollHeightHistory = [];
      this.startTime = Date.now();
      const currentLength = this.getCurrentContentLength();
      const { soft, hard } = this.timeoutManager.calculateTimeout(currentLength);
      let typingActive = true;
      const growthHistory = [];

      const recordGrowth = (diff) => {
        const now = Date.now();
        growthHistory.push({ ts: now, diff });
        while (growthHistory.length && now - growthHistory[0].ts > 2000) {
          growthHistory.shift();
        }
      };

      const getRecentGrowth = () => {
        const now = Date.now();
        return growthHistory
          .filter((item) => now - item.ts <= 2000)
          .reduce((sum, item) => sum + item.diff, 0);
      };

      let lastMutation = Date.now();
      let lastScrollHeight = this.getScrollHeight();
      let lastContentLength = 0;
      const mutationObserver = new MutationObserver(() => {
        lastMutation = Date.now();
        this.criteria.mark('mutationIdle', false);
        this.humanSession?.reportActivity?.('mutation');
      });
      mutationObserver.observe(this.container, { childList: true, subtree: true, characterData: true });

      const updateHandle = setInterval(() => {
        const now = Date.now();
        if (now - lastMutation > (this.criteria.criteria.mutationIdle?.threshold || 1500)) {
          this.criteria.mark('mutationIdle', true);
        }

        const height = this.getScrollHeight();
        this.scrollHeightHistory.push({ timestamp: now, height });
        while (this.scrollHeightHistory.length > 40) {
          this.scrollHeightHistory.shift();
        }
        if (Math.abs(height - lastScrollHeight) < 2) {
          this.criteria.mark('scrollStable', true);
        } else {
          if (height - lastScrollHeight > 0) {
            recordGrowth(height - lastScrollHeight);
          }
          lastScrollHeight = height;
          this.criteria.mark('scrollStable', false);
        }

        typingActive = this.detectTyping();
        this.criteria.mark('typingGone', !typingActive);

        const sentinelVisible = this.isSentinelVisible();
        this.criteria.mark('sentinelVisible', sentinelVisible);

        const completionSignal = this.detectCompletionIndicator();
        if (this.criteria.criteria.completionSignal?.enabled) {
          this.criteria.mark('completionSignal', completionSignal);
        }

        const answerEl = this.getAnswerElement();
        if (answerEl) {
          const len = answerEl.textContent?.length || 0;
          if (Math.abs(len - lastContentLength) < 5 && len > 0) {
            this.criteria.mark('contentStable', true);
          } else {
            lastContentLength = len;
            this.criteria.mark('contentStable', false);
          }
          this.humanSession?.reportActivity?.('content-change');
        }
      }, this.checkInterval / 2);

      return new Promise((resolve) => {
        let checkHandle;
        const cleanup = (payload) => {
          clearInterval(checkHandle);
          clearInterval(updateHandle);
          mutationObserver.disconnect();
          resolve(payload);
        };

        checkHandle = setInterval(() => {
          const expiration = this.timeoutManager.checkExpiration();
          const metCount = this.criteria.metCount();
          const criteriaTotal = Object.values(this.criteria.criteria).filter((c) => c.enabled !== false).length || 5;
          if (metCount >= (Config.streaming?.completionCriteria?.minMetCriteria || 3)) {
            cleanup(this.buildResult('criteria_met', metCount / criteriaTotal, typingActive, getRecentGrowth()));
            return;
          }

          if (expiration.hardExpired) {
            cleanup(this.buildResult('hard_timeout', 0.3, typingActive, getRecentGrowth(), false));
            return;
          }

          if (expiration.softExpired) {
            if (metCount >= 2 && this.timeoutManager.extendSoftTimeout()) {
              return;
            }
            cleanup(this.buildResult('soft_timeout', 0.5, typingActive, getRecentGrowth(), false));
          }
        }, this.checkInterval);
      });
    }

    detectTyping() {
      const generating = (this.selectors.generatingIndicators || []).some((selector) => this.safeQuery(selector));
      const streaming = (this.selectors.streaming || []).some((selector) => this.safeQuery(selector));
      const spinners = (this.selectors.spinner || []).some((selector) => {
        const nodes = this.safeQueryAll(selector);
        return Array.from(nodes).some((el) => {
          const rect = el.getBoundingClientRect();
          const style = window.getComputedStyle(el);
          return rect.width > 0 && rect.height > 0 && style.visibility !== 'hidden' && style.display !== 'none';
        });
      });
      const stopButton = this.selectors.stopButton && this.safeQuery(this.selectors.stopButton);
      return generating || streaming || spinners || Boolean(stopButton);
    }

    isSentinelVisible() {
      const sentinel = document.getElementById('toolkit-sentinel');
      if (!sentinel) return false;
      const rect = sentinel.getBoundingClientRect();
      return rect.top >= 0 && rect.bottom <= window.innerHeight;
    }

    getScrollHeight() {
      const node = this.container === document.body ? document.documentElement : this.container;
      return node?.scrollHeight || document.documentElement.scrollHeight || 0;
    }

    getAnswerElement() {
      const selectors = this.selectors.lastMessage ? [this.selectors.lastMessage] : [];
      if (!selectors.length && this.selectors.answerContainer) {
        selectors.push(`${this.selectors.answerContainer} > :last-child`);
      }
      return selectors
        .map((selector) => this.safeQuery(selector))
        .find(Boolean);
    }

    getCurrentContentLength() {
      const el = this.getAnswerElement();
      return el?.textContent?.length || 0;
    }

    detectCompletionIndicator() {
      if (!this.selectors.completionIndicators || !this.selectors.completionIndicators.length) return false;
      return this.selectors.completionIndicators.some((selector) => {
        const nodes = this.safeQueryAll(selector);
        return Array.from(nodes).some((el) => {
          const rect = el.getBoundingClientRect();
          const style = window.getComputedStyle(el);
          return rect.width > 0 && rect.height > 0 && style.visibility !== 'hidden' && style.display !== 'none';
        });
      });
    }

    buildResult(reason, confidence, typingActive, recentGrowth, completed = true) {
      return {
        success: completed,
        completed,
        reason,
        confidence,
        duration: Date.now() - this.startTime,
        indicators: { streaming: typingActive },
        scrollGrowthInLast2s: recentGrowth,
        criteriaMet: this.criteria.metCount(),
        metrics: {
          scrollHeightHistory: this.scrollHeightHistory.slice(-20),
          timeoutStatus: this.timeoutManager.getStatus(),
          typingActive
        }
      };
    }

    safeQuery(selector) {
      try {
        return document.querySelector(selector);
      } catch (err) {
        if (!this.invalidSelectors.has(selector)) {
          this.invalidSelectors.add(selector);
          console.warn('[AnswerWatcher] Invalid selector', selector, err);
        }
        return null;
      }
    }

    safeQueryAll(selector) {
      try {
        return document.querySelectorAll(selector);
      } catch (err) {
        if (!this.invalidSelectors.has(selector)) {
          this.invalidSelectors.add(selector);
          console.warn('[AnswerWatcher] Invalid selector', selector, err);
        }
        return [];
      }
    }
  }

  namespace.UnifiedAnswerCompletionWatcher = UnifiedAnswerCompletionWatcher;
})();

;
/* eslint-disable no-console */

(function initSanityCheck() {
  const namespace = window.AnswerPipeline = window.AnswerPipeline || {};
  if (namespace.SanityCheck) return;

  const Config = window.AnswerPipelineConfig;
  if (!Config) {
    console.warn('[SanityCheck] Missing AnswerPipelineConfig');
    return;
  }

  class SanityCheck {
    constructor(customConfig = {}) {
      this.config = Object.assign({}, Config.finalization?.sanityCheck || {}, customConfig);
      this.channelAvailable = typeof chrome !== 'undefined' && !!chrome.runtime?.sendMessage;
    }

    async execute(pipelineResult = {}) {
      if (!this.config.enabled) {
        return { ok: true, warnings: [], overallConfidence: 1 }; 
      }

      const warnings = [];
      const answerResult = pipelineResult.answerResult || {};
      const scrollResult = pipelineResult.scrollResult || {};
      const answerText = pipelineResult.answer || '';
      const context = {
        llmName: pipelineResult.llmName || this.config.llmName || pipelineResult.platform || 'unknown',
        platform: pipelineResult.platform || this.config.platform || 'generic',
        answerLength: answerText.length
      };

      if (this.config.warnOnHardTimeout && answerResult.reason === 'hard_timeout') {
        warnings.push({
          type: 'hard_timeout',
          message: 'Answer may be incomplete (hard timeout reached)',
          confidence: 0.6,
          severity: 'high'
        });
      }

      if (this.config.warnOnActiveIndicators && answerResult.indicators?.streaming) {
        warnings.push({
          type: 'streaming_active',
          message: 'Streaming indicators still active at completion',
          confidence: 0.5,
          severity: 'medium'
        });
      }

      const recentGrowth = answerResult.scrollGrowthInLast2s || 0;
      if (recentGrowth > (this.config.recentGrowthThreshold || 10)) {
        warnings.push({
          type: 'content_growing',
          message: `Scroll height still increasing (+${recentGrowth}px)`,
          confidence: 0.7,
          severity: 'medium'
        });
      }

      if (answerText.length && answerText.length < 50) {
        warnings.push({
          type: 'short_answer',
          message: `Answer is very short (${answerText.length} chars)`,
          confidence: 0.8,
          severity: 'low'
        });
      }

      if (scrollResult.reason === 'timeout') {
        warnings.push({
          type: 'scroll_timeout',
          message: 'Scroll settlement timed out',
          confidence: 0.75,
          severity: 'medium'
        });
      }

      const overallConfidence = this.calculateConfidence(warnings);
      if (warnings.length) {
        this.emitDiagnostics(warnings, context);
      }
      return {
        ok: warnings.length === 0,
        warnings,
        overallConfidence
      };
    }

    calculateConfidence(warnings) {
      if (!warnings.length) return 1;
      const minConfidence = Math.min(...warnings.map((w) => w.confidence));
      const penalty = warnings.length * 0.05;
      return Math.max(0.3, minConfidence - penalty);
    }

    emitDiagnostics(warnings, context) {
      if (!this.channelAvailable) return;
      warnings.forEach((warning) => {
        try {
          chrome.runtime.sendMessage({
            type: 'LLM_DIAGNOSTIC_EVENT',
            llmName: context.llmName,
            event: {
              ts: Date.now(),
              type: 'SANITY_WARNING',
              label: `[${context.platform}] ${warning.message}`,
              details: warning.message,
              level: warning.severity === 'high' ? 'warning' : 'info',
              meta: {
                warningType: warning.type,
                confidence: warning.confidence,
                severity: warning.severity,
                platform: context.platform,
                answerLength: context.answerLength
              }
            }
          });
        } catch (_) {
          /* noop */
        }
      });
    }
  }

  namespace.SanityCheck = SanityCheck;
})();

;
(function initUnifiedAnswerPipeline() {
  if (window.UnifiedAnswerPipeline) return;

  const Modules = window.UnifiedPipelineModules;
  const Config = window.AnswerPipelineConfig;
  const SelectorBundle = window.AnswerPipelineSelectors;
  const namespace = window.AnswerPipeline || {};
  const WatcherClass = namespace.UnifiedAnswerCompletionWatcher;
  const SanityCheckClass = namespace.SanityCheck;

  if (!Modules || !Config || !SelectorBundle || !WatcherClass || !SanityCheckClass) {
    console.warn('[UnifiedAnswerPipeline] Missing dependencies (modules/config/selectors/watcher/sanity)');
    return;
  }

  const {
    AdaptiveTimeoutManager,
    coordinationModes,
    selectMode,
    IntelligentRetryManager,
    ContinuousHumanActivity,
    MaintenanceScroll,
    ComprehensiveTelemetry,
    PerplexityStabilization,
    HumanSessionController
  } = Modules;
  const { PLATFORM_SELECTORS, detectPlatform } = SelectorBundle;

  const clone = (obj) => JSON.parse(JSON.stringify(obj || {}));

  const deepMerge = (target, source) => {
    if (!source) return target;
    Object.keys(source).forEach((key) => {
      const value = source[key];
      if (value && typeof value === 'object' && !Array.isArray(value)) {
        target[key] = deepMerge(target[key] || {}, value);
      } else {
        target[key] = value;
      }
    });
    return target;
  };

  class UnifiedAnswerPipeline {
    constructor(platform, overrides = {}) {
      const normalizedPlatform = typeof platform === 'string' ? platform.toLowerCase() : platform;
      this.platform = normalizedPlatform || detectPlatform?.() || 'generic';
      const baseConfig = clone(Config);
      this.config = deepMerge(baseConfig, overrides);
      this.selectors = PLATFORM_SELECTORS[this.platform] || PLATFORM_SELECTORS.generic || {};

      this.adaptiveTimeout = new AdaptiveTimeoutManager(this.config.streaming?.adaptiveTimeout);
      this.retryManager = new IntelligentRetryManager(this.config.streaming?.intelligentRetry);
      this.humanActivity = new ContinuousHumanActivity(this.config.streaming?.continuousActivity);
      this._initHumanSession();
      this.maintenanceScroll = new MaintenanceScroll(this.config.streaming?.maintenanceScroll);
      this.sanityCheck = new SanityCheckClass(this.config.finalization?.sanityCheck);
      this.telemetry = new ComprehensiveTelemetry();
      this.perplexityHelper = /perplexity/i.test(this.platform || '') ? new PerplexityStabilization() : null;
      this.answerWatcherClass = WatcherClass;

      this.state = {
        phase: 'idle',
        startTime: 0,
        phaseTimings: {},
        preparationResult: null,
        scrollResult: null,
        answerResult: null,
        finalizationResult: null,
        container: null,
        maintenanceResult: null,
        initialScrollKick: null
      };

      this.scrollToolkit = window.__UniversalScrollToolkit || null;
      this.lifecycle = window.HumanoidEvents || null;
      this.lifecycleTraceId = null;
      this.hardStopTriggered = false;
    }

    _initHumanSession() {
      const self = this;
      const cfg = Object.assign({
        onHardStop() {
          self.streamingTimedOut = true;
          self.hardStopTriggered = true;
        }
      }, this.config.streaming?.humanSession || {});
      this.humanSession = new HumanSessionController({
        continuousActivity: this.humanActivity,
        getHumanoid: () => window.Humanoid || null
      }, cfg);
    }

    async execute() {
      this.state.phase = 'preparation';
      this.state.startTime = Date.now();
      this.telemetry.logPhase('pipeline_start', { platform: this.platform });
      this._lifecycleHeartbeat('pipeline_start', 0.05);

      const lifecycle = this.lifecycle;
      if (lifecycle && !this.lifecycleTraceId) {
        this.lifecycleTraceId = lifecycle.start('pipeline', {
          platform: this.platform,
          mode: this.config.streaming?.coordinationMode
        });
      }

      let lifecycleStatus = 'error';
      let lifecycleHeartbeatInterval = null;
      if (this.lifecycleTraceId && lifecycle) {
        lifecycleHeartbeatInterval = setInterval(() => {
          lifecycle.heartbeat(this.lifecycleTraceId, null, { phase: this.state.phase });
        }, 7000);
      }

      try {
        const preparation = await this.runPreparationPhase();
        if (!preparation.success) {
          this._reportLifecycleError('preparation', preparation.error);
          return this.handleError('preparation', preparation.error);
        }
        this._lifecycleHeartbeat('preparation', 0.3);

        const streaming = await this.runStreamingPhase(preparation);
        if (!streaming.success) {
          this._reportLifecycleError('streaming', streaming.error);
          return this.handleError('streaming', streaming.error);
        }
        this._lifecycleHeartbeat('streaming', 0.7);

        const finalization = await this.runFinalizationPhase(streaming);
        if (!finalization.success) {
          this._reportLifecycleError('finalization', finalization.error);
          return this.handleError('finalization', finalization.error);
        }

        this.state.phase = 'complete';
        const report = this.telemetry.generateReport();
        this._lifecycleHeartbeat('finalization', 1);
        lifecycleStatus = 'success';

        return {
          success: true,
          answer: finalization.answer,
          metadata: {
            traceId: report.traceId,
            platform: this.platform,
            duration: report.totalDuration,
            phases: report.phases,
            completionReason: report.completionReason,
            confidence: finalization.sanityCheck?.overallConfidence ?? report.confidence,
            preparation: this.state.preparationResult,
            scroll: this.state.scrollResult,
            answer: this.state.answerResult,
            maintenance: this.state.maintenanceResult,
            finalization: finalization,
            sanityCheck: finalization.sanityCheck
          }
        };
      } catch (error) {
        if (this.lifecycleTraceId && lifecycle) {
          lifecycle.error(this.lifecycleTraceId, error, true);
        }
        return this.handleError('unexpected', error);
      } finally {
        if (lifecycleHeartbeatInterval) {
          clearInterval(lifecycleHeartbeatInterval);
        }
        if (this.lifecycleTraceId && lifecycle) {
          lifecycle.stop(this.lifecycleTraceId, {
            status: lifecycleStatus,
            phase: this.state.phase
          });
          this.lifecycleTraceId = null;
        }
        this.humanSession.stopSession('pipeline-exit');
      }
    }

    async runPreparationPhase() {
      const phaseStart = Date.now();
      this.telemetry.logPhase('preparation_start');
      const tabActive = await this.activateTab();
      if (!tabActive) {
        return { success: false, error: 'tab_activation_failed' };
      }
      this.telemetry.logPhase('tab_activated');

      const streamOk = await this.waitForStreamStart();
      if (!streamOk) {
        return { success: false, error: 'stream_start_timeout' };
      }

      const containerInfo = this.detectContainer();
      if (!containerInfo) {
        return { success: false, error: 'container_not_found' };
      }

      this.state.container = containerInfo;
      const duration = Date.now() - phaseStart;
      this.state.phaseTimings.preparation = duration;
      this.state.preparationResult = { success: true, duration, containerInfo };
      this.telemetry.logPhase('preparation_done', { duration });
      return this.state.preparationResult;
    }

    waitForStreamStart() {
      const selectors = this.selectors.streamStart?.length
        ? this.selectors.streamStart
        : this.getDefaultStreamStartSelectors();
      const timeout = this.config.preparation?.streamStartTimeout || 45000;
      return new Promise((resolve) => {
        const existing = selectors.some((selector) => document.querySelector(selector));
        if (existing) {
          resolve(true);
          return;
        }

        const timer = setTimeout(() => {
          observer.disconnect();
          resolve(false);
        }, timeout);

        const observer = new MutationObserver(() => {
          const found = selectors.some((selector) => document.querySelector(selector));
          if (found) {
            clearTimeout(timer);
            observer.disconnect();
            resolve(true);
          }
        });
        observer.observe(document.body, { childList: true, subtree: true });
      });
    }

    async activateTab() {
      if (!document.hidden) return true;
      const timeoutMs = this.config.preparation?.tabActivationTimeout || 5000;
      return new Promise((resolve) => {
        const timer = setTimeout(() => {
          document.removeEventListener('visibilitychange', handler);
          resolve(false);
        }, timeoutMs);

        const handler = () => {
          if (!document.hidden) {
            clearTimeout(timer);
            document.removeEventListener('visibilitychange', handler);
            resolve(true);
          }
        };

        document.addEventListener('visibilitychange', handler);

        try {
          chrome?.tabs?.getCurrent?.((tab) => {
            if (tab?.id) chrome.tabs.update(tab.id, { active: true });
          });
        } catch (_) {
          // ignore
        }
      });
    }

    detectContainer() {
      try {
        if (this.scrollToolkit) {
          const toolkit = new this.scrollToolkit();
          const candidates = toolkit.containerDetector?.findScrollable() || [];
          return candidates[0] || { element: window, type: 'window' };
        }
      } catch (err) {
        console.warn('[Pipeline] ScrollToolkit container detection failed', err);
      }
      const container = document.querySelector(this.selectors.answerContainer) || document.documentElement;
      return { element: container, type: container === window ? 'window' : 'container' };
    }

    async runStreamingPhase(prepResult) {
      const phaseStart = Date.now();
      this.state.phase = 'streaming';
      const expectedLength = this.config.streaming?.expectedLength || this.config.expectedLength || 'medium';
      const modeName = this.config.streaming?.coordinationMode || 'balanced';
      const configuredMode = coordinationModes[modeName] || selectMode({ expectedLength });
      this.telemetry.logPhase('streaming_start', { mode: modeName });

      this.humanSession.startSession();
      this.streamingTimedOut = false;
      const timeouts = this.adaptiveTimeout.calculateTimeout(this.config.seedContent || '');
      const watchdog = setTimeout(() => {
        this.streamingTimedOut = true;
      }, timeouts.hard);

      this.humanActivity.startDuringWait();

      try {
        await this.runInitialScrollKick(prepResult);
        const scrollPromise = this.runScrollSettlement(prepResult);
        const answerPromise = this.runAnswerCompletion(prepResult.containerInfo);

        let scrollResult;
        let answerResult;

        if (configuredMode.waitFor === 'both') {
          [scrollResult, answerResult] = await Promise.all([scrollPromise, answerPromise]);
        } else {
          const first = await Promise.race([
            scrollPromise.then((res) => ({ type: 'scroll', res })),
            answerPromise.then((res) => ({ type: 'answer', res })),
            new Promise((_, reject) => {
              const check = setInterval(() => {
                if (this.hardStopTriggered) {
                  clearInterval(check);
                  reject(new Error('hard_stop'));
                }
              }, 300);
            })
          ]);
          if (first?.type === 'scroll') {
            scrollResult = first.res;
            answerResult = await answerPromise;
          } else if (first?.type === 'answer') {
            answerResult = first.res;
            scrollResult = await scrollPromise;
          }
        }

        clearTimeout(watchdog);
        this.humanActivity.stop();

        if (this.streamingTimedOut) {
          return { success: false, error: 'hard_timeout' };
        }

        this.state.scrollResult = scrollResult;
        this.state.answerResult = answerResult;

        if (!scrollResult?.success && !answerResult?.success) {
          return { success: false, error: 'streaming_incomplete' };
        }

        const duration = Date.now() - phaseStart;
        this.state.phaseTimings.streaming = duration;
        this.telemetry.logPhase('streaming_done', { duration });
        return { success: true, duration };
      } catch (error) {
        clearTimeout(watchdog);
        this.humanActivity.stop();
        this.humanSession.stopSession('streaming-error');
        return { success: false, error: error.message || 'streaming_failed' };
      }
    }

    async runInitialScrollKick(prepResult) {
      if (!this.config.streaming?.initialScrollKick?.enabled) {
        return { ran: false, reason: 'disabled' };
      }
      if (!prepResult || !prepResult.containerInfo) {
        return { ran: false, reason: 'no_container' };
      }
      const delay = Number(this.config.streaming.initialScrollKick.delay) || 0;
      if (delay > 0) {
        await this.sleep(delay);
      }
      const target = prepResult.containerInfo.element || window;
      try {
        if (this.scrollToolkit) {
          const tk = new this.scrollToolkit({ logLevel: 'error' });
          await tk.scrollToBottom({ targetNode: target });
          this.state.initialScrollKick = { ran: true, tool: 'scrollToolkit' };
          this.telemetry.logPhase('scroll_kick', { tool: 'scrollToolkit' });
          return this.state.initialScrollKick;
        }
        const humanoid = window.Humanoid;
        if (humanoid?.humanScroll) {
          const el = target === window ? document.documentElement : target;
          const start = target === window ? window.scrollY : (target.scrollTop || 0);
          const height = el?.scrollHeight || document.documentElement.scrollHeight || 0;
          const view = el?.clientHeight || window.innerHeight || 0;
          const distance = Math.max(0, height - view - start);
          await humanoid.humanScroll(distance || 800, { targetNode: target, style: 'reading' });
          this.state.initialScrollKick = { ran: true, tool: 'humanoid' };
          this.telemetry.logPhase('scroll_kick', { tool: 'humanoid', distance });
          return this.state.initialScrollKick;
        }
        const el = target === window ? document.documentElement : target;
        if (el?.scrollTo) {
          el.scrollTo({ top: el.scrollHeight, behavior: 'smooth' });
          this.state.initialScrollKick = { ran: true, tool: 'native' };
          this.telemetry.logPhase('scroll_kick', { tool: 'native' });
          return this.state.initialScrollKick;
        }
      } catch (err) {
        this.telemetry.logPhase('scroll_kick_error', { message: err.message });
        this.state.initialScrollKick = { ran: false, reason: err.message };
        return this.state.initialScrollKick;
      }
      this.state.initialScrollKick = { ran: false, reason: 'no_tool' };
      return this.state.initialScrollKick;
    }

    async runScrollSettlement(prepResult) {
      const { containerInfo } = prepResult;
      const target = containerInfo?.element ? containerInfo : { element: window, type: 'window' };
      const useRetry = this.config.streaming?.intelligentRetry?.enabled && this.scrollToolkit;

      if (!useRetry) {
        return this.performScrollAttempt(target);
      }

      let lastScrollHeight = this.getScrollHeight(target);
      for (let attempt = 1; attempt <= (this.retryManager.maxRetries || 5); attempt += 1) {
        const context = {
          lastScrollHeight,
          currentScrollHeight: this.getScrollHeight(target)
        };
        lastScrollHeight = context.currentScrollHeight;
        const attemptResult = await this.retryManager.retryWithBackoff(
          attempt,
          () => this.performScrollAttempt(target),
          context
        );

        this.telemetry.logPhase('streaming_scroll_attempt', {
          attempt,
          success: attemptResult?.success,
          growth: context.currentScrollHeight - context.lastScrollHeight
        });

        if (attemptResult?.success) {
          return Object.assign({ success: true, attempts: attempt }, attemptResult);
        }
      }
      return { success: false, reason: 'scroll_settlement_failed' };
    }

    async performScrollAttempt(target) {
      if (this.scrollToolkit) {
        const toolkit = new this.scrollToolkit({ logLevel: 'error' });
        const settled = await toolkit.scrollToBottom({ targetNode: target.element });
        return { success: settled, settled };
      }
      const el = target.element === window ? document.documentElement : target.element;
      el.scrollTo({ top: el.scrollHeight, behavior: 'smooth' });
      return { success: true, reason: 'fallback' };
    }

    getScrollHeight(target) {
      const el = target?.element === window ? document.documentElement : target?.element;
      return el?.scrollHeight || document.documentElement.scrollHeight || 0;
    }

    async runAnswerCompletion(containerInfo) {
      if (!this.answerWatcherClass) {
        return { success: false, reason: 'watcher_missing' };
      }
      const watcher = new this.answerWatcherClass(this.platform, {
        completionCriteria: this.config.streaming?.completionCriteria,
        adaptiveTimeout: this.config.streaming?.adaptiveTimeout
      });
      const result = await watcher.waitForCompletion({ container: containerInfo });
      return result;
    }

    async runFinalizationPhase() {
      const phaseStart = Date.now();
      this.state.phase = 'finalization';
      this.telemetry.logPhase('finalization_start');

      const maintenanceResult = await this.runMaintenanceScroll(this.state.container);
      this.state.maintenanceResult = maintenanceResult;

      const stable = await this.runFinalStabilityChecks();
      const answer = await this.extractAnswer();
      const sanityCheck = await this.sanityCheck.execute({
        answer,
        scrollResult: this.state.scrollResult,
        answerResult: this.state.answerResult,
        platform: this.platform,
        llmName: this.config.llmName || this.platform
      });

      const duration = Date.now() - phaseStart;
      this.state.phaseTimings.finalization = duration;
      this.state.finalizationResult = { success: true, duration, answer, sanityCheck, stable };
      this.telemetry.logPhase('finalization_done', { duration, sanityCheck });

      return this.state.finalizationResult;
    }

    async runMaintenanceScroll(containerInfo) {
      if (!containerInfo || !this.config.streaming?.maintenanceScroll?.enabled) {
        return { ran: false, reason: 'disabled' };
      }
      try {
        return await this.maintenanceScroll.run(containerInfo);
      } catch (error) {
        return { ran: false, reason: error.message };
      }
    }

    async runFinalStabilityChecks() {
      const checks = this.config.finalization?.stabilityChecks || 3;
      const interval = this.config.finalization?.stabilityInterval || 800;
      let lastHash = '';
      let stableCount = 0;
      for (let i = 0; i < checks; i += 1) {
        const element = this.getAnswerElement();
        if (!element) return false;
        const hash = this.hashString(element.textContent || '');
        if (hash === lastHash) {
          stableCount += 1;
          if (stableCount >= checks - 1) return true;
        } else {
          stableCount = 0;
        }
        lastHash = hash;
        // eslint-disable-next-line no-await-in-loop
        await this.sleep(interval);
      }
      return false;
    }

    getAnswerElement() {
      const selectors = [];
      if (this.selectors.lastMessage) selectors.push(this.selectors.lastMessage);
      if (this.config.answerSelectors) selectors.push(...this.config.answerSelectors);
      return selectors.map((selector) => document.querySelector(selector)).find(Boolean);
    }

    async extractAnswer() {
      const element = this.getAnswerElement();
      if (!element) throw new Error('answer_element_missing');
      if (this.perplexityHelper) {
        const stable = await this.perplexityHelper.waitForStabilization(element);
        return stable.text.trim();
      }
      return this.extractText(element);
    }

    extractText(element) {
      if (!element) return '';
      const cloneEl = element.cloneNode(true);
      cloneEl.querySelectorAll('[style*="display: none"], [style*="visibility: hidden"]').forEach((el) => el.remove());
      cloneEl.querySelectorAll('button, [role="button"], .toolbar, .actions').forEach((el) => el.remove());
      return (cloneEl.textContent || '').replace(/\s+/g, ' ').trim();
    }

    hashString(str) {
      let hash = 0;
      for (let i = 0; i < str.length; i += 1) {
        hash = ((hash << 5) - hash) + str.charCodeAt(i);
        hash |= 0;
      }
      return hash.toString(36);
    }

    sleep(ms) {
      return new Promise((resolve) => setTimeout(resolve, ms));
    }

    getDefaultStreamStartSelectors() {
      return [
        '[data-testid=\"conversation-turn\"]',
        '.chat-message',
        'article',
        '[data-scroll-anchor]'
      ];
    }

    querySelectorSafe(selector) {
      if (!selector) return null;
      try {
        return document.querySelector(selector);
      } catch (err) {
        console.warn('[Pipeline] Invalid selector', selector, err);
        return null;
      }
    }

    _lifecycleHeartbeat(phase, progress) {
      if (this.lifecycle && this.lifecycleTraceId) {
        this.lifecycle.heartbeat(this.lifecycleTraceId, progress, { phase });
      }
    }

    _reportLifecycleError(phase, message) {
      if (this.lifecycle && this.lifecycleTraceId) {
        const err = new Error(message || phase);
        this.lifecycle.error(this.lifecycleTraceId, err, false);
      }
    }

    handleError(phase, error) {
      this.state.phase = 'error';
      const payload = {
        success: false,
        error: {
          phase,
          message: typeof error === 'string' ? error : error.message
        }
      };
      this.telemetry.logPhase('pipeline_error', payload.error);
      return payload;
    }
  }

  window.UnifiedAnswerPipeline = UnifiedAnswerPipeline;
})();

;
(function () {
  const CHANNEL = 'humanoid-fetch-monitor';

  function injectMainWorldHook(modelName) {
    if (!document.documentElement) return;
    const script = document.createElement('script');
    const injector = function (channel, model) {
      try {
        const globalState = window.__humanoidFetchMonitor = window.__humanoidFetchMonitor || {
          hooked: false,
          models: [],
          record(modelName) {
            if (!this.models.includes(modelName)) this.models.push(modelName);
          }
        };
        globalState.record(model);
        if (globalState.hooked || typeof window.fetch !== 'function') return;
        const originalFetch = window.fetch;
        globalState.hooked = true;
        window.fetch = async (...args) => {
          const requestInfo = args[0];
          const init = args[1] || {};
          const method = init.method || requestInfo?.method || 'GET';
          const url = typeof requestInfo === 'string' ? requestInfo : requestInfo?.url || '';
          const startedAt = Date.now();
          try {
            const response = await originalFetch(...args);
            const status = Number(response?.status) || 0;
            if (status >= 400) {
              let retryAfter = '';
              try {
                retryAfter = response.headers?.get?.('Retry-After') || '';
              } catch (_) {}
              window.postMessage({
                source: channel,
                status,
                method,
                url,
                retryAfter,
                ok: response?.ok ?? true,
                startedAt,
                endedAt: Date.now(),
                models: globalState.models.slice()
              }, '*');
            }
            return response;
          } catch (error) {
            window.postMessage({
              source: channel,
              status: 0,
              method,
              url,
              retryAfter: '',
              error: error?.message || String(error),
              startedAt,
              endedAt: Date.now(),
              models: globalState.models.slice()
            }, '*');
            throw error;
          }
        };
      } catch (_) {
        /* swallow */
      }
    };
    script.textContent = `(${injector.toString()})(${JSON.stringify(CHANNEL)}, ${JSON.stringify(modelName)});`;
    (document.documentElement || document.head || document.body).appendChild(script);
    script.remove();
  }

  window.setupHumanoidFetchMonitor = function setupHumanoidFetchMonitor(modelName, handler) {
    if (!modelName || typeof handler !== 'function') return;
    const guardKey = `__humanoidFetchBridge_${modelName}`;
    if (window[guardKey]) return;
    window[guardKey] = true;
    injectMainWorldHook(modelName);
    window.addEventListener('message', (event) => {
      if (event.source !== window || !event.data || event.data.source !== CHANNEL) return;
      const payload = event.data;
      if (Array.isArray(payload.models) && !payload.models.includes(modelName)) return;
      handler(payload);
    });
  };
})();
