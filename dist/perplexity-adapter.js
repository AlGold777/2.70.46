// Auto-generated by scripts/build-bundles.js @ 2025-12-02T17:36:09.121Z
(function () {
  const globalObject = typeof window !== 'undefined' ? window : self;
  globalObject.SelectorConfigRegistry = globalObject.SelectorConfigRegistry || {};
  if (globalObject.SelectorConfigRegistry.Perplexity) return;

  globalObject.SelectorConfigRegistry.Perplexity = {
    versions: [],
    emergencyFallbacks: {
      composer: [
        'textarea[aria-label*="Ask"]',
        'textarea',
        'div[role="textbox"]',
        '[contenteditable="true"]'
      ],
      sendButton: [
        'button[aria-label*="Ask"]',
        'button[type="submit"]',
        'button'
      ],
      response: [
        '.answer',
        '.prose',
        'article',
        'main'
      ]
    },
    observationDefaults: {
      rootSelector: 'main',
      targetSelectors: [
        '.answer',
        '.prose',
        'article'
      ],
      stabilizationDelayMs: 1800,
      endGenerationMarkers: [
        { selector: '.loading-indicator', type: 'disappear' }
      ]
    }
  };
})();

;
// content-perplexity.js

//-- Защита от дублирования --//
const resolveExtensionVersion = () => {
  try {
    return chrome?.runtime?.getManifest?.()?.version || 'unknown';
  } catch (_) {
    return 'unknown';
  }
};
if (window.perplexityContentScriptLoaded) {
  console.warn('[content-perplexity] Script already loaded, skipping duplicate initialization');
  throw new Error('Duplicate script load prevented');
}
window.perplexityContentScriptLoaded = {
  timestamp: Date.now(),
  version: resolveExtensionVersion(),
  source: 'content-perplexity'
};
console.log('[content-perplexity] First load, initializing...');
//-- 2. Очистка кэша селекторов на старте -//
chrome.storage.local.remove([
  'selector_cache_Perplexity_inputField',
  'selector_cache_Perplexity_sendButton'
]);

//-- Конец защиты --//

const MODEL = "Perplexity";

window.setupHumanoidFetchMonitor?.(MODEL, ({ status, retryAfter }) => {
  if (status !== 429) return;
  const waitTime = retryAfter ? parseInt(retryAfter, 10) * 1000 || 60000 : 60000;
  chrome.runtime.sendMessage({
    type: 'LLM_RESPONSE',
    llmName: MODEL,
    answer: 'Error: Rate limit detected. Please wait.',
    error: {
      type: 'rate_limit',
      message: `HTTP 429 detected. Suggested wait time: ${waitTime}ms`,
      waitTime
    }
  });
});
const getLifecycleMode = () => {
  if (typeof window !== 'undefined') {
    if (window.__humanoidActivityMode) return window.__humanoidActivityMode;
    if (document?.visibilityState === 'hidden') return 'background';
  }
  return 'interactive';
};
const buildLifecycleContext = (prompt = '', extra = {}) => ({
  promptLength: prompt?.length || 0,
  evaluator: Boolean(extra.evaluator),
  mode: extra.mode || getLifecycleMode()
});
const getForceStopRegistry = () => {
  if (window.__humanoidForceStopRegistry) {
    return window.__humanoidForceStopRegistry;
  }
  const handlers = new Set();
  window.__humanoidForceStopRegistry = {
    register(handler) {
      if (typeof handler !== 'function') return () => {};
      handlers.add(handler);
      return () => handlers.delete(handler);
    },
    run(reason) {
      handlers.forEach((fn) => {
        try { fn(reason); } catch (_) {}
      });
    }
  };
  return window.__humanoidForceStopRegistry;
};
const registerForceStopHandler = (handler) => getForceStopRegistry().register(handler);
const handleForceStopMessage = (traceId) => {
  if (traceId && window.HumanoidEvents?.stop) {
    try {
      window.HumanoidEvents.stop(traceId, { status: 'forced', reason: 'background-force-stop' });
    } catch (_) {}
  }
  getForceStopRegistry().run('background-force-stop');
};

const cleanupScope = window.HumanoidCleanup?.createScope?.(`${MODEL.toLowerCase()}-content`) || {
  trackInterval: (id) => id,
  trackTimeout: (id) => id,
  trackObserver: (observer) => observer,
  trackAbortController: (controller) => controller,
  register: () => () => {},
  addEventListener: () => () => {},
  cleanup: () => {},
  isCleaned: () => false,
  getReason: () => null
};
let scriptStopped = false;
const stopContentScript = (reason = 'manual-stop') => {
  if (scriptStopped) return cleanupScope.getReason?.() || reason;
  scriptStopped = true;
  console.warn('[content-perplexity] Cleanup triggered:', reason);
  try {
    getForceStopRegistry().run(reason);
  } catch (_) {}
  try {
    cleanupScope.cleanup?.(reason);
  } catch (err) {
    console.warn('[content-perplexity] Cleanup scope failed', err);
  }
  try {
    window.perplexityContentScriptLoaded = null;
  } catch (_) {}
  return reason;
};
window.__cleanup_perplexity = stopContentScript;
cleanupScope.addEventListener?.(window, 'pagehide', () => stopContentScript('pagehide'));
cleanupScope.addEventListener?.(window, 'beforeunload', () => stopContentScript('beforeunload'));

//-- V3.0 START: Advanced Content Cleaning System --//
class ContentCleaner {
  constructor() {
    this.cleaningRules = this.initializeCleaningRules();
    this.cleaningStats = { elementsRemoved: 0, charactersRemoved: 0, rulesApplied: 0 };
  }

  initializeCleaningRules() {
    return {
      // UI-элементы и фразы интерфейса
      uiPhrases: [
        /\b(Send|Menu|Settings|New chat|Clear|Like|Reply|Copy|Share|Follow|Subscribe)\b/gi,
        /\b(Upload|Download|Save|Delete|Edit|Search|Filter|Sort)\b/gi,
        /\b(Perplexity|PPLX|Pro Search)\b/gi
      ],
      // Временные метки и даты
      timePatterns: [
        /\b\d{1,2}:\d{2}\s*(?:AM|PM)?\b/gi,
        /\b\d+\s*(?:hours?|minutes?|seconds?)\s*ago\b/gi,
        /\b(?:Just now|Yesterday|Today|Tomorrow)\b/gi
      ],
      // Символы форматирования
      formattingSymbols: [
        /\xa0/g, /&nbsp;/g, /&[a-z]+;/gi
      ],
      // URL
      urlPatterns: [
        /\bhttps?:\/\/[^\s"]+?\b/gi, /\bwww\.[^\s"]+?\b/gi
      ]
    };
  }

  cleanContent(content, options = {}) {
    const startTime = Date.now();
    this.cleaningStats = { elementsRemoved: 0, charactersRemoved: 0, rulesApplied: 0 };
    console.log('[ContentCleaner] Starting content cleaning, initial length:', content.length);

    let textContent = content;
    if (/<\/?[a-z][\s\S]*>/i.test(content)) {
      try {
        const parser = new DOMParser();
        const doc = parser.parseFromString(content, 'text/html');
        doc.querySelectorAll('script,style,svg,canvas,noscript,header,footer,nav,aside,[aria-hidden="true"]').forEach(el => el.remove());
        textContent = doc.body?.textContent || '';
      } catch (err) {
        console.warn('[ContentCleaner] DOMParser failed in Perplexity cleaner, falling back to textContent', err);
        const fallbackDiv = document.createElement('div');
        fallbackDiv.textContent = content;
        textContent = fallbackDiv.textContent || '';
      }
    }

    let cleanedContent = this.cleanTextContent(textContent, options);

    if (options.maxLength && cleanedContent.length > options.maxLength) {
      cleanedContent = this.applyLengthLimit(cleanedContent, options.maxLength);
    }

    const processingTime = Date.now() - startTime;
    console.log(`[ContentCleaner] Cleaning completed in ${processingTime}ms. Final length: ${cleanedContent.length}`);
    return cleanedContent;
  }

  cleanTextContent(textContent, options) {
    let cleanedText = textContent;
    const allRules = [
      ...this.cleaningRules.uiPhrases,
      ...this.cleaningRules.timePatterns,
      ...this.cleaningRules.urlPatterns,
      ...this.cleaningRules.formattingSymbols
    ];

    allRules.forEach(pattern => {
      const originalLength = cleanedText.length;
      cleanedText = cleanedText.replace(pattern, ' ');
      this.recordRemoval(originalLength - cleanedText.length);
    });

    return this.finalNormalization(cleanedText);
  }

  recordRemoval(charactersRemoved) {
    if (charactersRemoved > 0) {
      this.cleaningStats.charactersRemoved += charactersRemoved;
      this.cleaningStats.rulesApplied++;
    }
  }

  applyLengthLimit(content, maxLength) {
    if (content.length <= maxLength) return content;
    const truncated = content.substring(0, maxLength);
    const lastSentenceEnd = Math.max(
      truncated.lastIndexOf('. '), truncated.lastIndexOf('! '),
      truncated.lastIndexOf('? '), truncated.lastIndexOf('\n\n')
    );
    if (lastSentenceEnd > maxLength * 0.7) {
      return truncated.substring(0, lastSentenceEnd + 1) + '\n\n[Content truncated]';
    }
    return truncated + '\n\n[Content truncated]';
  }

  finalNormalization(text) {
    return text
      .replace(/\n\s*\n\s*\n/g, '\n\n')
      .replace(/[ \t]+/g, ' ')
      .trim();
  }

  getCleaningStats() {
    return { ...this.cleaningStats };
  }
}
window.contentCleaner = new ContentCleaner();
//-- V3.0 END: Advanced Content Cleaning System --//

const sleep = (ms) => new Promise((r) => setTimeout(r, ms));
const getHumanoid = () => (typeof window !== 'undefined' ? window.Humanoid : null);
const isUserInteracting = () => {
  if (document.hidden) return true;
  const el = document.activeElement;
  if (!el) return false;
  const tag = el.tagName;
  return tag === 'INPUT' || tag === 'TEXTAREA' || el.isContentEditable;
};
const keepAliveMutex = (() => {
  const key = '__keepAliveMutex';
  if (window[key]) return window[key];
  let locked = false;
  const queue = [];
  const run = async (fn) => {
    if (locked) await new Promise((res) => queue.push(res));
    locked = true;
    try { return await fn(); } finally {
      locked = false;
      const next = queue.shift();
      if (next) next();
    }
  };
  const mutex = { run };
  window[key] = mutex;
  return mutex;
})();

const runLifecycle = (source, context, executor) => {
  if (typeof window.withHumanoidActivity === 'function') {
    return window.withHumanoidActivity(source, context, executor);
  }
  return executor({
    traceId: null,
    heartbeat: () => {},
    stop: () => {},
    error: () => {}
  });
};

const pipelineExpectedLength = (text = '') => {
  const len = (text || '').length;
  if (len > 4000) return 'veryLong';
  if (len > 2000) return 'long';
  if (len > 800) return 'medium';
  return 'short';
};

async function tryPerplexityPipeline(promptText = '', lifecycle = {}) {
  const { heartbeat, stop } = lifecycle || {};
  if (!window.UnifiedAnswerPipeline) return null;
  heartbeat?.({
    stage: 'start',
    expectedLength: pipelineExpectedLength(promptText),
    pipeline: 'UnifiedAnswerPipeline'
  });
  try {
    const pipeline = new window.UnifiedAnswerPipeline('perplexity', {
      expectedLength: pipelineExpectedLength(promptText)
    });
    const result = await pipeline.execute();
    if (result?.success && result.answer) {
      heartbeat?.({
        stage: 'success',
        answerLength: result.answer.length,
        pipeline: 'UnifiedAnswerPipeline'
      });
      if (typeof stop === 'function') {
        await stop({
          status: 'success',
          source: 'pipeline',
          answer: result.answer,
          answerLength: result.answer.length
        });
      }
      return result;
    }
    heartbeat?.({
      stage: 'empty',
      status: 'no-answer',
      pipeline: 'UnifiedAnswerPipeline'
    });
  } catch (err) {
    heartbeat?.({
      stage: 'error',
      error: err?.message || String(err),
      pipeline: 'UnifiedAnswerPipeline'
    });
    console.warn('[content-perplexity] UnifiedAnswerPipeline failed, falling back to legacy watcher', err);
  }
  return null;
}

const startDriftFallback = (intensity = 'soft') => {
  const humanoid = getHumanoid();
  if (humanoid?.startAntiSleepDrift) {
    humanoid.startAntiSleepDrift(intensity);
    return;
  }
  const delta = intensity === 'hard' ? 24 : intensity === 'medium' ? 16 : 10;
  window.scrollBy({ top: (Math.random() > 0.5 ? 1 : -1) * delta, behavior: 'auto' });
};

const stopDriftFallback = () => {
  const humanoid = getHumanoid();
  humanoid?.stopAntiSleepDrift?.();
};

const createKeepAliveHeartbeat = (source) => {
  let traceId = null;
  let cleanupTimer = null;
  return (meta = {}) => {
    const lifecycle = window.HumanoidEvents;
    if (!lifecycle?.start) return;
    if (!traceId) {
      try {
        traceId = lifecycle.start(source, { mode: 'anti-sleep', source });
      } catch (err) {
        console.warn(`[${source}] keepalive trace failed`, err);
        return;
      }
    }
    try {
      lifecycle.heartbeat(traceId, meta.progress || 0, Object.assign({ phase: 'keepalive-pulse' }, meta));
    } catch (err) {
      console.warn(`[${source}] keepalive heartbeat failed`, err);
    }
    if (cleanupTimer) clearTimeout(cleanupTimer);
    cleanupTimer = setTimeout(() => {
      try { lifecycle.stop(traceId, { status: 'idle' }); } catch (_) {}
      traceId = null;
    }, 8000);
  };
};
const emitKeepAliveHeartbeat = createKeepAliveHeartbeat(`${MODEL.toLowerCase()}:keepalive`);

async function perplexityHumanRead(duration = 480) {
  const humanoid = getHumanoid();
  if (humanoid?.readPage) {
    try {
      await humanoid.readPage(duration);
    } catch (err) {
      console.warn('[content-perplexity] Humanoid.readPage failed', err);
    }
  }
}

async function perplexityHumanClick(element) {
  const humanoid = getHumanoid();
  if (!element) return;
  if (humanoid?.click) {
    try {
      await humanoid.click(element);
      return;
    } catch (err) {
      console.warn('[content-perplexity] Humanoid.click failed', err);
    }
  }
  element.click();
}

const runAntiSleepPulse = (intensity = 'soft') => {
  emitKeepAliveHeartbeat({ action: 'keep-alive-ping', intensity, model: MODEL });
  const delta = intensity === 'hard' ? 28 : intensity === 'medium' ? 16 : 8;
  try {
    const Toolkit = window.__UniversalScrollToolkit;
    if (Toolkit) {
      const tk = new Toolkit({ idleThreshold: 800, driftStepMs: 40 });
      tk.keepAliveTick?.((Math.random() > 0.5 ? 1 : -1) * delta);
      return;
    }
  } catch (_) {}
  startDriftFallback(intensity);
};

const perplexityScrollCoordinator = window.ScrollCoordinator
  ? new window.ScrollCoordinator({
      source: `${MODEL.toLowerCase()}-smart-scroll`,
      getLifecycleMode,
      registerForceStopHandler,
      startDrift: () => startDriftFallback('soft'),
      stopDrift: () => stopDriftFallback(),
      logPrefix: `[${MODEL}] SmartScroll`
    })
  : null;

async function withSmartScroll(asyncOperation, options = {}) {
  if (perplexityScrollCoordinator) {
    return perplexityScrollCoordinator.run(asyncOperation, options);
  }
  return asyncOperation();
}

function perplexityTriggerEvents(element, data = '') {
  element.dispatchEvent(new InputEvent('input', { bubbles: true, inputType: 'insertText', data }));
  element.dispatchEvent(new Event('change', { bubbles: true }));
}

function setContentEditableParagraphs(element, text) {
  if (!element) return;
  const doc = element.ownerDocument || document;
  while (element.firstChild) {
    element.removeChild(element.firstChild);
  }
  const lines = String(text).split(/\n/);
  if (!lines.length) {
    const p = doc.createElement('p');
    p.textContent = '\u200B';
    element.appendChild(p);
    return;
  }
  lines.forEach(line => {
    const paragraph = doc.createElement('p');
    paragraph.textContent = line || '\u200B';
    element.appendChild(paragraph);
  });
}

async function fallbackPerplexityType(element, text) {
  try {
    element.focus({ preventScroll: true });
  } catch (_) {
    element.focus?.();
  }
  await sleep(250);
  if ('value' in element) {
    setNativeValue(element, text);
  } else {
    setContentEditableParagraphs(element, text);
  }
  perplexityTriggerEvents(element, text);
  await sleep(150);
}

async function perplexityHumanType(element, text, options = {}) {
  const humanoid = getHumanoid();
  if (humanoid?.typeText) {
    try {
      await humanoid.typeText(element, text, options);
      return;
    } catch (err) {
      console.warn('[content-perplexity] Humanoid.typeText failed', err);
    }
  }
  await fallbackPerplexityType(element, text);
}

// --- ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ ---
function isElementInteractable(element) {
  //-- 4. Нативная установка значения для React-контролируемых textarea -//
function setNativeValue(el, value) {
  const proto = Object.getPrototypeOf(el);
  const setter = Object.getOwnPropertyDescriptor(proto, 'value')?.set
              || Object.getOwnPropertyDescriptor(HTMLTextAreaElement.prototype, 'value')?.set
              || Object.getOwnPropertyDescriptor(HTMLInputElement.prototype, 'value')?.set;
  if (setter) setter.call(el, value);
  el.dispatchEvent(new Event('input', { bubbles: true }));
}

  if (!element) return false;
  if (element.offsetParent === null) return false;
  if (element.getAttribute('disabled') !== null) return false;
  if (element.style.display === 'none') return false;
  if (element.style.visibility === 'hidden') return false;
  const rect = element.getBoundingClientRect();
  return rect.top >= 0 && rect.left >= 0 &&
    rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) &&
    rect.right <= (window.innerWidth || document.documentElement.clientWidth);
}

// --- Self-Healing Selector Logic ---
async function findAndCacheElement(selectorKey, selectorArray, timeout = 30000) {
  const storageKey = `selector_cache_${MODEL}_${selectorKey}`;
  try {
    const result = await chrome.storage.local.get(storageKey);
    const cachedSelector = result[storageKey];
    if (cachedSelector) {
      const el = document.querySelector(cachedSelector);
      if (el && isElementInteractable(el)) {
        console.log(`[Self-Healing] Found element using cached selector for '${selectorKey}'`);
        return el;
      }
    }
  } catch (e) { console.warn('[content-perplexity] Storage access failed, continuing without cache'); }

  const start = Date.now();
  while (Date.now() - start < timeout) {
    for (const selector of selectorArray) {
      try {
        const el = document.querySelector(selector);
        if (el && isElementInteractable(el)) {
          console.log(`[Self-Healing] Found element with '${selector}'. Caching for '${selectorKey}'.`);
          try { await chrome.storage.local.set({ [storageKey]: selector }); } catch (e) {}
          return el;
        }
      } catch (error) { console.warn(`[content-perplexity] Selector error for ${selector}:`, error); }
    }
    await sleep(1000);
  }
  throw new Error(`Element not found for '${selectorKey}' with any selector`);
}

// --- ОСНОВНАЯ ФУНКЦИЯ ОБРАБОТКИ ---
async function injectAndGetResponse(prompt) {
  return runLifecycle('perplexity:inject', buildLifecycleContext(prompt), async (activity) => {
    console.log('[content-perplexity] Starting Perplexity injection process');
    try {
    await sleep(800);

    // Ввод: Perplexity может использовать textarea или contenteditable
    const inputSelectors = [
      'textarea[data-testid="search-input"]',
      'form[role="search"] textarea',
      'form textarea[placeholder*="Ask"]',
      'div[contenteditable="true"][role="textbox"]'
    ];

    // Кнопка отправки (иконка-стрелка, submit, aria-label)
    const sendButtonSelectors = [
      'button[type="submit"]',
      'button[aria-label*="Send"]',
      'button[data-testid="send-button"]',
      'form button:has(svg)',
      'button:has([data-icon="send"])'
    ];

    console.log('[content-perplexity] Looking for input field...');
    activity.heartbeat(0.2, { phase: 'composer-search' });
    const inputField = await findAndCacheElement('inputField', inputSelectors)
      .catch(err => { throw { type: 'selector_not_found', message: 'Perplexity input field not found' }; });

    console.log('[content-perplexity] Input field found. Injecting prompt...');
    await perplexityHumanRead(650);
    await perplexityHumanType(inputField, prompt, { wpm: 120, instant: false });
    activity.heartbeat(0.3, { phase: 'typing' });
    await sleep(100);
    const __val = (inputField.value ?? inputField.textContent ?? '').trim();
    if (!__val.length) {
      throw { type: 'injection_failed', message: 'Textarea did not accept value (React guard).' };
    }




    await sleep(1200); // Даем время кнопке активироваться

    console.log('[content-perplexity] Looking for send button...');
    activity.heartbeat(0.4, { phase: 'send-button-search' });
    let sendButton = await findAndCacheElement('sendButton', sendButtonSelectors).catch(() => null);

    if (sendButton) {
      console.log('[content-perplexity] Clicking send button');
      await perplexityHumanClick(sendButton);
    } else {
      // Фолбэк: отправка через Enter
      console.log('[content-perplexity] Send button not found, using Enter fallback');
      const evt = new KeyboardEvent('keydown', { key: 'Enter', code: 'Enter', keyCode: 13, which: 13, bubbles: true });
      inputField.dispatchEvent(evt);
    }
    activity.heartbeat(0.55, { phase: 'send-dispatched' });

    console.log('[content-perplexity] Message sent, waiting for response...');
    activity.heartbeat(0.6, { phase: 'waiting-response' });

    let pipelineAnswer = null;
    await tryPerplexityPipeline(prompt, {
      heartbeat: (meta = {}) => activity.heartbeat(0.8, Object.assign({ phase: 'pipeline' }, meta)),
      stop: async ({ answer }) => {
        console.log('[content-perplexity] UnifiedAnswerPipeline captured response, skipping legacy watcher');
        const cleanedPipelineResponse = window.contentCleaner.cleanContent(answer, {
          maxLength: 50000
        });
        pipelineAnswer = cleanedPipelineResponse;
        activity.stop({ status: 'success', answerLength: cleanedPipelineResponse.length, source: 'pipeline' });
        return cleanedPipelineResponse;
      }
    });
    if (pipelineAnswer) {
      return pipelineAnswer;
    }

    const response = await withSmartScroll(() => waitForResponse(120000), {
      keepAliveInterval: 2000,
      operationTimeout: 300000,
      debug: false
    });

    // Очистка ответа
    const cleanedResponse = window.contentCleaner.cleanContent(response, {
      maxLength: 50000
    });

    console.log(`[content-perplexity] Process completed. Response length: ${cleanedResponse.length}`);
    activity.heartbeat(0.9, { phase: 'response-processed' });
    activity.stop({ status: 'success', answerLength: cleanedResponse.length });
    return cleanedResponse;

  } catch (error) {
    if (error?.code === 'background-force-stop') {
      activity.error(error, false);
      throw error;
    }
    console.error('[content-perplexity] Error in injectAndGetResponse:', error);
    activity.error(error, true);
    throw error;
  }
  });
}

// --- ОЖИДАНИЕ ОТВЕТА ---
async function waitForResponse(timeout = 120000) {
  const responseSelectors = [
    '.prose',
    '.markdown',
    '[data-testid="answer"] .markdown',
    'article .markdown',
    '[data-testid="thread"] .markdown',
    '.result',
    '.answer'
  ];
  const generatingSelector = '.animate-pulse, .typing-indicator, [data-testid="generation-in-progress"], [aria-busy="true"], .loading, .loader, .dots';

  const readSnapshot = () => {
    let nodes = [];
    for (const sel of responseSelectors) {
      try {
        nodes = document.querySelectorAll(sel);
        if (nodes.length) break;
      } catch (_) {}
    }
    if (!nodes.length) return null;
    const last = nodes[nodes.length - 1];
    const html = last.innerHTML?.trim();
    if (!html) return null;
    const isGenerating = Boolean(document.querySelector(generatingSelector));
    return { html, isGenerating };
  };

  return new Promise((resolve, reject) => {
    let lastHTML = '';
    let stableCount = 0;
    let settled = false;
    const observer = cleanupScope.trackObserver(new MutationObserver(() => evaluate()));
    const intervalId = cleanupScope.trackInterval(setInterval(() => evaluate(), 1200));
    const timerId = cleanupScope.trackTimeout(setTimeout(() => {
      if (settled) return;
      settled = true;
      observer.disconnect();
      clearInterval(intervalId);
      if (lastHTML) {
        console.warn('[content-perplexity] Timeout reached, returning last captured HTML.');
        resolve(lastHTML);
      } else {
        reject(new Error('Timeout: No response received from Perplexity'));
      }
    }, timeout));

    const cleanup = (value) => {
      if (settled) return;
      settled = true;
      observer.disconnect();
      clearInterval(intervalId);
      clearTimeout(timerId);
      resolve(value);
    };

    const evaluate = () => {
      const snapshot = readSnapshot();
      if (!snapshot) return;
      const { html, isGenerating } = snapshot;
      if (isGenerating) {
        lastHTML = html;
        stableCount = 0;
        return;
      }
      if (!lastHTML) lastHTML = html;
      if (html === lastHTML) {
        stableCount += 1;
        if (stableCount >= 2) {
          console.log('[content-perplexity] Response stabilized.');
          cleanup(html);
        }
      } else {
        lastHTML = html;
        stableCount = 0;
      }
    };

    observer.observe(document.body, { childList: true, subtree: true, characterData: true });
    evaluate();
  });
}

// --- ОБРАБОТЧИК СООБЩЕНИЙ ---
const onRuntimeMessage = (message, sender, sendResponse) => {
  if (!message) return false;
  console.log('[content-perplexity] Received:', message.type);

  if (message?.type === 'STOP_AND_CLEANUP') {
    handleForceStopMessage(message.payload?.traceId);
    stopContentScript('manual-toggle');
    if (typeof sendResponse === 'function') {
      sendResponse({ status: 'cleaned', llmName: MODEL });
    }
    return false;
  }

  if (message?.type === 'HUMANOID_FORCE_STOP') {
    handleForceStopMessage(message.payload?.traceId);
    if (typeof sendResponse === 'function') {
      sendResponse({ status: 'force_stop_ack' });
    }
    return false;
  }

  if (message?.type === 'HEALTH_CHECK_PING') {
    sendResponse({ type: 'HEALTH_CHECK_PONG', pingId: message.pingId, llmName: MODEL });
    return true;
  }

  if (message?.type === 'ANTI_SLEEP_PING') {
    if (isUserInteracting()) {
      stopDriftFallback();
      return false;
    }
    keepAliveMutex.run(async () => {
      runAntiSleepPulse(message.intensity || 'soft');
    });
    return false;
  }

  if (message.type === 'GET_ANSWER' || message.type === 'GET_FINAL_ANSWER') {
    injectAndGetResponse(message.prompt)
      .then(result => {
        if (message.isFireAndForget) {
          sendResponse?.({ status: 'success_fire_and_forget' });
          return;
        }
        const responseType = message.type === 'GET_ANSWER' ? 'LLM_RESPONSE' : 'FINAL_LLM_RESPONSE';

        const stats = window.contentCleaner.getCleaningStats();
        chrome.runtime.sendMessage({
          type: 'CONTENT_CLEANING_STATS', llmName: MODEL, stats: stats, timestamp: Date.now()
        });

        chrome.runtime.sendMessage({ type: responseType, llmName: MODEL, answer: result });
        sendResponse?.({ status: 'success' });
      })
      .catch(error => {
        if (error?.code === 'background-force-stop') {
          sendResponse?.({ status: 'force_stopped' });
          return;
        }
        const errorMessage = error.message || 'Unknown error in Perplexity content script';
        const responseType = message.type === 'GET_ANSWER' ? 'LLM_RESPONSE' : 'FINAL_LLM_RESPONSE';

        chrome.runtime.sendMessage({
          type: responseType, llmName: MODEL, answer: `Error: ${errorMessage}`,
          error: { type: error.type || 'generic_error', message: errorMessage }
        });
        sendResponse?.({ status: 'error', message: errorMessage });
      });
    return true; // Для асинхронной обработки
  }

  return false;
};
chrome.runtime.onMessage.addListener(onRuntimeMessage);
cleanupScope.register?.(() => {
  try {
    chrome.runtime.onMessage.removeListener(onRuntimeMessage);
  } catch (_) {}
});

// --- БАЗОВЫЙ HEARTBEAT ДЛЯ АКТИВНОСТИ ---
function startBasicHeartbeat() { return; }

console.log('[content-perplexity] Initialization complete');
