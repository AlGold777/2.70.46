

Данные в секции «Telemetry Storage» (и вообще «телеметрия» в этом UI) появляются потому, что разные части расширения (content‑скрипты и background) записывают события/логи в хранилище браузера или пересылают их в background; popup затем читает эти записи через chrome.storage.local или запрашивает агрегированную статистику у background и рендерит их в UI.
Детально — поток данных и где смотреть в коде

Источник событий (кто пишет)
Content‑скрипты (например humanoid.js, unified-answer-pipeline.js, другие модули) регистрируют события в «телеметрическом автобусе». В humanoid.js есть сборщик:

humanoidTelemetry.log(...) — собирает события в память и периодически вызывает flush().
flush() отправляет пачку в background: chrome.runtime.sendMessage({ type: 'HUMANOID_TELEMETRY', data: { sessionId, schema, events: batch } }).
(Файл: humanoid.js, функции log/flush — см. раздел «Unified Telemetry Bus».)
Другие модули могут отправлять сообщения вида TELEMETRY_EVENT, SCROLL_TELEMETRY или HUMANOID_EVENT — background обрабатывает эти сообщения и иногда сохраняет агрегаты/метрики.

Что делает background
Background принимает сообщения и может:
обновлять внутренние счётчики/метрики (например selectorResolutionMetrics),
сохранять более долговременные данные в chrome.storage.local (есть в проекте helper для telemetry — в background.js, см. блок с STORAGE_KEY = 'telemetry'),
отвечать на запросы popup (см. case 'REQUEST_SELECTOR_TELEMETRY' в background.js — background возвращает агрегированную метрику selectorResolutionMetrics).
Как UI (popup / results.js) получает и отображает данные
Для агрегированных метрик селекторов:

results.js вызывает chrome.runtime.sendMessage({ type: 'REQUEST_SELECTOR_TELEMETRY' }) → background отвечает { status:'ok', metrics } → results.js вызывает renderTelemetryTable(metrics) и заполняет таблицу.
(Функции: requestSelectorTelemetry() и renderTelemetryTable() в results.js.)
Для «сырых» логов (те, которые мы называли __humanoid_init_events_v1):

В текущей реализации кнопки Export/Copy/Load/Clear в results.js читают/пишут непосредственно chrome.storage.local под ключом __humanoid_init_events_v1. Код чтения находится в attachTelemetryButtons() в results.js (переменная telemetryKey = '__humanoid_init_events_v1').
То есть: кто‑то (content или background) должен был ранее положить массив записей в chrome.storage.local['__humanoid_init_events_v1']; наши кнопки просто читают этот массив и экспортируют/копируют/загружают/удаляют его.
Итого — последовательность, проще:
Событие происходит (content script или pipeline) → модуль логирует (humanoidTelemetry.log / telemetry.logPhase / sendMessage) → событие либо отправляется в background (через chrome.runtime.sendMessage) либо background сам его пишет в chrome.storage.local → popup:
либо делает запрос (REQUEST_SELECTOR_TELEMETRY) и получает агрегат для таблицы,
либо читает напрямую chrome.storage.local['__humanoid_init_events_v1'] и показывает/экспортирует сырые логи.
Как это проверить вручную (быстрая проверка в popup или в консоли)

В консоли background (или в devtools popup) выполнить:

chrome.storage.local.get(['__humanoid_init_events_v1'], console.log)
— увидите массив записей (или {} / пустой массив, если ничего нет).

Проверить, что background отдаёт метрики селекторов:

chrome.runtime.sendMessage({ type: 'REQUEST_SELECTOR_TELEMETRY' }, (resp) => console.log(resp));
Где точно смотреть в проекте (файлы / функции)

Отправка из content → background:

humanoid.js — humanoidTelemetry.log(...) и flush() (отправляет HUMANOID_TELEMETRY).
Другие content‑скрипты: unified-answer-pipeline.js, pipeline-modules.js — используемый Telemetry API (sendMessage с типами TELEMETRY_EVENT/METRIC_EVENT и т.д.).
Приём и хранение в background:

background.js — обработчики сообщений (например case 'REQUEST_SELECTOR_TELEMETRY' возвращает selectorResolutionMetrics). В этом файле также есть helper для лёгкой записи в chrome.storage.local (переменная STORAGE_KEY = 'telemetry' и функции записи в ту структуру).
Отображение в popup:

results.js:
requestSelectorTelemetry() / renderTelemetryTable() — для таблицы selector telemetry;
attachTelemetryButtons() — чтение/экспорт/копирование/загрузка/очистка __humanoid_init_events_v1.
Почему вы можете видеть «ничего» в поле

Возможные причины:
Никто ещё не записал события в __humanoid_init_events_v1 (т.е. массив пуст).
Телеметрия может собираться, но background не сохраняет её в тот конкретный ключ (в проекте пока есть несколько механизмов и ключей — telemetry, __answer_pipeline_telemetry, __humanoid_init_events_v1). Нужно проверить, какой ключ используют конкретные модули.
Компилированный бандл (content-lib.js) всё ещё может содержать старую логику записи — после правок source нужно пересобрать dist, чтобы runtime поведение соответствовало исходникам.
Что сделать, если хотите, чтобы поле автоматически показывало JSON

Сейчас кнопки работают с chrome.storage.local напрямую (Export/Copy), но UI не рендерит «сырое» JSON в текстовое поле. Я могу:
Добавить автозагрузку содержимого __humanoid_init_events_v1 в текстовое поле/<pre> при открытии вкладки Storage (и кнопку «Обновить»), или
Сделать кнопку Refresh, которая читает storage и показывает JSON в модальном блоке.
Скажите, нужно ли добавлять автопоказ JSON прямо в UI — сделаю небольшой и безопасный патч.
Если хотите, я могу сейчас:

Быстро проверить (и показать) какие ключи и сколько записей есть в chrome.storage.local в вашем рабочем окружении (покажите, куда вы хотите увидеть вывод: popup DevTools console или background console).
Или добавить автопоказ JSON в Storage panel.
Подсказка на будущее

Чтобы понять «какой модуль пишет в какой ключ», лучше всего: воспроизвести проблему, открыть background console (в chrome://extensions → "Inspect views: background page") и смотреть логи при попытке записать. Я могу помочь сформировать короткий чек‑лист для отладки.





Кратко: что это и зачем

Вкладка "Storage" хранит детальные технические записи (логи событий), которые показывают последовательность действий (когда и что произошло). Это полезно для воспроизведения ошибок и детальной диагностики; в отличие от карточки "Diagnostics", которая даёт общую сводку состояния, Storage показывает «сырые» шаги и коды ошибок в хронологическом порядке.

Руководство для пользователя: вкладка "Storage"

Практическое назначение вкладки "Storage"

Ниже — простое и понятное объяснение, зачем обычному пользователю нужна эта вкладка. Если вы не программист, прочтите этот раздел — он даёт несколько реальных сценариев использования.

- Диагностика проблем: если расширение работает некорректно (висит, не отвечает, появляются ошибки), вы можете экспортировать текущие записи и отправить файл разработчику. Это облегчает и ускоряет поиск причины.

- Поддержка и отчёты: служба поддержки часто просит файл с логами. Вы используете Export или Copy, чтобы предоставить точные данные о том, что происходило на вашем устройстве.

- Восстановление после удаления: если вы заранее сохранили файл настроек/логов, можно загрузить его через Load — это восстанавливает прежнее состояние.

- Контроль приватности: если вы хотите убедиться, что расширение не хранит ничего лишнего, вкладка показывает эти записи. При желании вы можете удалить их кнопкой Clear.

Примеры действий в реальном мире:

1) "Расширение стало медленным/не запускается": экспортируйте логи и отправьте файл в техподдержку.
2) "Техподдержка просит данные": нажмите Copy и вставьте данные в чат или нажмите Export и прикрепите файл.
3) "Хочу удалить всё, что сохранено": нажмите Clear и подтвердите — данные будут удалены.

Короткое практическое правило:
- Если нужно показать что случилось — Export.
- Если нужно быстро вставить в сообщение — Copy.
- Если нужно восстановить — Load (только доверенные файлы).
- Если нужно удалить — Clear.

Что это за записи и в чём их практическая ценность

Очень важно понять — экспортируемый файл содержит не «ваши переписки» и не тексты, которые вы вводили в сервисы, а технические записи (логи). Ниже объяснение простыми словами и пример, чтобы стало ясно, зачем это нужно.

- Что обычно хранится в каждой записи (очень простым языком):
  - Время (когда произошло событие).
  - Тип события (например: отправка команды на инициализацию, получение ответа, обнаруженная ошибка).
  - Короткая метка состояния (например: sent, received, initialized, error).
  - Номер/идентификатор вкладки или сессии (чтобы понять, на какой вкладке случилась проблема).
  - Короткое текстовое сообщение или код ошибки (если что‑то пошло не так).

- Зачем это полезно разработчику и вам:
  - Воспроизведение ошибки: разработчик видит временные метки и последовательность событий (сначала отправка, потом ошибка) — это часто позволяет воспроизвести проблему.
  - Поиск закономерностей: если у многих пользователей одна и та же запись с ошибкой — это указывает на баг, а не на случайный сбой у одного человека.
  - Быстрая локализация: метка вкладки/сессии и код ошибки помогают понять, в каком месте кода возникла проблема.

- Маленький пример (упрощённый) одной записи в JSON:

```json
{
  "timestamp": "2025-11-28T12:34:56.789Z",
  "event": "HUMANOID_INIT",
  "status": "received",
  "tabId": 123,
  "message": "init message received from background",
  "error": null
}
```

Ещё пример ошибки:

```json
{
  "timestamp": "2025-11-28T12:35:01.001Z",
  "event": "HUMANOID_INIT",
  "status": "init_error",
  "tabId": 123,
  "message": "failed to initialize overlay",
  "error": "TypeError: Cannot read property 'foo' of undefined"
}
```

Как понять, полезен ли экспорт для поддержки
- Если в файле есть записи с пометкой `error` или много повторяющихся записей `init_error` — это ценный материал для разработчика.
- Если есть плотная последовательность записей (много событий за короткий промежуток) — это указывает на нестабильность.
- Если файл пуст (`[]`) — проблем с инициализацией/логированием не зафиксировано, смысла отправлять его меньше.

Как подготовить файл к отправке, если вы беспокоитесь о конфиденциальности
- Откройте экспортированный файл в обычном текстовом редакторе (Например: Блокнот, TextEdit, VSCode).
- Посмотрите, есть ли там какие‑то строки, которые явно содержат личные данные (имена, фрагменты текста чатов и т.п.). В большинстве случаев таких данных там не будет.
- Если вы видите чувствительную информацию, удалите вручную те строки или перед отправкой замените их в редакторе (например, заменой текста на `[REDACTED]`).
- После правки сохраните файл и отправьте уже исправленный вариант.

Кому всё это полезно: кратко
- Вам — чтобы быстрее получить помощь и снова вернуть расширение в рабочее состояние.
- Разработчику — чтобы точнее диагностировать и исправить баги, опираясь на реальные события из вашего браузера.

Коротко о терминах
- Телеметрия: это данные, которые расширение может записывать о том, как и когда оно запускалось. Обычно это небольшие записи (время, событие), которые помогают разработчикам понять поведение расширения. Вы ничего не обязаны сохранять.
- Local storage (локальное хранилище): место в вашем браузере, где расширение сохраняет эти записи. Это хранится только на вашем компьютере, а не где-то в интернете (если специально не настроено иначе).

Какие кнопки есть и что они делают
1) Export (Экспорт)
   - Что делает: скачивает текущие записи телеметрии в файл JSON на ваш компьютер.
   - Когда использовать: если вы хотите сохранить копию данных для анализа или переслать её разработчику.
   - Что будет видно: откроется окно сохранения файла, имя будет выглядеть как humanoid_init_events_<временная_метка>.json. Если данных нет — скачанный файл будет содержать пустой массив `[]`.

2) Copy (Копировать)
   - Что делает: копирует данные телеметрии как текст JSON в буфер обмена (т.е. чтобы вы могли вставить их в письмо или чат).
   - Когда использовать: если нужно быстро вставить данные в сообщение разработчику.
   - Что будет видно: после успешного копирования на кнопке может появиться небольшая метка (например, ✅) — это означает, что копирование прошло успешно. Если копирование не поддерживается вашим окружением, появится всплывающее окно с данными, которое вы можете скопировать вручную.

3) Load (Загрузить)
   - Что делает: позволяет выбрать JSON-файл с компьютера и загрузить его в локальное хранилище расширения — данные из файла будут добавлены к уже существующим записям.
   - Когда использовать: если разработчик или вы отправили себе заранее сохранённый файл с данными и хотите восстановить их в расширении.
   - Как работает: после выбора файла данные будут объединены с текущими записями; старые записи не удаляются. Чтобы избежать сильного роста, расширение может хранить только последнее N записей (например, 50).
   - Важное предупреждение: загружайте только те файлы, которым вы доверяете. Не загружайте файлы, скачанные из неизвестных источников.

4) Clear (Очистить)
   - Что делает: удаляет все текущие записи телеметрии из локального хранилища расширения.
   - Когда использовать: если вы не хотите больше хранить эти записи на своём компьютере.
   - Что будет видно: перед удалением появится диалог подтверждения ("Вы уверены?"). Если подтвердите — данные будут удалены.

Пошаговые инструкции

A. Как экспортировать данные
1. Откройте расширение (иконка в панели браузера) и переключитесь в модальное окно DevTools → вкладка "Storage".
2. Нажмите кнопку "Export" (Экспорт).
3. Появится диалог сохранения файла — выберите папку и нажмите "Сохранить".
4. Проверка: откройте сохранённый файл в текстовом редакторе — он должен содержать массив JSON с записями.

B. Как скопировать данные в буфер обмена
1. На той же вкладке нажмите кнопку "Copy" (Копировать).
2. Если копирование прошло успешно, вы увидите небольшую подсказку (например, иконку ✅) на кнопке.
3. Вставьте (Cmd+V) содержимое в окно сообщения, почтовый клиент или любой текстовый редактор.

C. Как загрузить файл с данными
1. Нажмите кнопку "Load" (Загрузить).
2. Откроется файл-диалог: выберите JSON-файл с данными телеметрии (обычно тот же файл, который вы ранее скачали через Export).
3. После загрузки появится сообщение об успешной загрузке (или небольшое уведомление). Данные объединятся с теми, что уже сохранены.

D. Как очистить данные
1. Нажмите кнопку "Clear" (Очистить).
2. Появится окно с подтверждением: подтвердите действие, если вы действительно хотите удалить данные.
3. После подтверждения все записи удалятся.

Частные случаи и ответы на вопросы
- "У меня пусто — что делать?"
  Это нормально. Если вы видите пустой массив (`[]`) в экспортированном файле, значит телеметрия пока не записывала событий. Нет ничего страшного.

- "Почему мне предлагают загрузить файл?"
  Загрузка нужна, если вы хотите восстановить или объединить данные, которые были сохранены ранее. Загрузку стоит делать только для доверенных файлов.

- "Куда уходят эти данные — в интернет?"
  В обычной ситуации эти данные хранятся локально в вашем браузере. Они не отправляются наружу автоматически. Если разработчик специально не настроил отправку, данные останутся на вашем компьютере.

- "Могу ли я удалить эти данные навсегда?"
  Да — кнопка Clear удалит их из локального хранилища расширения. Также вы можете очистить данные расширения целиком через настройки браузера → расширения → очистить данные расширения.

Безопасность и конфиденциальность
- Никаких персональных данных (имён, паролей, содержимого ваших текстов) расширение обычно не записывает — только технические записи о запуске/инициализации. Если вы заметили что-то личное в экспортируемом JSON-файле — не загружайте его в публичные места.
- Никогда не загружайте (Load) файлы из сомнительных источников.

Если что-то не работает
1. Кнопки не реагируют — попробуйте закрыть и открыть попап расширения заново.
2. Если при нажатии вы видите сообщение об ошибке — скопируйте текст ошибки и отправьте разработчику вместе с экспортом (`Export`) — это поможет исследовать проблему.
3. Если вы не уверены, что файл в корректном формате, откройте его в простом текстовом редакторе — он должен быть читаемым JSON (начинается с `[` и заканчивается на `]`).

Контакты и помощь
- Если вам нужна помощь: сохраните файл через Export и приложите его к сообщению разработчику вместе с описанием проблемы и скриншотом.

Часто используемые советы (для начинающих)
- Не паникуйте: действия Export, Copy и Clear — безопасны и выполняются локально.
- Export и Copy полезны, если вы хотите показать разработчику, что именно происходит.
- Load используйте только если вам скажут конкретно какой файл загрузить (например, техподдержка).

Конец инструкции — краткое резюме
- Export = сохранить файл с данными
- Copy = скопировать данные в буфер обмена
- Load = загрузить файл в расширение (только доверенные файлы)
- Clear = удалить данные локально


