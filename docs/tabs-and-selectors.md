# Tabs & Selectors — текущая архитектура и тайминги

Этот документ фиксирует логику работы с вкладками моделей и подсистемой селекторов (какая цепочка вызовов, какие таймауты, что смотреть в диагностике).

## 1) Вкладки (Tabs)

### 1.1. Основные сущности
- `LLM_TARGETS` (`background.js`): список платформ, стартовый URL, `queryPatterns` и правила допустимых URL для attach/reuse.
- `TabMapManager` (`background.js`): persist‑карта `LLM → tabId` (через `chrome.storage.local`).
- Results tab singleton (`background.js`): `result_new.html` открывается/фокусируется как единичная вкладка.

### 1.1.1. Сообщения (IPC) — что куда летит
- UI → background:
  - `START_FULLPAGE_PROCESS` — старт мульти‑запроса по выбранным платформам.
  - `SUBMIT_PROMPT` — отправка команды в LLM вкладки через `EXECUTE_COMMAND` (DevTools/Commands).
- background → content:
  - `GET_ANSWER` — вставить промпт и отправить.
  - `STOP_ALL` / `STOP_AND_CLEANUP` — остановка и очистка.
  - `HEALTH_CHECK_PING` — проверка, что контент‑скрипт жив.
- content → background:
  - `PROMPT_SUBMITTED` — подтверждение, что “Send” реально инициирован (клик/Enter прошёл).
  - `LLM_RESPONSE` — итоговый текст ответа (или ошибка).

### 1.2. Проблема “залипания фокуса”
Симптомы:
- фокус остаётся на одной вкладке “навсегда”;
- часть вкладок не получает промпт, пока пользователь вручную не активирует вкладку.

Причины:
- параллельные источники активации вкладок (фон + пайплайн в контенте + human‑presence цикл) создают “войну фокусов”;
- без гарантии, что вкладка активна, UI некоторых сайтов не принимает ввод/клик (или события не отрабатывают), из‑за чего промпт фактически ставится только после ручной активации.

### 1.3. Диспетчер отправки промпта (Prompt dispatch coordinator)
Цель: гарантировать доставку промпта и исключить thrash фокуса.

Поток для каждой модели (`background.js`):
1) (опционально) активировать окно+вкладку модели (`chrome.windows.update` + `chrome.tabs.update(active=true)`) — только при включённом `allow_focus_steal_enabled` и когда браузер в фокусе; по умолчанию dispatch идёт в фоне без смены активной вкладки;
2) дождаться готовности контент‑скрипта (`HEALTH_CHECK_PING`) не более `SEND_PROMPT_DELAY_MS` (сейчас 5s);
3) отправить `GET_ANSWER` в контент;
4) дождаться подтверждения “клик Send реально произошёл” (`PROMPT_SUBMITTED`) в пределах таймаута (ожидание не блокирует очередь отправки);
5) (опционально) вернуть фокус на results вкладку — только при включённом `allow_focus_steal_enabled` и когда браузер в фокусе.

Сериализация:
- per‑model mutex сериализует dispatch внутри одной модели, чтобы повторные попытки не перекрывались;
- отдельный focus‑mutex сериализует фазу “активация вкладки → доставка `GET_ANSWER`” между моделями, чтобы не было гонок фокуса и потерь `PROMPT_SUBMITTED`;
- ожидание `PROMPT_SUBMITTED` идёт параллельно (вне mutex), чтобы логин/капча/зависшая вкладка одной платформы не стопорили отправку в остальные модели.

Automation window (изоляция вкладок моделей):
- когда `allow_focus_steal_enabled=false` (дефолт), фон создаёт отдельное окно для вкладок LLM (automation window) и открывает LLM вкладки там;
- внутри automation window фон может делать `tabs.update(active=true)` для вкладок LLM без переключения пользователя (окно не фокусируется), чтобы снизить фоновые тормоза UI.

Тайминги (background):
- `SEND_PROMPT_DELAY_MS` — максимум ожидания готовности контент‑скрипта перед первой попыткой отправки промпта (сейчас 5s).
- `PROMPT_SUBMITTED` timeout — максимум ожидания подтверждения “клик отправки произошёл”:
  - дефолт: 7s,
  - overrides: Grok/Qwen/DeepSeek — 9s (медленный UI).
  - override: GPT — 12s (если Send/React “созревает” позже).

Retry/циклы:
- если `PROMPT_SUBMITTED` не приходит, фон не “останавливается навсегда”: работает supervisor‑цикл, который переотправляет `GET_ANSWER` в те же вкладки с backoff (до `DISPATCH_MAX_ATTEMPTS`).

### 1.3.1. Guard по URL и готовности вкладки (v2.54.6 — 2025-12-20 23:07 UTC)
Назначение: не цепляться за “чужие” страницы на общих доменах (например, `x.com`) и не отправлять в вкладки, которые выгружены или ещё грузятся.
- `LLM_TARGETS.attachUrlAllowPrefixes` + fallback на `queryPatterns` → фильтр допустимых URL для attach/reuse.
- Grok: разрешены только `https://grok.com/` и `https://x.com/i/grok...`, чтобы не брать обычные страницы X.
- `ensureTabReadyForDispatch()` ждёт `status=complete` и делает reload для `discarded`, после чего повторно проверяет URL/статус.

### 1.3.2. Диагностика вкладок при dispatch/attach (v2.54.6 — 2025-12-20 23:07 UTC)
Назначение: быстро видеть причину “не отправилось” без ручной проверки вкладки.
- Снимок вкладки (url/status/discarded/lastAccessed) добавляется в логи при attach/reuse и при таймауте `PROMPT_SUBMITTED`.

### 1.3.3. Per-model dispatch locks + conservative модели (v2.54.24 — 2025-12-22 23:14 UTC)
Назначение: снизить взаимные блокировки между моделями и не провоцировать антибот-защиту.
- Mutex теперь per‑model, а блокировка фокуса применяется только на фазе “activate → send”.
- `CONSERVATIVE_MODELS`: добавлены `Qwen`, `DeepSeek` для более мягких backoff‑таймингов.

### 1.4. PROMPT_SUBMITTED (сигнал из контента)
Контент‑скрипт после “Send” (клик кнопки/Enter‑fallback) шлёт:
- `chrome.runtime.sendMessage({ type: 'PROMPT_SUBMITTED', llmName: MODEL, ts })`.

Зачем:
- фон фиксирует “промпт реально отправлен” и безопасно переходит к следующей вкладке;
- убирается зависимость от ручной активации и от косвенных признаков типа `messageSent`.

### 1.4.1. Почему без PROMPT_SUBMITTED бывает “отправилось только после ручного клика”
На части сайтов:
- кнопка Send/поле ввода могут быть “инертными” пока вкладка не активна (фоновые вкладки режутся, теряется focus/IME, события не проходят);
- клик по кнопке может не привести к отправке, пока UI не “созрел” (disabled → enabled позже).

`PROMPT_SUBMITTED` даёт фону сигнал, что отправка реально инициирована, а не “мы попытались вызвать код”.

### 1.5. Human presence loop
Это отдельный механизм “посещения вкладок” для поддержания активности/скролла.

Важно:
- во время dispatch‑очереди human presence loop принудительно выключается, чтобы не перебивать фокус.
- когда dispatch завершён, human loop может быть включён только если остались pending‑вкладки и нет активного dispatch.
- по умолчанию human loop не активирует вкладки/окна; форс‑фокус возможен только при `allow_focus_steal_enabled` и когда браузер в фокусе.

### 1.6. Anti‑sleep / keepalive (контент)
Контент‑скрипты получают `ANTI_SLEEP_PING`, но могут его игнорировать если:
- пользователь реально взаимодействует с вкладкой (`isUserInteracting()`),
- сессия жёстко остановлена (`__LLMScrollHardStop`).
Это важно при отладке “почему вкладка не отвечает”: анти‑sleep не должен мешать пользователю и не должен нарушать HARD_STOP.

### 1.7. Телеметрия вкладок (v2.54.7 — 2025-12-21 06:40 UTC)
Назначение: получить полную цепочку событий по вкладкам без ручного дебага.
- Введены системные события `RUN_START`, `TAB_CREATED/ATTACHED/REUSE`, `TAB_READY_*`, `DISPATCH_*`, `PROMPT_SUBMITTED_*`, `SCRIPT_HEALTH_*`.
- Все события пишутся в diagnostics‑лог и содержат `extVersion`, `sessionId`, `requestId`, `tabId`.
- Подробная схема и список событий: `docs/telemetry.md`.

### 1.7.1. Диагностика метаданных и pipeline‑фаз (v2.54.8 — 2025-12-21 06:59 UTC)
Назначение: видеть метаданные (snapshot/тайминги) и фазы pipeline прямо в diagnostics UI.
- Diagnostics UI отображает `meta` JSON у каждой записи.
- UnifiedAnswerPipeline отправляет `PIPELINE_*` события, привязанные к `llmName`.

## 2) Селекторы (Selectors)

### 2.1. Источник конфигурации
- `selectors/config-bundle.js`: единый бандл селекторов по платформам/версиям UI.
- `SelectorConfig`/`SelectorFinder`: слой выбора селекторов (кэш/версионные/автодискавери/аварийные).

### 2.2. Кэширование и устаревание
- `ContentUtils.findAndCacheElement`: кэширует успешный селектор в `localStorage` с версионным ключом и чистит stale‑ключи при смене версии.

### 2.3. Overrides
- В DevTools можно сохранять override на (model, element), чтобы быстро чинить поломанные UI‑изменения без пересборки бандла.
- Перед сохранением используется проверка селектора на активной вкладке и фиксируется причина/тикет в истории изменений.

### 2.4. Selector Health (DevTools)
- Панель Selector Health показывает реальную картину работы селекторов: распределение L1–L4, долю fail/error, число семплов, время обновления.
- В строке модели/элемента видны последние override и результаты health‑check.
- Данные локальные (chrome.storage), поэтому для доверия к метрикам важен объём семплов.
- Доступны копирование таблицы и экспорт JSON для быстрой передачи статуса.
- Метрики селекторов пишутся батчами с отложенной записью в storage, чтобы снижать нагрузку на прод.

### 2.5. Circuit / health
- `SelectorCircuit`: умеет “выключать” плохие селекторы по статистике ошибок (чтобы не тратить время на заведомо битые варианты).
- Health checks: контент‑скрипты отвечают на `HEALTH_CHECK_PING`, фон использует это для ожидания готовности при доставке промпта.

### 2.6. Verbose selector diagnostics (v2.54.24 — 2025-12-22 23:14 UTC)
Назначение: видеть список попыток селекторов, тайминги и DOM‑контекст при фейлах.
- Включение: `LLMExtension.flags.verboseSelectors = true` или `localStorage.__verbose_selectors = 'true'`.
- В `SELECTOR_RESOLVE_*` мета появляется `attempts` (по слоям), `timing`, `domSnapshot`.

### 2.7. Практика: “где чинить селектор”
- если “не находится поле ввода/кнопка” — сначала override в DevTools (быстро), потом фиксим в `selectors/config-bundle.json` и пересобираем бандл (стабильно).

## 3) Где смотреть, если снова “не ставится промпт”
1) DevTools → Diagnostics: события `DISPATCH` (фон) и наличие `PROMPT_SUBMITTED` (контент).
2) Если `PROMPT_SUBMITTED` таймаутится:
   - проверь, что вкладка реально активируется (видеонаблюдение/лог),
   - увеличь timeout override для конкретной модели,
   - проверь в console платформы, что кнопка send/composer реально находится селекторами.
3) Если `HEALTH_CHECK_PING` не проходит: контент‑скрипт не загружен (matches/manifest) или страница не того домена.

## 4) Ссылки
- Тайминги (sleep/таймауты): `docs/timing-map.md`
- История изменений: `docs/change-log-codex.md`
- Известные проблемы инъекции: `docs/llm-tab-injection-issues.md`
