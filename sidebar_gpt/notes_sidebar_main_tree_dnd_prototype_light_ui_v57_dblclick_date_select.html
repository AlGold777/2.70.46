<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Notes Organizer ‚Äî Sidebar + Main (Tree DnD)</title>
  <style>
    :root{
      --bg:#f6f8fc;
      --panel:#ffffff;
      --panel2:#f3f6fb;
      --text:#111827;
      --muted:#5b677a;
      --border:rgba(17,24,39,.10);
      --border2:rgba(17,24,39,.14);
      --shadow:0 16px 40px rgba(17,24,39,.12);
      --radius:14px;
      --rowH:34px;
    }
*{box-sizing:border-box}
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
      background: radial-gradient(1200px 700px at 20% 0%, #ffffff 0%, var(--bg) 60%) fixed;
color:var(--text);
      height:100vh;
      overflow:hidden;
    }
    .app{
      display:flex;
      height:100vh;
      width:100vw;
    }

    /* Sidebar */
    .sidebar{
      width:340px;
      min-width:280px;
      max-width:520px;
      display:flex;
      flex-direction:column;
      border-right:1px solid var(--border);
      background: rgba(255,255,255,.92);
      backdrop-filter: blur(10px);
    }
    .sb-top{
      padding:12px 12px 10px;
      border-bottom:1px solid var(--border);
      position:sticky;
      top:0;
      background: rgba(255,255,255,.98);
      z-index:5;
    }
    .sb-title{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      margin-bottom:0px;
    }
    .sb-title h1{
      margin:0;
      font-size:13px;
      font-weight:750;
      letter-spacing:.2px;
    }
    .pill{
      font-size:11px;
      color:var(--muted);
      border:1px solid var(--border);
      padding:3px 8px;
      border-radius:999px;
      background: rgba(17,24,39,.04);
      white-space:nowrap;
    }
    .sb-actions{
      display:flex;
      gap:8px;
      align-items:center;
      margin-bottom:10px;
      flex-wrap:wrap;
    }
    .btn{
      border:1px solid var(--border);
      height:32px;
      min-width:32px;
      padding:0 10px;

      background: linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.04));
      color:var(--text);
      padding:7px 9px;
      border-radius:10px;
      cursor:pointer;
      font-weight:700;
      font-size:12px;
      box-shadow: 0 10px 18px rgba(0,0,0,.18);
      user-select:none;
    }
    .btn:hover{filter:brightness(1.05)}
    .btn:active{transform: translateY(1px)}
    .btn.ghost{
      background: rgba(17,24,39,.03);
      box-shadow:none;
    }
    .search{
      display:flex;
      gap:8px;
      align-items:center;
    }
    .search input{
      width:100%;
      border:1px solid rgba(17,24,39,.14);
      background: rgba(17,24,39,.03);
      color:var(--text);
      padding:9px 10px;
      border-radius:12px;
      outline:none;
      font-size:12px;
    }
    .search input:focus{border-color: rgba(255,255,255,.20)}
    .tree{
      padding: 8px 3px 10px;
      overflow:auto;
      height:100%;
    }
    .hint{
      color:var(--muted);
      font-size:12px;
      padding:10px;
      border:1px dashed rgba(255,255,255,.14);
      border-radius:12px;
      background: rgba(17,24,39,.02);
      margin:8px;
    }

    /* Tree rows */
    .node{
      display:flex;
      flex-direction:column;
      gap:0px;
      }
    .children{
      margin-left:14px;
      padding-left:10px;
      border-left:1px dashed rgba(255,255,255,.12);
      display:flex;
      flex-direction:column;
      gap:0px;
      }
    .children.empty{min-height:8px}
    .row{
      height:var(--rowH);
      display:flex;
      align-items:center;
      gap:8px;
      padding:0 8px;
      background: rgba(255,255,255,.92);
      box-shadow:none;
      user-select:none;
      touch-action:none;
      cursor:default;
      position:relative;
    
      border-top:1px solid rgba(17,24,39,.10);
      border-bottom:1px solid rgba(17,24,39,.10);
    }
    .row:hover{filter:brightness(1.04)}
    .row.selected{
      border-color: rgba(37,99,235,.45);
      box-shadow:none;
    }
    .chev{
      width:18px;
      height:20px;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      border-radius:8px;
      border:1px solid rgba(17,24,39,.12);
      background: rgba(17,24,39,.03);
      color:var(--muted);
      font-size:12px;
      flex:0 0 auto;
      user-select:none;
    }
    .chev.invisible{
      opacity:0;
      border-color: transparent;
      background: transparent;
    }
    .handle{
      width:22px;height:27px;
      border-radius:9px;
      border:1px solid rgba(17,24,39,.12);
      background: rgba(17,24,39,.03);
      display:inline-flex;
      align-items:center;
      justify-content:center;
      cursor:grab;
      flex:0 0 auto;
      color:var(--muted);
      font-size:12px;
    }
    .handle:active{cursor:grabbing}
    .title{
      flex:1 1 auto;
      min-width:0;
      font-size:13px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .meta{
      flex:0 0 auto;
      font-size:11px;
      color:var(--muted);
      opacity:.9;
    }

    /* Drop visuals */
    .drop-child{
      outline:2px solid rgba(37,99,235,.45);
      filter:brightness(1.07);
    }
    .drop-sibling{
      outline:2px dashed rgba(255,255,255,.22);
    }
    .placeholder{
      border:2px dashed rgba(255,255,255,.18);
      background: rgba(17,24,39,.03);
      border-radius:12px;
      height:var(--rowH);
    }
    .drag-ghost{
      position:fixed;
      left:0;top:0;
      width:320px;
      pointer-events:none;
      transform:translate(-9999px,-9999px);
      opacity:.90;
      z-index:9999;
    }
    .dragging-original{opacity:.25}

    /* Main */
    .main{
      flex:1 1 auto;
      display:flex;
      flex-direction:column;
      background: rgba(246,248,252,1);
    }
    .main-top{
      padding:14px 16px 12px;
      border-bottom:1px solid var(--border);
      background: rgba(255,255,255,.86);
      backdrop-filter: blur(10px);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
    }
    .crumbs{
      display:flex;
      flex-direction:column;
      gap:2px;
      min-width:0;
    }
    .crumbs .path{
      font-size:12px;
      color:var(--muted);
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .crumbs .headline{
      font-size:14px;
      font-weight:780;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .main-actions{
      display:flex;
      gap:8px;
      align-items:center;
      flex:0 0 auto;
    }
    .editor-wrap{
      padding:14px 16px 18px;
      overflow:auto;
      height:100%;
    }
    .card{
      max-width: 980px;
      margin: 0 auto;
      background: rgba(255,255,255,.92);
      border:1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 14px;
    }
    .editor{
      width:100%;
      min-height: 60vh;
      border:1px solid rgba(17,24,39,.12);
      background: rgba(17,24,39,.03);
      color:var(--text);
      border-radius: 12px;
      padding: 12px;
      font-size: 13px;
      line-height: 1.35rem;
      outline:none;
      resize: vertical;
    }
    .editor:focus{border-color: rgba(255,255,255,.18)}
    .small{
      margin-top:10px;
      color:var(--muted);
      font-size:12px;
      display:flex;
      justify-content:space-between;
      gap:10px;
      flex-wrap:wrap;
    }
    .kbd{
      border:1px solid rgba(17,24,39,.16);
      padding:2px 6px;
      border-radius:8px;
      background: rgba(17,24,39,.03);
      font-size:11px;
      color:var(--muted);
    }

    /* Resize handle */
    .resizer{
      width:6px;
      cursor:col-resize;
      background: rgba(17,24,39,.03);
    }
    .resizer:hover{background: rgba(255,255,255,.06)}
  
    .sidebar.drag-text-over{
      outline:2px dashed rgba(37,99,235,.35);
      outline-offset:6px;
      border-radius:12px;
    }
    .text-drag-ghost{
      position: fixed;
      left: 0; top: 0;
      transform: translate(-9999px,-9999px);
      pointer-events: none;
      z-index: 10000;
      font-size: 12px;
      font-weight: 700;
      color: var(--text);
      background: rgba(255,255,255,.92);
      border: 1px solid rgba(17,24,39,.14);
      border-radius: 999px;
      padding: 8px 10px;
      box-shadow: 0 16px 40px rgba(17,24,39,.18);
      max-width: 420px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .btn.add{
      width:32px;
      padding:0;
      border-radius:999px;
      font-size:16px;
      line-height:32px;
      text-align:center;
    }
    .btn.icon{
      width:32px;
      padding:0;
      border-radius:12px;
      font-size:14px;
      line-height:32px;
      text-align:center;
    }
    .main-actions .btn{
      width:32px;
      padding:0;
      border-radius:12px;
      line-height:32px;
      text-align:center;
      font-size:14px;
    }

    .tree:focus{outline:none}
    .tree:focus-visible{
      outline:2px solid rgba(37,99,235,.25);
      outline-offset:6px;
      border-radius:12px;
    }
    .row.multi{
      border-color: rgba(37,99,235,.35);
      background: rgba(37,99,235,.06);
    }

    .sb-actions{justify-content:flex-start}
    .spacer{flex:1 1 auto}
    .btn.danger{border-color: rgba(220,38,38,.22)}

    .row{
      gap:6px;
      padding:0 8px;
    }
        .childplus{
      flex:0 0 auto;
      width:22px;
      height:27px;
      border-radius:8px;
      border:none;
      background: transparent;
      color: var(--text);
      font-weight: 800;
      font-size: 14px;
      line-height: 20px;
      cursor: pointer;
      padding:0;
    }
    .childplus:hover{background: transparent}

    .sb-title{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      margin-bottom:10px;
    }
    .top-search{
      flex:1 1 auto;
      display:flex;
      justify-content:flex-end;
    }
    .top-search input{
      width:min(240px, 100%);
      border:1px solid rgba(17,24,39,.14);
      background: rgba(17,24,39,.03);
      color:var(--text);
      padding:8px 10px;
      border-radius:12px;
      outline:none;
      font-size:12px;
    }
    .top-search input:focus{border-color: rgba(17,24,39,.22)}
    /* Tabs (Chrome-like, smooth outline) */
    .tabs{
      display:flex;
      align-items:flex-end;
      gap:0;
      padding:0 1px 0;
      background: transparent;
      overflow:auto;
      scrollbar-width: thin;
    }
    .tab{
      position:relative;
      height:26px;
      min-width:72px;
      max-width:180px;
      padding:0 12px;
      margin:0 0 0 -8px; /* overlap like Chrome */
      border:1px solid rgba(17,24,39,.16);
      border-bottom:none;
      background: var(--panel2);
      color: var(--text);
      font-size:13px;
      line-height:26px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      cursor:pointer;
      user-select:none;
      border-top-left-radius:12px;
      border-top-right-radius:12px;
      z-index:1;
      box-shadow: 0 -1px 0 rgba(255,255,255,.75) inset; /* crisp top highlight */
    }
    .tab:first-child{ margin-left:0; }

    /* Smooth "ears" using rounded pseudo-elements (no clip-path, no jagged top) */
    .tab::before,
    .tab::after{
      content:"";
      position:absolute;
      top:-1px;
      width:12px;
      height:27px;
      background: inherit;
      border:1px solid rgba(17,24,39,.16);
      border-bottom:none;
      z-index:-1;
    }
    .tab::before{
      left:-7px;
      border-top-left-radius:12px;
      border-right:none;
      transform: skewX(-18deg);
    }
    .tab::after{
      right:-7px;
      border-top-right-radius:12px;
      border-left:none;
      transform: skewX(18deg);
    }

    .tab.active{
      background: var(--panel);
      border-color: rgba(17,24,39,.18);
      z-index:3;
    }
    .tab.active::before,
    .tab.active::after{
      border-color: rgba(17,24,39,.18);
    }
    .tab:not(.active):hover{
      background: #e9eef8;
    }

    .tab.plus{
      min-width:26px;
      max-width:26px;
      width:26px;
      margin-left:-3px;
      border-radius:999px;
      background: transparent;
      line-height:24px;
      text-align:center;
      font-size:16px;
      border:none;
      box-shadow:none;
    
      text-overflow:clip;
      overflow:visible;
          z-index:6;
    }
    .tab.plus::before, .tab.plus::after{ display:none; }

    .tab .label{
      display:block;
      pointer-events:none;
    }
    .tab input.rename{
      width:100%;
      height:20px;
      margin-top:2px;
      border:1px solid rgba(17,24,39,.18);
      border-radius:8px;
      padding:0 8px;
      font-size:12px;
      font-weight:750;
      outline:none;
      background: var(--panel);
      color: var(--text);
    }
    .tab .close{
      pointer-events:auto;
      position:absolute;
      right:6px;
      top:4px;
      width:18px;
      height:20px;
      border-radius:999px;
      border:1px solid rgba(17,24,39,.16);
      background: var(--panel);
      color: var(--text);
      font-size:14px;
      line-height:16px;
      display:none;
      align-items:center;
      justify-content:center;
      cursor:pointer;
      z-index:4;
    }
    .tab.editing .close{ display:inline-flex; }
    .tab.editing{ padding-right:28px; }
    .tab.editing .label{ display:none; }

    .top-block{
      background: rgba(255,255,255,.98);
      border-radius:14px;
      padding:10px 10px 0;
      box-shadow:none;
      overflow:hidden;
      margin-bottom:10px;
    }
    .top-block .sb-title{ margin-bottom:8px; }
    .top-block .sb-actions{ padding:0; margin:0 0 8px; }
    .top-block .tabs{ padding:0 0 0; background: transparent; }

    .node{ width:100%; }
    .row{ width:100%; box-sizing:border-box; }

    .datehdr{
      margin:0;

      font-size:12px;
      font-weight:800;
      color: var(--text);
      opacity:.85;
      padding:10px 8px 6px;
      user-select:none;
    }

    button#btnAddRoot.btn.add{box-shadow: 0 4px 8px rgba(0,0,0,.18);} 

    #btnDelete{ border:none !important; }

    .chkAll{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      width:26px;
      height:26px;
      border-radius:10px;
      cursor:pointer;
      user-select:none;
    }
    .chkAll input{ position:absolute; opacity:0; pointer-events:none; }
    .chkAll span{
      width:16px;
      height:16px;
      border-radius:6px;
      border:1px solid rgba(17,24,39,.20);
      background: rgba(255,255,255,.9);
      box-shadow: 0 1px 2px rgba(17,24,39,.08);
      display:inline-block;
      position:relative;
    }
    .chkAll input:checked + span{
      background: #e9eef8;
      border-color: rgba(17,24,39,.28);
    }
    .chkAll input:checked + span::after{
      content:"";
      position:absolute;
      left:4px;
      top:1px;
      width:5px;
      height:9px;
      border:2px solid rgba(17,24,39,.85);
      border-top:none;
      border-left:none;
      transform: rotate(45deg);
    }
    .chkAll:hover span{ border-color: rgba(17,24,39,.30); }
    .row.selected{ outline:2px solid rgba(59,130,246,.35); background: rgba(59,130,246,.06); }


    /* Root notes: no vertical gap between root labels */
    .tree{
      display:flex;
      flex-direction:column;
      gap:0 !important;
    }
    .tree > .node{ margin:0 !important; }



    /* Collapse double borders between consecutive ROOT notes (no visual gap / 2px line) */
    .tree > .node > .node + .node > .row{
      border-top: 0 !important;
    }
    /* Keep top border for the first root after each date header */
    .tree > .node > .datehdr + .node > .row{
      border-top: 1px solid rgba(17,24,39,.10) !important;
    }



    /* Collapse double borders between consecutive CHILD notes as well */
    .node > .node + .node > .row{
      border-top: 0 !important;
    }



    /* Collapse double borders between consecutive nodes (roots and children) */
    .tree > .node + .node > .row{ border-top:0 !important; }
    .children > .node + .node > .row{ border-top:0 !important; }



    /* Export HTML button */
    #btnExportHtml{
      border: 0;
      background: transparent;
      padding: 4px 6px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 12px;
      line-height: 1;
      color: rgba(17,24,39,.85);
    }
    #btnExportHtml:hover{ background: rgba(0,0,0,.05); }
    #btnExportHtml:active{ transform: translateY(0.5px); }
</style>
</head>
<body>
<div class="app">
  <aside class="sidebar" id="sidebar">
    <div class="sb-top">
      <div class="top-block">
      <div class="sb-title">
        <h1>–ó–∞–º–µ—Ç–∫–∏</h1>
        <div class="top-search">
          <input id="search" placeholder="–ü–æ–∏—Å–∫‚Ä¶" autocomplete="off" />
        </div>
      </div>

      <div class="sb-actions">
        <button class="btn add" id="btnAddRoot" title="–î–æ–±–∞–≤–∏—Ç—å –∑–∞–º–µ—Ç–∫—É" aria-label="–î–æ–±–∞–≤–∏—Ç—å –∑–∞–º–µ—Ç–∫—É">+</button>
        <button class="btn ghost icon" id="btnSort" title="–°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞" aria-label="–°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞">‚áÖ</button>
        <div class="spacer"></div><label class="chkAll" title="Select all"><input id="chkSelectAll" type="checkbox"/><span></span></label>
        
        
          <button id="btnExportHtml" class="iconbtn export" title="Export selected to HTML">&lt;/&gt;</button>
          <button class="btn ghost icon danger" id="btnDelete" title="–£–¥–∞–ª–∏—Ç—å" aria-label="–£–¥–∞–ª–∏—Ç—å">üóëÔ∏è</button>
</div>
    </div>
      <div class="tabs" id="tabs"></div>
      </div>

      



    <div class="tree" id="tree" tabindex="0"></div>
  </aside>

  <div class="resizer" id="resizer" title="Resize"></div>

  <main class="main">
    <div class="main-top">
      <div class="crumbs">
        <div class="path" id="path">‚Äî</div>
        <div class="headline" id="headline">–í—ã–±–µ—Ä–∏—Ç–µ –∑–∞–º–µ—Ç–∫—É</div>
      </div>
      <div class="main-actions">      </div>
    </div>

    <div class="editor-wrap">
      <div class="card">
        <textarea class="editor" id="editor" placeholder="–¢–µ–∫—Å—Ç –∑–∞–º–µ—Ç–∫–∏‚Ä¶" disabled></textarea>
        <div class="small">
          <div>Click: –æ—Ç–∫—Ä—ã—Ç—å –≤ –æ—Å–Ω–æ–≤–Ω–æ–º –æ–∫–Ω–µ ‚Ä¢ Double click: —Å–≤–µ—Ä–Ω—É—Ç—å/—Ä–∞–∑–≤–µ—Ä–Ω—É—Ç—å</div>
          <div>Drag: <span class="kbd">‚ãÆ‚ãÆ</span> ‚Ä¢ Drop –Ω–∞ –∑–∞–º–µ—Ç–∫—É = —Å–¥–µ–ª–∞—Ç—å –¥–æ—á–µ—Ä–Ω–µ–π ‚Ä¢ Drop –≤ –ø—É—Å—Ç–æ—Ç—É = –ø–µ—Ä–µ–º–µ—Å—Ç–∏—Ç—å –∫–∞–∫ sibling</div>
        </div>
      </div>
    </div>
  </main>
</div>

<script>
(() => {
  const STORAGE_KEY = "notes-split-proto:v1";

  // notes[id] = {id, text, createdAt}
  // parents[id] = parentId | null
  // children[id] = [childIds]
  // roots = [rootIds]
  // expanded[id] = true/false
  // selectedId = id | null
  let state = load() ?? emptyState();
  if (!state.sortMode) state.sortMode = "manual";
  if (!state.tabs || !Array.isArray(state.tabs) || state.tabs.length===0) state.tabs = [{id:"t_home", name:"Home"}];
  if (!state.activeTab) state.activeTab = state.tabs[0].id;
  if (!state.tabSeq) state.tabSeq = 1;
  if (!state.noteSeq) state.noteSeq = 1;
  // activeTab must exist
  if (!state.tabs.some(t => t.id === state.activeTab)) state.activeTab = state.tabs[0].id;


  const treeEl = document.getElementById("tree");
  const tabsEl = document.getElementById("tabs");

  // Tabs UI state (not persisted)
  let editingTabId = null;

const searchEl = document.getElementById("search");

  // Multi-select (not persisted): long-press or Ctrl/‚åò+Click to toggle.
  const multiSelected = new Set(); // ids
  let selectionAnchorId = null; // for shift-range selection (not persisted)

  function getVisibleNoteIds(){
    return Array.from(document.querySelectorAll('.row[data-note-id]'))
      .map(r => r.getAttribute('data-note-id'))
      .filter(Boolean);
  }

  function setRangeSelection(anchorId, targetId, additive=false){
    const ids = getVisibleNoteIds();
    const a = ids.indexOf(anchorId);
    const b = ids.indexOf(targetId);
    if (a === -1 || b === -1) return;
    const s = Math.min(a,b), e = Math.max(a,b);
    if (!additive) multiSelected.clear();
    for (const id of ids.slice(s, e+1)) multiSelected.add(id);
  }

  function focusRow(id){
    if (!id) return;
    const esc = (window.CSS && CSS.escape) ? CSS.escape(id) : id.replace(/"/g, '\"');
    const row = document.querySelector(`.row[data-note-id="${esc}"]`);
    if (row) row.scrollIntoView({ block: "nearest" });
  }

  function afterRenderFocus(id){
    requestAnimationFrame(() => focusRow(id));
  }
  function clearMulti(){ multiSelected.clear(); }
  function toggleMulti(id){
    if (!id || !state.notes[id]) return;
    if (multiSelected.has(id)) multiSelected.delete(id);
    else multiSelected.add(id);
    selectionAnchorId = id;
    render();
  }
  function isMulti(id){ return multiSelected.has(id); }

  // Custom double-click tracker (stable even with re-render)
  const __dblTap = { id: null, t: 0 };



  const pathEl = document.getElementById("path");
  const headlineEl = document.getElementById("headline");
  const editorEl = document.getElementById("editor");

  const btnAddRoot = document.getElementById("btnAddRoot");
  const btnSort = document.getElementById("btnSort");
const btnDelete = document.getElementById("btnDelete");
  const btnExportHtml = document.getElementById("btnExportHtml");

  function __syncRowSelection(selSet){
    document.querySelectorAll('.row[data-note-id]').forEach(r=>{
      const id = r.getAttribute('data-note-id');
      // multi-select highlight (active note uses .selected separately)
      r.classList.toggle('multi', selSet.has(id));
    });
  }

  
  const chkSelectAll = document.getElementById("chkSelectAll");
  if (chkSelectAll) {
    chkSelectAll.addEventListener("change", () => {
      const all = collectAllInActiveTab();
      multiSelected.clear();
      if (chkSelectAll.checked) {
        all.forEach(id => multiSelected.add(id));
      }
      __syncRowSelection(multiSelected);
    });
  }
function emptyState(){
    return { notes:{}, parents:{}, children:{}, roots:[], expanded:{}, selectedId:null, sortMode:"manual", tabs:[{id:"t_home", name:"Home"}], activeTab:"t_home", tabSeq:1, noteSeq:1 };
  }
  function uid(){
    return "n_" + Math.random().toString(16).slice(2) + "_" + Date.now().toString(16);
  }
  function ensureChildren(id){
    if (!state.children[id]) state.children[id] = [];
    return state.children[id];
  }
  
  function escapeHtml(s){
    return String(s ?? "")
      .replaceAll("&","&amp;")
      .replaceAll("<","&lt;")
      .replaceAll(">","&gt;")
      .replaceAll('"',"&quot;")
      .replaceAll("'","&#39;");
  }

  function buildSubtreeHtml(id){
    const note = state.notes[id];
    const title = escapeHtml(titleOf(id));
    const body = escapeHtml(note?.text || "");
    const kids = getSortedIds(state.children[id] || []);
    const kidsHtml = kids.length ? `<ul>` + kids.map(k => buildSubtreeHtml(k)).join("") + `</ul>` : "";
    return `<li><div class="n"><div class="t">${title}</div><div class="b">${body}</div></div>${kidsHtml}</li>`;
  }

  function exportSelectedToHtml(){
    // Determine selection (top-most)
    let ids = Array.from(multiSelected || []);
    if (!ids.length && state.selectedId) ids = [state.selectedId];
    if (!ids.length) return;

    // top-most only (avoid duplicates when parent+child selected)
    const sel = new Set(ids);
    const top = [];
    for (const id of ids){
      let p = state.parents?.[id];
      let blocked = false;
      while (p){
        if (sel.has(p)) { blocked = true; break; }
        p = state.parents?.[p];
      }
      if (!blocked) top.push(id);
    }

    const tabName = (state.tabs || []).find(t => t.id === state.activeTab)?.name || "Tab";
    const dateStr = new Date().toLocaleString();

    const htmlOut = `<!doctype html>
<html>
<head>
<meta charset="utf-8"/>
<title>Notes export - ${escapeHtml(tabName)}</title>
<style>
  body{ font-family: -apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Arial,sans-serif; padding:18px; }
  h1{ font-size:16px; margin:0 0 6px; }
  .meta{ color:#6b7280; font-size:12px; margin-bottom:12px; }
  ul{ list-style: none; padding-left: 18px; margin: 8px 0; }
  li{ margin: 10px 0; }
  .n{ border:1px solid rgba(17,24,39,.12); border-radius:10px; padding:10px 12px; }
  .t{ font-size:13px; margin:0 0 6px; color:#111827; }
  .b{ font-size:12px; color:#374151; white-space:pre-wrap; }
</style>
</head>
<body>
  <h1>Export: ${escapeHtml(tabName)}</h1>
  <div class="meta">${escapeHtml(dateStr)} ‚Ä¢ ${top.length} root selection(s)</div>
  <ul>
    ${top.map(id => buildSubtreeHtml(id)).join("")}
  </ul>
</body>
</html>`;

    // Download
    const blob = new Blob([htmlOut], { type: "text/html;charset=utf-8" });
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = `notes_export_${tabName.replace(/\W+/g,"_")}_${Date.now()}.html`;
    document.body.appendChild(a);
    a.click();
    setTimeout(() => { URL.revokeObjectURL(a.href); a.remove(); }, 0);

    // Best-effort copy to clipboard
    if (navigator.clipboard?.writeText) {
      navigator.clipboard.writeText(htmlOut).catch(()=>{});
    }
  }


  function titleOf(id){
    const t = (state.notes[id]?.text ?? "").split("\\n")[0].trim();
    return t.length ? t : "‚Ä¶";
  }

  function truncateTitle(s, maxLen=50){
    const str = (s ?? "").toString();
    return str.length > maxLen ? (str.slice(0, maxLen) + "‚Ä¶") : str;
  }

  function formatDateShort(ts){
    const d = new Date(ts);
    const now = new Date();
    const startToday = new Date(now.getFullYear(), now.getMonth(), now.getDate());
    const startThat = new Date(d.getFullYear(), d.getMonth(), d.getDate());
    const diffDays = Math.round((startToday - startThat) / 86400000);

    if (diffDays === 0) return "Today";
    if (diffDays === 1) return "Yesterday";

    const m = d.toLocaleString("en-US", { month: "short" }).toLowerCase();
    const day = String(d.getDate()).padStart(2, "0");
    return m + day;
  }

  
  function dateKeyOf(ts){
    const d = new Date(ts);
    return d.getFullYear()+"-"+(d.getMonth()+1)+"-"+d.getDate();
  }

  function selectAllForDateKey(key){
    multiSelected.clear();
    const rows = document.querySelectorAll('.row[data-note-id]');
    for (const r of rows){
      const id = r.getAttribute('data-note-id');
      const n = state.notes[id];
      if (!n) continue;
      if (dateKeyOf(n.createdAt) === key) multiSelected.add(id);
    }
    // keep checkbox off (date selection is scoped)
    const chk = document.getElementById("chkSelectAll");
    if (chk) chk.checked = false;

    // set active to first selected (top visible)
    const first = Array.from(multiSelected)[0] || null;
    if (first) state.selectedId = first;

    persist();
    render();
  }


  function formatDateHeader(ts){
    const d = new Date(ts);
    const m = d.toLocaleString("en-US", { month: "short" });
    const day = String(d.getDate()).padStart(2, "0");
    return m + "." + day;
  }
  
  function migrateTabsForNotes(){
    const fallback = state.activeTab || (state.tabs?.[0]?.id) || "t_home";
    for (const id of Object.keys(state.notes || {})){
      if (!state.notes[id].tabId) state.notes[id].tabId = fallback;
    }
  }
  migrateTabsForNotes();

function totalCount(){
    return Object.keys(state.notes).length;
  }
  function persist(){
    localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
  }
  function load(){
    try{
      const raw = localStorage.getItem(STORAGE_KEY);
      if (!raw) return null;
      const s = JSON.parse(raw);
      if (!s || !s.notes || !s.parents || !s.children || !s.roots || !s.expanded) return null;
      return s;
    }catch{ return null; }
  }

  function addNote(text="New", tabId=null){
    const id = uid();
    const tId = tabId || state.activeTab;

    let finalText = (text ?? "").toString();
    if (!finalText || finalText.trim().toLowerCase() === "new") {
      const n = state.noteSeq || 1;
      finalText = "New " + n;
      state.noteSeq = n + 1;
    }

    state.notes[id] = { id, text: finalText, createdAt: Date.now(), tabId: tId };
    state.parents[id] = null;
    ensureChildren(id);
    state.expanded[id] = true;
    return id;
  }

  function addRoot(text="New"){
    const id = addNote(text);
    state.roots.unshift(id);
    select(id);
    return id;
  }

  function addChild(parentId, text="New"){
    const id = addNote(text);
    attachAsChild(parentId, id, ensureChildren(parentId).length);
    state.expanded[parentId] = true;
    select(id);
    return id;
  }

  function select(id){
    state.selectedId = id;
    persist();
    render();
  }

  function ancestors(id){
    const arr = [];
    let cur = id;
    while(cur){
      arr.push(cur);
      cur = state.parents[cur] ?? null;
    }
    return arr.reverse();
  }

  function deleteSubtree(id){
    const kids = (state.children[id] || []).slice();
    for (const k of kids) deleteSubtree(k);
    detach(id);
    delete state.notes[id];
    delete state.parents[id];
    delete state.children[id];
    delete state.expanded[id];
    if (state.selectedId === id) state.selectedId = null;
  }

  function detach(id){
    const p = state.parents[id];
    if (p){
      const arr = ensureChildren(p);
      const i = arr.indexOf(id);
      if (i !== -1) arr.splice(i,1);
    } else {
      const i = state.roots.indexOf(id);
      if (i !== -1) state.roots.splice(i,1);
    }
    state.parents[id] = null;
  }

  function isDescendant(maybeDescId, rootId){
    const stack = (state.children[rootId] || []).slice();
    while(stack.length){
      const cur = stack.pop();
      if (cur === maybeDescId) return true;
      for (const k of (state.children[cur] || [])) stack.push(k);
    }
    return false;
  }

  function attachAsChild(parentId, id, index=0){
    if (parentId === id) return false;
    if (isDescendant(parentId, id)) return false;
    detach(id);
    state.parents[id] = parentId;
    // Keep subtree within the same tab
    if (state.notes[id] && state.notes[parentId]) state.notes[id].tabId = state.notes[parentId].tabId;
    const arr = ensureChildren(parentId);
    const idx = Math.min(Math.max(0, index), arr.length);
    arr.splice(idx, 0, id);
    return true;
  }

  function attachAsRoot(id, index=0){
    detach(id);
    state.parents[id] = null;
    const idx = Math.min(Math.max(0, index), state.roots.length);
    state.roots.splice(idx, 0, id);
  }

  function attachAsSibling(targetId, draggedId, before=true){
    if (targetId === draggedId) return false;
    if (isDescendant(targetId, draggedId)) return false;

    const p = state.parents[targetId];
    detach(draggedId);

    if (p){
      state.parents[draggedId] = p;
      const arr = ensureChildren(p);
      const t = arr.indexOf(targetId);
      const at = before ? t : t+1;
      arr.splice(at < 0 ? arr.length : at, 0, draggedId);
    } else {
      state.parents[draggedId] = null;
      const t = state.roots.indexOf(targetId);
      const at = before ? t : t+1;
      state.roots.splice(at < 0 ? state.roots.length : at, 0, draggedId);
    }
    return true;
  }

  // ===== Render =====
  let filter = "";

  function matchesFilter(id){
    if (!filter) return true;
    const text = (state.notes[id]?.text ?? "").toLowerCase();
    return text.includes(filter);
  }

  function anyMatchInSubtree(id){
    if (matchesFilter(id)) return true;
    for (const k of (state.children[id] || [])){
      if (anyMatchInSubtree(k)) return true;
    }
    return false;
  }

  
  function getSortedIds(ids){
    const arr = (ids || []).slice();
    if (state.sortMode === "manual") return arr;

    if (state.sortMode === "created_desc") {
      arr.sort((a,b) => (state.notes[b]?.createdAt || 0) - (state.notes[a]?.createdAt || 0));
      return arr;
    }
    if (state.sortMode === "title_asc") {
      arr.sort((a,b) => titleOf(a).localeCompare(titleOf(b), "ru", { sensitivity: "base" }));
      return arr;
    }
    return arr;
  }


  
  function isInActiveTab(id){
    const n = state.notes?.[id];
    if (!n) return false;
    if ((n.tabId || state.activeTab) === state.activeTab) return true;
    // Fallback: walk up to find an ancestor in this tab
    let p = state.parents?.[id];
    while (p){
      const pn = state.notes?.[p];
      if (pn && (pn.tabId || state.activeTab) === state.activeTab) return true;
      p = state.parents?.[p];
    }
    return false;
  }


  function collectSubtreeIds(rootId, outSet){
    outSet.add(rootId);
    const kids = (state.children && state.children[rootId]) ? state.children[rootId] : [];
    for (const k of kids) collectSubtreeIds(k, outSet);
  }

  function collectAllInActiveTab(){
    const out = new Set();
    const roots = (state.roots || []).filter(id => (state.notes[id]?.tabId || state.activeTab) === state.activeTab);
    for (const r of roots) collectSubtreeIds(r, out);
    return out;
  }

function renderTabs(){
    if (!tabsEl) return;
    tabsEl.innerHTML = "";

    const tabs = state.tabs || [];
    for (const t of tabs){
      const b = document.createElement("button");
      b.className = "tab" + (t.id === state.activeTab ? " active" : "") + (t.id === editingTabId ? " editing" : "");
      b.type = "button";

      const label = document.createElement("span");
      label.className = "label";
      label.textContent = t.name;
      b.appendChild(label);

      // Close button appears on dblclick/edit mode (and is disabled for Home)
      const close = document.createElement("span");
      close.className = "close";
      close.textContent = "√ó";
      if (t.id !== "t_home") {
        close.addEventListener("pointerdown", (e) => {
          e.preventDefault();
          e.stopPropagation();

          // Move notes of this tab to Home (safe default)
          for (const nid of Object.keys(state.notes || {})){
            if (state.notes[nid]?.tabId === t.id) state.notes[nid].tabId = "t_home";
          }

          // Remove tab
          state.tabs = (state.tabs || []).filter(x => x.id !== t.id);
          if (state.activeTab === t.id) state.activeTab = "t_home";
          if (editingTabId === t.id) editingTabId = null;

          persist();
          render();
          treeEl.focus();
        });
      } else {
        close.style.display = "none";
      }
      b.appendChild(close);

      // Normal click: switch tab (unless editing)
      b.addEventListener("click", () => {
        if (editingTabId) return;
        state.activeTab = t.id;
        const chk = document.getElementById("chkSelectAll");
        if (chk) chk.checked = false;
        if (typeof selected !== 'undefined' && selected?.clear) selected.clear();
        if (typeof multiSelected !== 'undefined' && multiSelected?.clear) multiSelected.clear();
        if (typeof __syncRowSelection === "function") __syncRowSelection(multiSelected);

        if (typeof clearMulti === "function") clearMulti();
        persist();
        render();
        treeEl.focus();
      });

      // Double click: rename mode (editable input) + show close
      b.addEventListener("dblclick", (e) => {
        e.preventDefault();
        e.stopPropagation();
        if (t.id === "t_home") return; // keep Home fixed
        editingTabId = t.id;
        renderTabs();

        // Focus input
        const input = tabsEl.querySelector(".tab.editing input.rename");
        if (input) {
          input.focus();
          input.select();
        }
      });

      if (t.id === editingTabId) {
        const input = document.createElement("input");
        input.className = "rename";
        input.value = t.name;
        input.addEventListener("click", (e) => { e.stopPropagation(); });
        input.addEventListener("keydown", (e) => {
          if (e.key === "Enter") {
            const v = input.value.trim() || "New";
            t.name = v;
            editingTabId = null;
            persist();
            render();
            treeEl.focus();
          } else if (e.key === "Escape") {
            editingTabId = null;
            renderTabs();
            treeEl.focus();
          }
        });
        input.addEventListener("blur", () => {
          const v = input.value.trim() || "New";
          t.name = v;
          editingTabId = null;
          persist();
          render();
        });
        b.appendChild(input);
      }

      tabsEl.appendChild(b);
    }

    const plus = document.createElement("button");
    plus.className = "tab plus";
    plus.type = "button";
    plus.textContent = "+";
    plus.title = "–ù–æ–≤—ã–π —Ç–∞–±";
    plus.addEventListener("click", () => {
      const n = state.tabSeq || 1;
      const id = "t_" + Date.now().toString(16) + "_" + n;
      const name = "Tab " + n;
      state.tabSeq = n + 1;
      state.tabs.push({id, name});
      state.activeTab = id;
      const chk = document.getElementById("chkSelectAll");
      if (chk) chk.checked = false;

      editingTabId = null;
      persist();
      render();
      treeEl.focus();
    });
    tabsEl.appendChild(plus);
  }
function render(){
    renderTabs();

    // Update search filter
    filter = (searchEl?.value || "").trim().toLowerCase();

    // Main pane
    const sel = state.selectedId;
    if (!sel || !state.notes[sel]){
      pathEl.textContent = "‚Äî";
      headlineEl.textContent = "–í—ã–±–µ—Ä–∏—Ç–µ –∑–∞–º–µ—Ç–∫—É";
      editorEl.value = "";
      editorEl.disabled = true;
btnDelete.disabled = true;
    } else {
      const chain = ancestors(sel).map(titleOf).join(" / ");
      pathEl.textContent = chain || "‚Äî";
      headlineEl.textContent = truncateTitle(titleOf(sel), 50);
editorEl.disabled = false;
      editorEl.value = state.notes[sel].text;
btnDelete.disabled = false;
    }

    // Sidebar tree
    treeEl.innerHTML = "";
    if (state.roots.length === 0){
      const h = document.createElement("div");
      h.className = "hint";
      h.textContent = "–ü–æ–∫–∞ –Ω–µ—Ç –∑–∞–º–µ—Ç–æ–∫. –ù–∞–∂–º–∏—Ç–µ ‚Äú+‚Äù.";
      treeEl.appendChild(h);
      wireDnD();
      return;
    }

    const rootZone = document.createElement("div");
    rootZone.className = "node";
    rootZone.style.gap = "0px";

    // Visible roots for current tab (and search filter)
    const sortedRoots = getSortedIds(state.roots).filter(id => (state.notes[id]?.tabId || state.activeTab) === state.activeTab);
    const visibleRoots = filter ? sortedRoots.filter(id => anyMatchInSubtree(id)) : sortedRoots;

    if (visibleRoots.length === 0){
      const h = document.createElement("div");
      h.className = "hint";
      h.textContent = filter ? "–ù–∏—á–µ–≥–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ." : "–í —ç—Ç–æ–º —Ç–∞–±–µ –ø–æ–∫–∞ –Ω–µ—Ç –∑–∞–º–µ—Ç–æ–∫. –ù–∞–∂–º–∏—Ç–µ ‚Äú+‚Äù.";
      treeEl.appendChild(h);
      wireDnD();
      return;
    }

    let __lastDateKey = null;

    for (const id of visibleRoots) {
      const ts = state.notes[id]?.createdAt || 0;
      const d = new Date(ts);
      const key = d.getFullYear()+"-"+(d.getMonth()+1)+"-"+d.getDate();
      if (key !== __lastDateKey){
        __lastDateKey = key;
        const hdr = document.createElement("div");
        hdr.className = "datehdr";
        const __dk = dateKeyOf(ts);
        hdr.dataset.dateKey = __dk;
        hdr.textContent = formatDateHeader(ts);
        hdr.addEventListener("dblclick", (e) => {
          e.preventDefault();
          e.stopPropagation();
          selectAllForDateKey(__dk);
        });
        rootZone.appendChild(hdr);
      }
      rootZone.appendChild(renderNode(id));
    }

    treeEl.appendChild(rootZone);

    wireDnD();
  }

  function renderNode(id){
    const node = document.createElement("div");
    node.className = "node";
    node.dataset.nodeId = id;

    const row = document.createElement("div");
    row.className = "row";
    row.dataset.noteId = id;

    if (state.selectedId === id) row.classList.add("selected");
    if (isMulti(id)) row.classList.add("multi");

    const kids = state.children[id] || [];
    const hasKids = kids.length > 0;
    const isOpen = !!state.expanded[id];

    const title = document.createElement("div");
    title.className = "title";
    title.textContent = titleOf(id);
    row.appendChild(title);


    const addChildBtn = document.createElement("button");
    addChildBtn.className = "childplus";
    addChildBtn.type = "button";
    addChildBtn.textContent = "+";
    addChildBtn.title = "–î–æ–±–∞–≤–∏—Ç—å –¥–æ—á–µ—Ä–Ω—é—é";
    addChildBtn.setAttribute("aria-label", "–î–æ–±–∞–≤–∏—Ç—å –¥–æ—á–µ—Ä–Ω—é—é");
    row.appendChild(addChildBtn);

    addChildBtn.addEventListener("click", (e) => {
      e.preventDefault();
      e.stopPropagation();
      addChild(id, "New");
      persist();
      render();
      treeEl.focus();
    });
    // Long press = toggle multi-select
    let __lpTimer = null;
    let __lpFired = false;
    let __singleTimer = null;

    // Threshold-based drag from the whole row
    const __DRAG_THRESHOLD = 7;
    let __dragCandidate = null;

    function __clearSingle(){
      if (__singleTimer) { clearTimeout(__singleTimer); __singleTimer = null; }
    }

    function __lpClear(){
      clearTimeout(__lpTimer);
      __lpTimer = null;
    }

    row.addEventListener("pointerdown", (e) => {
      if (drag) return;
      if (e.button !== 0) return;

      // If user pressed on the child "+" button, do not treat as row gesture
      if (e.target?.closest?.(".childplus")) return;

      __lpFired = false;
      __lpClear();

      __lpTimer = setTimeout(() => {
        __lpFired = true;
        toggleMulti(id);
        treeEl.focus();
      }, 450);

      __dragCandidate = { pointerId: e.pointerId, x: e.clientX, y: e.clientY };
    });

    row.addEventListener("pointermove", (e) => {
      if (drag) return;
      if (!__dragCandidate || e.pointerId !== __dragCandidate.pointerId) return;

      // If user drags on child plus, ignore
      if (e.target?.closest?.(".childplus")) return;

      const dx = e.clientX - __dragCandidate.x;
      const dy = e.clientY - __dragCandidate.y;
      const dist = Math.hypot(dx, dy);

      if (!__lpFired && dist > __DRAG_THRESHOLD) {
        // Start note drag; cancel long-press + single click timers
        __lpClear();
        __clearSingle();

        // Start the existing DnD pipeline
        startDrag(e, row);
        __dragCandidate = null;
      }
    });

    row.addEventListener("pointerleave", () => {
      __lpClear();
      __dragCandidate = null;
    });
    row.addEventListener("pointercancel", () => {
      __lpClear();
      __dragCandidate = null;
    });

    // Use pointerup to implement stable single vs double click (native dblclick breaks on re-render)
    row.addEventListener("pointerup", (e) => {
      if (drag) return;
      if (e.button !== 0) return;

      // childplus handled separately
      if (e.target?.closest?.(".childplus")) return;

      __lpClear();
      __dragCandidate = null;

      if (__lpFired) {
        e.preventDefault();
        e.stopPropagation();
        return;
      }

      // Shift = range select (like file tree)
      if (e.shiftKey) {
        __clearSingle();
        const base = selectionAnchorId || state.selectedId || id;
        const additive = e.ctrlKey || e.metaKey;
        setRangeSelection(base, id, additive);
        state.selectedId = id;
        selectionAnchorId = base; // keep anchor stable for repeated shift actions
        persist();
        render();
        afterRenderFocus(id);
        treeEl.focus();
        __dblTap.id = null;
        __dblTap.t = 0;
        return;
      }

      // Ctrl/‚åò toggles multi-select immediately
      if (e.ctrlKey || e.metaKey) {
        __clearSingle();
        toggleMulti(id);
        treeEl.focus();
        __dblTap.id = null;
        __dblTap.t = 0;
        return;
      }

      const now = performance.now();
      const isDouble = (__dblTap.id === id) && (now - __dblTap.t < 320);

      __dblTap.id = id;
      __dblTap.t = now;

      if (isDouble) {
        __clearSingle();

        if (multiSelected.size) clearMulti();
        state.selectedId = id;

        if ((state.children[id] || []).length) {
          state.expanded[id] = !state.expanded[id];
        }

        persist();
        render();
        treeEl.focus();
        return;
      }

      // Single-click (delayed) = select note in main
      __clearSingle();
      __singleTimer = setTimeout(() => {
        __singleTimer = null;
        if (multiSelected.size) clearMulti();
        selectionAnchorId = id;
        select(id);
        afterRenderFocus(id);
        treeEl.focus();
      }, 220);
    });
row.addEventListener("dblclick", () => {
      if (drag) return;
      if (!(state.children[id] || []).length) return;
      state.expanded[id] = !state.expanded[id];
      persist();
      render();
    });

    node.appendChild(row);

    const childrenWrap = document.createElement("div");
    childrenWrap.className = "children" + (hasKids ? "" : " empty");
    childrenWrap.dataset.dropZone = "children";
    childrenWrap.dataset.parentId = id;

    if (hasKids && isOpen){
      for (const k of getSortedIds(kids)) {
        if (filter && !anyMatchInSubtree(k)) continue;
        childrenWrap.appendChild(renderNode(k));
      }
      childrenWrap.style.display = "flex";
    } else {
      childrenWrap.style.display = hasKids && !isOpen ? "none" : "flex";
    }

    node.appendChild(childrenWrap);
    return node;
  }

  // ===== Main editor =====
  let saveTimer = null;
  editorEl.addEventListener("input", () => {
    if (!state.selectedId || !state.notes[state.selectedId]) return;
    const id = state.selectedId;
    state.notes[id].text = editorEl.value;

    clearTimeout(saveTimer);
    saveTimer = setTimeout(() => {
      persist();
      const t = document.querySelector(`.row[data-note-id="${id}"] .title`);
      if (t) t.textContent = titleOf(id);
      headlineEl.textContent = truncateTitle(titleOf(id), 50);
pathEl.textContent = ancestors(id).map(titleOf).join(" / ");
    }, 200);
  });

  
  // ===== Drag selected text from main editor to sidebar (creates a new note) =====
// NOTE: Native HTML5 drag events for textarea selection are unreliable across browsers,
// so we implement a small pointer-based drag gesture for the current selection.
function createNoteFromDraggedText(text, dropTargetEl){
  const t = (text || "").trim();
  if (!t) return;

  // Create note (from copied text)
  const newId = addNote(t);

  // Priority:
  // 1) Drop ON a note row => that note becomes parent (create child)
  // 2) Drop inside a children zone => that parentId becomes parent
  // 3) Else => root note
  const row = dropTargetEl?.closest?.(".row");
  const hoverId = row?.dataset?.noteId || null;
  const childrenZone = dropTargetEl?.closest?.("[data-drop-zone='children']");
  const zoneParentId = childrenZone?.dataset?.parentId || null;

  const parentId = (hoverId && state.notes[hoverId]) ? hoverId
                : (zoneParentId && state.notes[zoneParentId]) ? zoneParentId
                : null;

  if (parentId) {
    const ok = attachAsChild(parentId, newId, ensureChildren(parentId).length);
    if (ok) state.expanded[parentId] = true;
  } else {
    state.roots.unshift(newId);
  }
  // Keep current active note in main editor (do not switch selection)
}

let __textDrag = null;
let __textGhost = null;
const __TEXT_DRAG_THRESHOLD = 6;

function __textDragCleanup(){
  sidebar.classList.remove("drag-text-over");
  clearDropHighlights();
  if (__textGhost) { __textGhost.remove(); __textGhost = null; }
  __textDrag = null;
}

function __textGhostEnsure(){
  if (__textGhost) return;
  __textGhost = document.createElement("div");
  __textGhost.className = "text-drag-ghost";
  document.body.appendChild(__textGhost);
}

function __textGhostMove(x, y, text){
  __textGhostEnsure();
  const preview = (text || "").trim().replace(/\s+/g, " ");
  __textGhost.textContent = "‚ûï " + (preview.length > 46 ? preview.slice(0,46) + "‚Ä¶" : preview || "Selection");
  __textGhost.style.transform = `translate(${x + 10}px, ${y + 10}px)`;
}

// Disable native HTML5 drag/drop on textarea selection (prevents "move" behavior)
editorEl.addEventListener("dragstart", (e) => { e.preventDefault(); });
editorEl.addEventListener("drop", (e) => { e.preventDefault(); });
editorEl.addEventListener("dragover", (e) => { e.preventDefault(); });

// Start drag when selection already exists and user drags (LMB) from editor
editorEl.addEventListener("pointerdown", (e) => {
  if (e.button !== 0) return;

  const s = editorEl.selectionStart ?? 0;
  const en = editorEl.selectionEnd ?? 0;
  if (s === en) return;

  
  // Prevent browser's native "drag selection to move" behavior
  e.preventDefault();
  e.stopPropagation();
  editorEl.focus();

__textDrag = {
    pointerId: e.pointerId,
    startX: e.clientX,
    startY: e.clientY,
    active: false,
    text: editorEl.value.substring(s, en),
  };
  editorEl.setPointerCapture(e.pointerId);
});

editorEl.addEventListener("pointermove", (e) => {
  if (!__textDrag || e.pointerId !== __textDrag.pointerId) return;

  const dx = e.clientX - __textDrag.startX;
  const dy = e.clientY - __textDrag.startY;
  const dist = Math.hypot(dx, dy);

  if (!__textDrag.active && dist > __TEXT_DRAG_THRESHOLD) {
    __textDrag.active = true;
  }
  if (!__textDrag.active) return;

  __textGhostMove(e.clientX, e.clientY, __textDrag.text);

  const under = document.elementFromPoint(e.clientX, e.clientY);
  const insideSidebar = !!under?.closest?.("#sidebar");
  if (insideSidebar) sidebar.classList.add("drag-text-over");
  else sidebar.classList.remove("drag-text-over");

  clearDropHighlights();
  const hoverRow = under?.closest?.(".row");
  if (hoverRow) hoverRow.classList.add("drop-child");
});

editorEl.addEventListener("pointerup", (e) => {
  if (!__textDrag || e.pointerId !== __textDrag.pointerId) return;

  try { editorEl.releasePointerCapture(e.pointerId); } catch {}

  if (__textDrag.active) {
    const under = document.elementFromPoint(e.clientX, e.clientY);
    if (under?.closest?.("#sidebar")) {
      createNoteFromDraggedText(__textDrag.text, under);
      persist();
      render();
    }
  }
  __textDragCleanup();
});

editorEl.addEventListener("pointercancel", (e) => {
  if (!__textDrag || e.pointerId !== __textDrag.pointerId) return;
  try { editorEl.releasePointerCapture(e.pointerId); } catch {}
  __textDragCleanup();
});
// ===== Buttons =====
  btnAddRoot.addEventListener("click", () => {
    addRoot("New");
    persist();
    render();
  });

  if (btnExportHtml) {
    btnExportHtml.addEventListener("click", () => {
      exportSelectedToHtml();
    });
  }

  btnDelete.addEventListener("click", () => {
    // Populate selection from UI if needed
    if (multiSelected.size === 0) {
      document.querySelectorAll('.row.multi[data-note-id]').forEach(r => {
        const id = r.getAttribute('data-note-id');
        if (id) multiSelected.add(id);
      });
    }

    // Multi-delete
    if (multiSelected.size > 0) {
      // delete only top-most selected nodes (avoid double-delete of children)
      const toDelete = [];
      for (const id of multiSelected) {
        let p = state.parents?.[id];
        let blocked = false;
        while (p) {
          if (multiSelected.has(p)) { blocked = true; break; }
          p = state.parents?.[p];
        }
        if (!blocked) toDelete.push(id);
      }
      toDelete.forEach(id => deleteSubtree(id));
      multiSelected.clear();
      const chk = document.getElementById("chkSelectAll");
      if (chk) chk.checked = false;
      state.selectedId = null;
      persist();
      render();
      return;
    }

    // Single delete (active note)
    const sel = state.selectedId;
    if (!sel) return;
    deleteSubtree(sel);
    persist();
    render();
  });

  btnSort.addEventListener("click", () => {
    state.sortMode = (state.sortMode === "manual") ? "created_desc" :
                     (state.sortMode === "created_desc") ? "title_asc" : "manual";
    persist();
    render();
  });

  // Search
  searchEl.addEventListener("input", () => {
    filter = (searchEl.value || "").trim().toLowerCase();
    if (filter){
      for (const id of Object.keys(state.notes)){
        if (matchesFilter(id)) {
          let p = state.parents[id];
          while(p){
            state.expanded[p] = true;
            p = state.parents[p];
          }
        }
      }
    }
    persist();
    render();
  });

  // ===== Sidebar resize =====
  const resizer = document.getElementById("resizer");
  const sidebar = document.getElementById("sidebar");
  let resizing = false;

  resizer.addEventListener("pointerdown", (e) => {
    resizing = true;
    resizer.setPointerCapture(e.pointerId);
  });
  resizer.addEventListener("pointermove", (e) => {
    if (!resizing) return;
    const w = Math.min(520, Math.max(260, e.clientX));
    sidebar.style.width = w + "px";
  });
  resizer.addEventListener("pointerup", (e) => {
    resizing = false;
    try { resizer.releasePointerCapture(e.pointerId); } catch {}
  });

  // ===== DnD =====
  let drag = null;

  function wireDnD(){
    // Dragging notes starts from the whole row (handled in renderNode pointermove threshold).
    // This function intentionally left minimal.
  }

  function clearDropHighlights(){
    document.querySelectorAll(".row.drop-child, .row.drop-sibling")
      .forEach(el => el.classList.remove("drop-child","drop-sibling"));
  }

  function startDrag(e, rowEl){
    if (!rowEl) return;
    e.preventDefault();
    e.stopPropagation();

    const draggedId = rowEl.dataset.noteId;
    if (!draggedId) return;

    const rect = rowEl.getBoundingClientRect();
    const offsetX = e.clientX - rect.left;
    const offsetY = e.clientY - rect.top;

    const ph = document.createElement("div");
    ph.className = "placeholder";
    ph.dataset.placeholder = "1";

    rowEl.classList.add("dragging-original");
    rowEl.parentElement.insertBefore(ph, rowEl.nextSibling);

    const ghost = rowEl.cloneNode(true);
    ghost.classList.add("drag-ghost");
    ghost.querySelectorAll(".meta").forEach(m => m.remove());
    document.body.appendChild(ghost);

    drag = { draggedId, originEl: rowEl, ph, ghost, offsetX, offsetY, startX: e.clientX, lastX: e.clientX, pullLeft: false };

    moveGhost(e.clientX, e.clientY);

    rowEl.setPointerCapture(e.pointerId);
    rowEl.onpointermove = (ev) => onDragMove(ev);
    rowEl.onpointerup = (ev) => endDrag(ev);
    rowEl.onpointercancel = (ev) => endDrag(ev);
  }

  function onDragMove(e){
    if (!drag) return;
    moveGhost(e.clientX, e.clientY);

        drag.lastX = e.clientX;
    drag.pullLeft = (drag.startX - drag.lastX) > 44; // pull-left threshold to promote one level
clearDropHighlights();

    const under = document.elementFromPoint(e.clientX, e.clientY);
    const hoverRow = under?.closest?.(".row");
    const hoverId = hoverRow?.dataset?.noteId;

    if (hoverRow && hoverId && hoverId !== drag.draggedId){
      const r = hoverRow.getBoundingClientRect();
      const edge = 9;
      const y = e.clientY;
      const asSibling = (y <= r.top + edge) || (y >= r.bottom - edge);

      if (asSibling){
        hoverRow.classList.add("drop-sibling");
        const before = (y <= r.top + edge);

        const targetNode = hoverRow.closest(".node");
        const container = targetNode?.parentElement;
        if (container){
          container.insertBefore(drag.ph, before ? targetNode : targetNode.nextSibling);
          drag.ph.dataset.siblingTarget = hoverId;
          drag.ph.dataset.siblingBefore = before ? "1" : "0";
          delete drag.ph.dataset.childTarget;
          return;
        }
      } else {
        hoverRow.classList.add("drop-child");
        const targetNode = hoverRow.closest(".node");
        const childZone = targetNode?.querySelector?.(".children[data-drop-zone='children']");
        if (childZone){
          childZone.style.display = "flex";
          childZone.appendChild(drag.ph);
          drag.ph.dataset.childTarget = hoverId;
          delete drag.ph.dataset.siblingTarget;
          delete drag.ph.dataset.siblingBefore;
          return;
        }
      }
    }

    delete drag.ph.dataset.childTarget;
    delete drag.ph.dataset.siblingTarget;
    delete drag.ph.dataset.siblingBefore;

    const zone = under?.closest?.("[data-drop-zone]");
    if (!zone) return;

    const items = Array.from(zone.children);
    const y = e.clientY;
    let inserted = false;

    for (const el of items){
      if (el === drag.ph) continue;
      const r = el.getBoundingClientRect();
      const mid = r.top + r.height/2;
      if (y < mid){
        zone.insertBefore(drag.ph, el);
        inserted = true;
        break;
      }
    }
    if (!inserted) zone.appendChild(drag.ph);
  }

  function endDrag(e){
    if (!drag) return;

    clearDropHighlights();

    try { drag.originEl.releasePointerCapture(e.pointerId); } catch {}
    drag.originEl.onpointermove = null;
    drag.originEl.onpointerup = null;
    drag.originEl.onpointercancel = null;

    const draggedId = drag.draggedId;
    const childTarget = drag.ph.dataset.childTarget;
    const siblingTarget = drag.ph.dataset.siblingTarget;

    let applied = false;

    // Pull-left gesture: promote one level up (outdent) without needing a drop target
    if (drag.pullLeft){
      const parentId = state.parents?.[draggedId];
      if (parentId){
        applied = attachAsSibling(parentId, draggedId, false); // after parent, under grandparent / roots
      }
    }

    if (!applied) {


    if (childTarget){
      const ok = attachAsChild(childTarget, draggedId, ensureChildren(childTarget).length);
      if (ok){
        state.expanded[childTarget] = true;
        applied = true;
      }
    } else if (siblingTarget){
      const before = drag.ph.dataset.siblingBefore === "1";
      applied = attachAsSibling(siblingTarget, draggedId, before);
    } else {
      const zone = drag.ph.closest?.("[data-drop-zone]");
      if (zone){
        const zoneType = zone.dataset.dropZone;
        const idx = placeho    }
    // end pull-left wrapper

    lderIndex(zone, drag.ph);

        if (zoneType === "root"){
          attachAsRoot(draggedId, idx);
          applied = true;
        } else if (zoneType === "children"){
          const parentId = zone.dataset.parentId;
          if (parentId) applied = attachAsChild(parentId, draggedId, idx);
        }
      }
    }

    drag.originEl.classList.remove("dragging-original");
    drag.ghost.remove();
    drag.ph.remove();
    drag = null;

    persist();
    render();
  }

  function placeholderIndex(container, phEl){
    const children = Array.from(container.children);
    return Math.max(0, children.indexOf(phEl));
  }

  function moveGhost(x, y){
    if (!drag) return;
    drag.ghost.style.transform = `translate(${x - drag.offsetX}px, ${y - drag.offsetY}px)`;
    drag.ghost.style.width = drag.originEl.getBoundingClientRect().width + "px";
  }


  // ===== Multi-select keyboard ops: Ctrl/‚åò+C, Ctrl/‚åò+X, Delete =====
  function getTopLevelSelected(){
    const ids = Array.from(multiSelected).filter(id => !!state.notes[id]);
    function hasSelectedAncestor(id){
      let p = state.parents[id] ?? null;
      while(p){
        if (multiSelected.has(p)) return true;
        p = state.parents[p] ?? null;
      }
      return false;
    }
    return ids.filter(id => !hasSelectedAncestor(id));
  }

  async function copySelectedToClipboard(){
    const top = getTopLevelSelected();
    if (!top.length) return;

    const text = top.map(id => {
      const title = titleOf(id);
      const body = state.notes[id]?.text ?? "";
      return `# ${title}\n${body}`;
    }).join("\n\n---\n\n");

    try{
      await navigator.clipboard.writeText(text);
    }catch{
      const ta = document.createElement("textarea");
      ta.value = text;
      ta.style.position = "fixed";
      ta.style.left = "-9999px";
      document.body.appendChild(ta);
      ta.select();
      try { document.execCommand("copy"); } catch {}
      ta.remove();
    }
  }

  async function cutSelected(){
    await copySelectedToClipboard();
    const top = getTopLevelSelected();
    for (const id of top) {
      if (state.notes[id]) deleteSubtree(id);
    }
    clearMulti();
    persist();
    render();
  }

  function deleteSelected(){
    const top = getTopLevelSelected();
    for (const id of top) {
      if (state.notes[id]) deleteSubtree(id);
    }
    clearMulti();
    persist();
    render();
  }

  document.addEventListener("keydown", async (e) => {
    const ae = document.activeElement;
    const tag = (ae?.tagName || "").toUpperCase();
    if (tag === "INPUT" || tag === "TEXTAREA" || ae === editorEl) return;

    const key = (e.key || "").toLowerCase();
    const mod = e.ctrlKey || e.metaKey;

    if (key === "escape" && multiSelected.size){
      clearMulti();
      render();
      return;
    }

    // ===== Tree keyboard navigation =====
    const nav = (key === "arrowup" || key === "arrowdown" || key === "arrowleft" || key === "arrowright" || key === "enter");
    if (nav) {
      const visible = getVisibleNoteIds();
      if (!visible.length) return;

      let cur = state.selectedId;
      if (!cur || !state.notes[cur]) cur = visible[0];

      const curIdx = visible.indexOf(cur);
      const hasKids = (state.children[cur] || []).length > 0;
      const isOpen = !!state.expanded[cur];

      function applyFocus(nextId, keepMulti=false, extend=false){
        if (!nextId) return;
        if (extend) {
          const base = selectionAnchorId || cur || nextId;
          const additive = mod; // Ctrl/‚åò+Shift adds to selection
          setRangeSelection(base, nextId, additive);
          state.selectedId = nextId;
          selectionAnchorId = base;
          persist();
          render();
          afterRenderFocus(nextId);
          return;
        }
        // no shift
        if (!keepMulti && multiSelected.size) clearMulti();
        selectionAnchorId = nextId;
        select(nextId);
        afterRenderFocus(nextId);
      }

      if (key === "arrowup") {
        e.preventDefault();
        const nextId = visible[Math.max(0, (curIdx === -1 ? 0 : curIdx - 1))];
        applyFocus(nextId, mod, e.shiftKey);
        return;
      }
      if (key === "arrowdown") {
        e.preventDefault();
        const nextId = visible[Math.min(visible.length - 1, (curIdx === -1 ? 0 : curIdx + 1))];
        applyFocus(nextId, mod, e.shiftKey);
        return;
      }
      if (key === "arrowleft") {
        e.preventDefault();
        if (hasKids && isOpen) {
          state.expanded[cur] = false;
          persist();
          render();
          afterRenderFocus(cur);
          return;
        }
        const p = state.parents[cur];
        if (p) {
          applyFocus(p, mod, e.shiftKey);
        }
        return;
      }
      if (key === "arrowright") {
        e.preventDefault();
        if (hasKids && !isOpen) {
          state.expanded[cur] = true;
          persist();
          render();
          afterRenderFocus(cur);
          return;
        }
        if (hasKids && isOpen) {
          const kids = getSortedIds(state.children[cur] || []);
          let nextId = null;
          for (const k of kids) {
            if (filter && !anyMatchInSubtree(k)) continue;
            // must be visible (rendered)
            const esc = (window.CSS && CSS.escape) ? CSS.escape(k) : k.replace(/"/g, '\"');
            if (document.querySelector(`.row[data-note-id="${esc}"]`)) { nextId = k; break; }
          }
          if (nextId) applyFocus(nextId, mod, e.shiftKey);
        }
        return;
      }
      if (key === "enter") {
        e.preventDefault();
        if (hasKids) {
          state.expanded[cur] = !state.expanded[cur];
          persist();
          render();
          afterRenderFocus(cur);
        }
        return;
      }
    }

    if (mod && key === "c" && multiSelected.size){
      e.preventDefault();
      await copySelectedToClipboard();
      return;
    }
    if (mod && key === "x" && multiSelected.size){
      e.preventDefault();
      await cutSelected();
      return;
    }
    if ((key === "delete" || key === "backspace") && multiSelected.size){
      e.preventDefault();
      deleteSelected();
      return;
    }
  });render();
})();
</script>
</body>
</html>
